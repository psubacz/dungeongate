
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth-service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dungeongate/cmd/auth-service/main.go (0.0%)</option>
				
				<option value="file1">github.com/dungeongate/cmd/game-service/main.go (0.0%)</option>
				
				<option value="file2">github.com/dungeongate/cmd/session-service/main.go (0.0%)</option>
				
				<option value="file3">github.com/dungeongate/cmd/user-service/main.go (0.0%)</option>
				
				<option value="file4">github.com/dungeongate/internal/auth/client.go (0.0%)</option>
				
				<option value="file5">github.com/dungeongate/internal/auth/proto/auth_service.pb.go (0.0%)</option>
				
				<option value="file6">github.com/dungeongate/internal/auth/proto/auth_service_grpc.pb.go (0.0%)</option>
				
				<option value="file7">github.com/dungeongate/internal/auth/service.go (0.0%)</option>
				
				<option value="file8">github.com/dungeongate/internal/games/games.go (0.0%)</option>
				
				<option value="file9">github.com/dungeongate/internal/games/kubernetes_controller.go (0.0%)</option>
				
				<option value="file10">github.com/dungeongate/internal/session/access_control.go (0.0%)</option>
				
				<option value="file11">github.com/dungeongate/internal/session/auth_middleware.go (0.0%)</option>
				
				<option value="file12">github.com/dungeongate/internal/session/game_client.go (0.0%)</option>
				
				<option value="file13">github.com/dungeongate/internal/session/grpc_service.go (0.0%)</option>
				
				<option value="file14">github.com/dungeongate/internal/session/pty_manager.go (25.0%)</option>
				
				<option value="file15">github.com/dungeongate/internal/session/save_manager.go (0.0%)</option>
				
				<option value="file16">github.com/dungeongate/internal/session/service_clients.go (17.3%)</option>
				
				<option value="file17">github.com/dungeongate/internal/session/session.go (0.0%)</option>
				
				<option value="file18">github.com/dungeongate/internal/session/ssh.go (10.0%)</option>
				
				<option value="file19">github.com/dungeongate/internal/session/types.go (0.0%)</option>
				
				<option value="file20">github.com/dungeongate/internal/user/user.go (0.0%)</option>
				
				<option value="file21">github.com/dungeongate/internal/user/user_login_attempts.go (30.8%)</option>
				
				<option value="file22">github.com/dungeongate/pkg/config/config.go (0.0%)</option>
				
				<option value="file23">github.com/dungeongate/pkg/config/game_config.go (0.0%)</option>
				
				<option value="file24">github.com/dungeongate/pkg/config/session_config.go (0.0%)</option>
				
				<option value="file25">github.com/dungeongate/pkg/config/user_config.go (0.0%)</option>
				
				<option value="file26">github.com/dungeongate/pkg/database/database.go (0.0%)</option>
				
				<option value="file27">github.com/dungeongate/pkg/encryption/encryption.go (0.0%)</option>
				
				<option value="file28">github.com/dungeongate/pkg/log/log.go (0.0%)</option>
				
				<option value="file29">github.com/dungeongate/pkg/metrics/prometheus.go (0.0%)</option>
				
				<option value="file30">github.com/dungeongate/pkg/ttyrec/ttyrec.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "flag"
        "fmt"
        "log"
        "net"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/dungeongate/internal/auth"
        "github.com/dungeongate/internal/auth/proto"
        "github.com/dungeongate/internal/user"
        "github.com/dungeongate/pkg/config"
        "github.com/dungeongate/pkg/database"
        "github.com/dungeongate/pkg/encryption"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

var (
        version   string = "dev"
        buildTime string = "unknown"
        gitCommit string = "unknown"
)

func main() <span class="cov0" title="0">{
        var (
                configFile  = flag.String("config", "configs/development/local.yaml", "Path to configuration file")
                showVersion = flag.Bool("version", false, "Show version information")
        )
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("DungeonGate Auth Service\n")
                fmt.Printf("Version: %s\n", version)
                fmt.Printf("Build Time: %s\n", buildTime)
                fmt.Printf("Git Commit: %s\n", gitCommit)
                return
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.LoadUserServiceConfig(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Setup database
        <span class="cov0" title="0">db, err := database.NewConnection(cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Setup encryption
        encryptor, err := encryption.New(&amp;config.EncryptionConfig{
                Enabled:             true,
                Algorithm:           "AES-256-GCM",
                KeyRotationInterval: "24h",
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize encryption: %v", err)
        }</span>

        // Setup user service
        <span class="cov0" title="0">sessionCfg := config.GetDefaultDevelopmentConfig()
        userService, err := user.NewService(db, cfg, sessionCfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create user service: %v", err)
        }</span>

        // Generate JWT secret if not provided
        <span class="cov0" title="0">jwtSecret := os.Getenv("JWT_SECRET")
        if jwtSecret == "" </span><span class="cov0" title="0">{
                log.Println("JWT_SECRET not set, generating random secret (not recommended for production)")
                secretBytes := make([]byte, 32)
                if _, err := rand.Read(secretBytes); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to generate JWT secret: %v", err)
                }</span>
                <span class="cov0" title="0">jwtSecret = hex.EncodeToString(secretBytes)</span>
        }

        // Setup auth service
        <span class="cov0" title="0">authConfig := &amp;auth.Config{
                JWTSecret:              jwtSecret,
                JWTIssuer:              "dungeongate-auth",
                AccessTokenExpiration:  15 * time.Minute,
                RefreshTokenExpiration: 7 * 24 * time.Hour,
                MaxLoginAttempts:       3,
                LockoutDuration:        15 * time.Minute,
        }

        authService := auth.NewService(db, userService, *encryptor, authConfig)

        // Setup context for graceful shutdown
        _, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Setup gRPC server
        grpcServer := grpc.NewServer()
        proto.RegisterAuthServiceServer(grpcServer, authService)
        reflection.Register(grpcServer)

        // Start gRPC server
        grpcListener, err := net.Listen("tcp", ":8082")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen on port 8082: %v", err)
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Printf("Starting Auth Service gRPC server on port 8082")
                if err := grpcServer.Serve(grpcListener); err != nil </span><span class="cov0" title="0">{
                        log.Printf("gRPC server error: %v", err)
                }</span>
        }()

        // Setup HTTP server for health checks
        <span class="cov0" title="0">httpServer := &amp;http.Server{
                Addr: fmt.Sprintf(":%d", 8081),
                Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if r.URL.Path == "/health" </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusOK)
                                fmt.Fprintf(w, "Auth Service OK")
                                return
                        }</span>
                        <span class="cov0" title="0">w.WriteHeader(http.StatusNotImplemented)
                        fmt.Fprintf(w, "Auth Service - gRPC API available on port 8082")</span>
                }),
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Printf("Starting Auth Service HTTP server on port 8081")
                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP server error: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("Shutting down gracefully...")

        // Shutdown gRPC server
        grpcServer.GracefulStop()

        // Shutdown HTTP server
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        if err := httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Printf("HTTP server shutdown error: %v", err)
        }</span>

        // Cancel context
        <span class="cov0" title="0">cancel()

        log.Println("Auth Service stopped")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/dungeongate/pkg/config"
        "github.com/dungeongate/pkg/database"
)

var (
        version   string = "dev"
        buildTime string = "unknown"
        gitCommit string = "unknown"
)

func main() <span class="cov0" title="0">{
        var (
                configFile  = flag.String("config", "configs/development/local.yaml", "Path to configuration file")
                showVersion = flag.Bool("version", false, "Show version information")
        )
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("DungeonGate Game Service\n")
                fmt.Printf("Version: %s\n", version)
                fmt.Printf("Build Time: %s\n", buildTime)
                fmt.Printf("Git Commit: %s\n", gitCommit)
                return
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.LoadGameServiceConfig(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Setup database
        <span class="cov0" title="0">db, err := database.NewConnection(cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Setup context for graceful shutdown
        _, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Setup HTTP server
        httpServer := &amp;http.Server{
                Addr: fmt.Sprintf(":%d", cfg.Server.Port),
                Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if r.URL.Path == "/health" </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusOK)
                                fmt.Fprintf(w, "Game Service OK")
                                return
                        }</span>
                        <span class="cov0" title="0">w.WriteHeader(http.StatusNotImplemented)
                        fmt.Fprintf(w, "Game Service - Implementation in progress")</span>
                }),
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Printf("Starting Game Service HTTP server on port %d", cfg.Server.Port)
                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP server error: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("Shutting down gracefully...")

        // Shutdown HTTP server
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        if err := httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Printf("HTTP server shutdown error: %v", err)
        }</span>

        // Cancel context
        <span class="cov0" title="0">cancel()

        log.Println("Game Service stopped")

        // Prevent unused variable warnings
        _ = db</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/dungeongate/internal/session"
        "github.com/dungeongate/internal/user"
        "github.com/dungeongate/pkg/config"
        "github.com/dungeongate/pkg/database"
        "github.com/dungeongate/pkg/encryption"
        "github.com/dungeongate/pkg/ttyrec"
)

var (
        version   string = "dev"
        buildTime string = "unknown"
        gitCommit string = "unknown"
)

func main() <span class="cov0" title="0">{
        var (
                configFile  = flag.String("config", "configs/development/local.yaml", "Path to configuration file")
                showVersion = flag.Bool("version", false, "Show version information")
        )
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("DungeonGate Session Service\n")
                fmt.Printf("Version: %s\n", version)
                fmt.Printf("Build Time: %s\n", buildTime)
                fmt.Printf("Git Commit: %s\n", gitCommit)
                return
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.LoadSessionServiceConfig(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Setup database
        <span class="cov0" title="0">db, err := database.NewConnection(cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Setup encryption
        encryptor, err := encryption.New(cfg.Encryption)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize encryption: %v", err)
        }</span>

        // Setup TTY recorder
        <span class="cov0" title="0">recorder, err := ttyrec.NewRecorder(cfg.SessionManagement.TTYRec)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize TTY recorder: %v", err)
        }</span>

        // Setup user service
        <span class="cov0" title="0">userConfig := &amp;config.UserServiceConfig{
                Database: cfg.Database,
        }
        userService, err := user.NewService(db, userConfig, cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize user service: %v", err)
        }</span>

        // Setup auth middleware if enabled
        <span class="cov0" title="0">var authMiddleware *session.AuthMiddleware
        if cfg.Auth != nil &amp;&amp; cfg.Auth.Enabled </span><span class="cov0" title="0">{
                authMiddleware, err = session.NewAuthMiddleware(cfg.Auth.ServiceAddress, cfg.Auth.Enabled)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to initialize auth middleware: %v", err)
                        log.Printf("Falling back to direct user service authentication")
                }</span>
        }

        // Setup session service with or without auth middleware
        <span class="cov0" title="0">var sessionService *session.Service
        if authMiddleware != nil </span><span class="cov0" title="0">{
                sessionService = session.NewServiceWithAuth(db, encryptor, recorder, cfg, userService, authMiddleware)
        }</span> else<span class="cov0" title="0"> {
                sessionService = session.NewService(db, encryptor, recorder, cfg, userService)
        }</span>

        // Setup context for graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start SSH server
        sshServer, err := session.NewSSHServer(sessionService, cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create SSH server: %v", err)
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Printf("Starting SSH server on %s:%d", cfg.SSH.Host, cfg.SSH.Port)
                if err := sshServer.Start(ctx, cfg.SSH.Port); err != nil </span><span class="cov0" title="0">{
                        log.Printf("SSH server error: %v", err)
                }</span>
        }()

        // Start HTTP server
        <span class="cov0" title="0">httpHandler := session.NewHTTPHandler(sessionService)
        httpServer := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", cfg.Server.Port),
                Handler: httpHandler,
        }

        go func() </span><span class="cov0" title="0">{
                log.Printf("Starting HTTP server on port %d", cfg.Server.Port)
                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP server error: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("Shutting down gracefully...")

        // Shutdown HTTP server
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        if err := httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Printf("HTTP server shutdown error: %v", err)
        }</span>

        // Cancel context to stop SSH server and other services
        <span class="cov0" title="0">cancel()

        log.Println("Server stopped")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/dungeongate/internal/user"
        "github.com/dungeongate/pkg/config"
        "github.com/dungeongate/pkg/database"
        "github.com/dungeongate/pkg/encryption"
)

var (
        version   string = "dev"
        buildTime string = "unknown"
        gitCommit string = "unknown"
)

func main() <span class="cov0" title="0">{
        var (
                configFile  = flag.String("config", "configs/development/local.yaml", "Path to configuration file")
                showVersion = flag.Bool("version", false, "Show version information")
        )
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("DungeonGate User Service\n")
                fmt.Printf("Version: %s\n", version)
                fmt.Printf("Build Time: %s\n", buildTime)
                fmt.Printf("Git Commit: %s\n", gitCommit)
                return
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.LoadUserServiceConfig(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Load session configuration (needed for user service)
        <span class="cov0" title="0">sessionCfg, err := config.LoadSessionServiceConfig(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load session configuration: %v", err)
        }</span>

        // Setup database
        <span class="cov0" title="0">db, err := database.NewConnection(cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Setup encryption
        encryptor, err := encryption.New(&amp;config.EncryptionConfig{
                Enabled:             true,
                Algorithm:           "AES-256-GCM",
                KeyRotationInterval: "24h",
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize encryption: %v", err)
        }</span>

        // Setup user service
        <span class="cov0" title="0">userService, err := user.NewService(db, cfg, sessionCfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize user service: %v", err)
        }</span>

        // Setup context for graceful shutdown
        <span class="cov0" title="0">_, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Setup HTTP server
        httpServer := &amp;http.Server{
                Addr: fmt.Sprintf(":%d", 8082),
                Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if r.URL.Path == "/health" </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusOK)
                                fmt.Fprintf(w, "User Service OK")
                                return
                        }</span>
                        <span class="cov0" title="0">w.WriteHeader(http.StatusNotImplemented)
                        fmt.Fprintf(w, "User Service - Implementation in progress")</span>
                }),
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Printf("Starting User Service HTTP server on port 8082")
                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP server error: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("Shutting down gracefully...")

        // Shutdown HTTP server
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        if err := httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Printf("HTTP server shutdown error: %v", err)
        }</span>

        // Cancel context
        <span class="cov0" title="0">cancel()

        log.Println("User Service stopped")

        // Prevent unused variable warnings
        _ = encryptor
        _ = userService</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "context"
        "fmt"
        "time"

        "github.com/dungeongate/internal/auth/proto"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/protobuf/types/known/emptypb"
)

// Client is a gRPC client for the Auth service
type Client struct {
        conn   *grpc.ClientConn
        client proto.AuthServiceClient
}

// NewClient creates a new Auth service client
func NewClient(address string) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to auth service: %w", err)
        }</span>

        <span class="cov0" title="0">client := proto.NewAuthServiceClient(conn)

        return &amp;Client{
                conn:   conn,
                client: client,
        }, nil</span>
}

// Close closes the gRPC connection
func (c *Client) Close() error <span class="cov0" title="0">{
        return c.conn.Close()
}</span>

// Login authenticates a user
func (c *Client) Login(ctx context.Context, username, password, clientIP string) (*proto.LoginResponse, error) <span class="cov0" title="0">{
        return c.client.Login(ctx, &amp;proto.LoginRequest{
                Username: username,
                Password: password,
                ClientIp: clientIP,
        })
}</span>

// Logout logs out a user
func (c *Client) Logout(ctx context.Context, accessToken, refreshToken string) error <span class="cov0" title="0">{
        _, err := c.client.Logout(ctx, &amp;proto.LogoutRequest{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
        })
        return err
}</span>

// ValidateToken validates an access token
func (c *Client) ValidateToken(ctx context.Context, accessToken string) (*proto.ValidateTokenResponse, error) <span class="cov0" title="0">{
        return c.client.ValidateToken(ctx, &amp;proto.ValidateTokenRequest{
                AccessToken: accessToken,
        })
}</span>

// RefreshToken refreshes an access token
func (c *Client) RefreshToken(ctx context.Context, refreshToken string) (*proto.RefreshTokenResponse, error) <span class="cov0" title="0">{
        return c.client.RefreshToken(ctx, &amp;proto.RefreshTokenRequest{
                RefreshToken: refreshToken,
        })
}</span>

// GetUserInfo gets user information from a token
func (c *Client) GetUserInfo(ctx context.Context, accessToken string) (*proto.GetUserInfoResponse, error) <span class="cov0" title="0">{
        return c.client.GetUserInfo(ctx, &amp;proto.GetUserInfoRequest{
                AccessToken: accessToken,
        })
}</span>

// Health checks the health of the auth service
func (c *Client) Health(ctx context.Context) (*proto.HealthResponse, error) <span class="cov0" title="0">{
        return c.client.Health(ctx, &amp;emptypb.Empty{})
}</span>

// AuthServiceClientImpl implements the AuthServiceClient interface for session service
type AuthServiceClientImpl struct {
        client *Client
}

// NewAuthServiceClient creates a new AuthServiceClient implementation
func NewAuthServiceClient(authServiceAddress string) (*AuthServiceClientImpl, error) <span class="cov0" title="0">{
        client, err := NewClient(authServiceAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;AuthServiceClientImpl{
                client: client,
        }, nil</span>
}

// Close closes the client connection
func (a *AuthServiceClientImpl) Close() error <span class="cov0" title="0">{
        return a.client.Close()
}</span>

// Login implements the session service AuthServiceClient interface
func (a *AuthServiceClientImpl) Login(ctx context.Context, req *SessionLoginRequest) (*SessionLoginResponse, error) <span class="cov0" title="0">{
        protoResp, err := a.client.Login(ctx, req.Username, req.Password, req.ClientIP)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert proto response to session service types
        <span class="cov0" title="0">resp := &amp;SessionLoginResponse{
                Success:      protoResp.Success,
                Error:        protoResp.Error,
                AccessToken:  protoResp.AccessToken,
                RefreshToken: protoResp.RefreshToken,
                ExpiresAt:    time.Unix(protoResp.AccessTokenExpiresAt, 0),
        }

        if protoResp.User != nil </span><span class="cov0" title="0">{
                sessionUser := &amp;SessionUser{
                        ID:              protoResp.User.Id,
                        Username:        protoResp.User.Username,
                        Email:           protoResp.User.Email,
                        IsAuthenticated: protoResp.User.IsAuthenticated,
                        IsActive:        protoResp.User.IsActive,
                        IsAdmin:         protoResp.User.IsAdmin,
                        CreatedAt:       time.Unix(protoResp.User.CreatedAt.Seconds, int64(protoResp.User.CreatedAt.Nanos)),
                        UpdatedAt:       time.Unix(protoResp.User.UpdatedAt.Seconds, int64(protoResp.User.UpdatedAt.Nanos)),
                }
                
                // Handle LastLogin safely - it can be nil for newly registered users
                if protoResp.User.LastLogin != nil </span><span class="cov0" title="0">{
                        sessionUser.LastLogin = time.Unix(protoResp.User.LastLogin.Seconds, int64(protoResp.User.LastLogin.Nanos))
                }</span>
                
                <span class="cov0" title="0">resp.User = sessionUser</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}

// Logout implements the session service AuthServiceClient interface
func (a *AuthServiceClientImpl) Logout(ctx context.Context, token string) error <span class="cov0" title="0">{
        return a.client.Logout(ctx, token, "")
}</span>

// ValidateToken implements the session service AuthServiceClient interface
func (a *AuthServiceClientImpl) ValidateToken(ctx context.Context, token string) (*SessionUser, error) <span class="cov0" title="0">{
        protoResp, err := a.client.ValidateToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !protoResp.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token: %s", protoResp.Error)
        }</span>

        <span class="cov0" title="0">if protoResp.User == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user information in token response")
        }</span>

        <span class="cov0" title="0">return &amp;SessionUser{
                ID:              protoResp.User.Id,
                Username:        protoResp.User.Username,
                Email:           protoResp.User.Email,
                IsAuthenticated: protoResp.User.IsAuthenticated,
                IsActive:        protoResp.User.IsActive,
                IsAdmin:         protoResp.User.IsAdmin,
                CreatedAt:       time.Unix(protoResp.User.CreatedAt.Seconds, int64(protoResp.User.CreatedAt.Nanos)),
                UpdatedAt:       time.Unix(protoResp.User.UpdatedAt.Seconds, int64(protoResp.User.UpdatedAt.Nanos)),
                LastLogin:       time.Unix(protoResp.User.LastLogin.Seconds, int64(protoResp.User.LastLogin.Nanos)),
        }, nil</span>
}

// RefreshToken implements the session service AuthServiceClient interface
func (a *AuthServiceClientImpl) RefreshToken(ctx context.Context, refreshToken string) (*SessionLoginResponse, error) <span class="cov0" title="0">{
        protoResp, err := a.client.RefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;SessionLoginResponse{
                Success:      protoResp.Success,
                Error:        protoResp.Error,
                AccessToken:  protoResp.AccessToken,
                RefreshToken: protoResp.RefreshToken,
                ExpiresAt:    time.Unix(protoResp.AccessTokenExpiresAt, 0),
        }, nil</span>
}

// Types for session service compatibility
type SessionLoginRequest struct {
        Username string
        Password string
        ClientIP string
}

type SessionLoginResponse struct {
        Success      bool
        Error        string
        AccessToken  string
        RefreshToken string
        ExpiresAt    time.Time
        User         *SessionUser
}

type SessionUser struct {
        ID              string
        Username        string
        Email           string
        IsAuthenticated bool
        IsActive        bool
        IsAdmin         bool
        CreatedAt       time.Time
        UpdatedAt       time.Time
        LastLogin       time.Time
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: internal/auth/proto/auth_service.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// LoginRequest represents a login request
type LoginRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Password      string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        ClientId      string                 `protobuf:"bytes,3,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
        ClientIp      string                 `protobuf:"bytes,4,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
        UserAgent     string                 `protobuf:"bytes,5,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
        Metadata      map[string]string      `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *LoginRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetClientId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetClientIp() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientIp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetUserAgent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserAgent
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// LoginResponse represents a login response
type LoginResponse struct {
        state     protoimpl.MessageState `protogen:"open.v1"`
        Success   bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error     string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        ErrorCode string                 `protobuf:"bytes,3,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"` // "invalid_credentials", "account_locked", "user_not_found", etc.
        // Tokens (only present on successful login)
        AccessToken           string `protobuf:"bytes,4,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken          string `protobuf:"bytes,5,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        AccessTokenExpiresAt  int64  `protobuf:"varint,6,opt,name=access_token_expires_at,json=accessTokenExpiresAt,proto3" json:"access_token_expires_at,omitempty"`
        RefreshTokenExpiresAt int64  `protobuf:"varint,7,opt,name=refresh_token_expires_at,json=refreshTokenExpiresAt,proto3" json:"refresh_token_expires_at,omitempty"`
        // User info (only present on successful login)
        User *User `protobuf:"bytes,8,opt,name=user,proto3" json:"user,omitempty"`
        // Rate limiting info
        RemainingAttempts int32 `protobuf:"varint,9,opt,name=remaining_attempts,json=remainingAttempts,proto3" json:"remaining_attempts,omitempty"`
        RetryAfterSeconds int64 `protobuf:"varint,10,opt,name=retry_after_seconds,json=retryAfterSeconds,proto3" json:"retry_after_seconds,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *LoginResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LoginResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetErrorCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ErrorCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetAccessTokenExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessTokenExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LoginResponse) GetRefreshTokenExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshTokenExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LoginResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LoginResponse) GetRemainingAttempts() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RemainingAttempts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LoginResponse) GetRetryAfterSeconds() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RetryAfterSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// LogoutRequest represents a logout request
type LogoutRequest struct {
        state                 protoimpl.MessageState `protogen:"open.v1"`
        AccessToken           string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken          string                 `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        UserId                string                 `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        InvalidateAllSessions bool                   `protobuf:"varint,4,opt,name=invalidate_all_sessions,json=invalidateAllSessions,proto3" json:"invalidate_all_sessions,omitempty"`
        unknownFields         protoimpl.UnknownFields
        sizeCache             protoimpl.SizeCache
}

func (x *LogoutRequest) Reset() <span class="cov0" title="0">{
        *x = LogoutRequest{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *LogoutRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogoutRequest) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogoutRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogoutRequest) GetInvalidateAllSessions() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InvalidateAllSessions
        }</span>
        <span class="cov0" title="0">return false</span>
}

// LogoutResponse represents a logout response
type LogoutResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogoutResponse) Reset() <span class="cov0" title="0">{
        *x = LogoutResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.
func (*LogoutResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LogoutResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogoutResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// RefreshTokenRequest represents a token refresh request
type RefreshTokenRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        RefreshToken  string                 `protobuf:"bytes,1,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ClientId      string                 `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RefreshTokenRequest) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenRequest{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RefreshTokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenRequest.ProtoReflect.Descriptor instead.
func (*RefreshTokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{4}
}</span>

func (x *RefreshTokenRequest) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RefreshTokenRequest) GetClientId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// RefreshTokenResponse represents a token refresh response
type RefreshTokenResponse struct {
        state                 protoimpl.MessageState `protogen:"open.v1"`
        Success               bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error                 string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        AccessToken           string                 `protobuf:"bytes,3,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken          string                 `protobuf:"bytes,4,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        AccessTokenExpiresAt  int64                  `protobuf:"varint,5,opt,name=access_token_expires_at,json=accessTokenExpiresAt,proto3" json:"access_token_expires_at,omitempty"`
        RefreshTokenExpiresAt int64                  `protobuf:"varint,6,opt,name=refresh_token_expires_at,json=refreshTokenExpiresAt,proto3" json:"refresh_token_expires_at,omitempty"`
        unknownFields         protoimpl.UnknownFields
        sizeCache             protoimpl.SizeCache
}

func (x *RefreshTokenResponse) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RefreshTokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenResponse.ProtoReflect.Descriptor instead.
func (*RefreshTokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{5}
}</span>

func (x *RefreshTokenResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *RefreshTokenResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RefreshTokenResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RefreshTokenResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RefreshTokenResponse) GetAccessTokenExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessTokenExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *RefreshTokenResponse) GetRefreshTokenExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshTokenExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ValidateTokenRequest represents a token validation request
type ValidateTokenRequest struct {
        state               protoimpl.MessageState `protogen:"open.v1"`
        AccessToken         string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RequiredPermissions []string               `protobuf:"bytes,2,rep,name=required_permissions,json=requiredPermissions,proto3" json:"required_permissions,omitempty"`
        unknownFields       protoimpl.UnknownFields
        sizeCache           protoimpl.SizeCache
}

func (x *ValidateTokenRequest) Reset() <span class="cov0" title="0">{
        *x = ValidateTokenRequest{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ValidateTokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidateTokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidateTokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidateTokenRequest.ProtoReflect.Descriptor instead.
func (*ValidateTokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{6}
}</span>

func (x *ValidateTokenRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ValidateTokenRequest) GetRequiredPermissions() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequiredPermissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateTokenResponse represents a token validation response
type ValidateTokenResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Valid         bool                   `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        User          *User                  `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
        Permissions   []string               `protobuf:"bytes,4,rep,name=permissions,proto3" json:"permissions,omitempty"`
        ExpiresAt     int64                  `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ValidateTokenResponse) Reset() <span class="cov0" title="0">{
        *x = ValidateTokenResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ValidateTokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidateTokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidateTokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidateTokenResponse.ProtoReflect.Descriptor instead.
func (*ValidateTokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{7}
}</span>

func (x *ValidateTokenResponse) GetValid() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Valid
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ValidateTokenResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ValidateTokenResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ValidateTokenResponse) GetPermissions() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ValidateTokenResponse) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// GetUserInfoRequest represents a request to get user info
type GetUserInfoRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserInfoRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserInfoRequest{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserInfoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserInfoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserInfoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserInfoRequest.ProtoReflect.Descriptor instead.
func (*GetUserInfoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{8}
}</span>

func (x *GetUserInfoRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetUserInfoResponse represents a response with user info
type GetUserInfoResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        User          *User                  `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserInfoResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserInfoResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserInfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserInfoResponse.ProtoReflect.Descriptor instead.
func (*GetUserInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetUserInfoResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *GetUserInfoResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserInfoResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ChangePasswordRequest represents a password change request
type ChangePasswordRequest struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        AccessToken     string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        CurrentPassword string                 `protobuf:"bytes,2,opt,name=current_password,json=currentPassword,proto3" json:"current_password,omitempty"`
        NewPassword     string                 `protobuf:"bytes,3,opt,name=new_password,json=newPassword,proto3" json:"new_password,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *ChangePasswordRequest) Reset() <span class="cov0" title="0">{
        *x = ChangePasswordRequest{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ChangePasswordRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ChangePasswordRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ChangePasswordRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ChangePasswordRequest.ProtoReflect.Descriptor instead.
func (*ChangePasswordRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{10}
}</span>

func (x *ChangePasswordRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ChangePasswordRequest) GetCurrentPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrentPassword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ChangePasswordRequest) GetNewPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewPassword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ChangePasswordResponse represents a password change response
type ChangePasswordResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ChangePasswordResponse) Reset() <span class="cov0" title="0">{
        *x = ChangePasswordResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ChangePasswordResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ChangePasswordResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ChangePasswordResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ChangePasswordResponse.ProtoReflect.Descriptor instead.
func (*ChangePasswordResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{11}
}</span>

func (x *ChangePasswordResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ChangePasswordResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ResetPasswordRequest represents a password reset request
type ResetPasswordRequest struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        UsernameOrEmail string                 `protobuf:"bytes,1,opt,name=username_or_email,json=usernameOrEmail,proto3" json:"username_or_email,omitempty"`
        ClientIp        string                 `protobuf:"bytes,2,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *ResetPasswordRequest) Reset() <span class="cov0" title="0">{
        *x = ResetPasswordRequest{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ResetPasswordRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ResetPasswordRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ResetPasswordRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ResetPasswordRequest.ProtoReflect.Descriptor instead.
func (*ResetPasswordRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{12}
}</span>

func (x *ResetPasswordRequest) GetUsernameOrEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UsernameOrEmail
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ResetPasswordRequest) GetClientIp() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientIp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ResetPasswordResponse represents a password reset response
type ResetPasswordResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ResetPasswordResponse) Reset() <span class="cov0" title="0">{
        *x = ResetPasswordResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ResetPasswordResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ResetPasswordResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ResetPasswordResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ResetPasswordResponse.ProtoReflect.Descriptor instead.
func (*ResetPasswordResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{13}
}</span>

func (x *ResetPasswordResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ResetPasswordResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ResetPasswordResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// VerifyPasswordResetRequest represents a password reset verification request
type VerifyPasswordResetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ResetToken    string                 `protobuf:"bytes,1,opt,name=reset_token,json=resetToken,proto3" json:"reset_token,omitempty"`
        NewPassword   string                 `protobuf:"bytes,2,opt,name=new_password,json=newPassword,proto3" json:"new_password,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *VerifyPasswordResetRequest) Reset() <span class="cov0" title="0">{
        *x = VerifyPasswordResetRequest{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *VerifyPasswordResetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VerifyPasswordResetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VerifyPasswordResetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VerifyPasswordResetRequest.ProtoReflect.Descriptor instead.
func (*VerifyPasswordResetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{14}
}</span>

func (x *VerifyPasswordResetRequest) GetResetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ResetToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *VerifyPasswordResetRequest) GetNewPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewPassword
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// VerifyPasswordResetResponse represents a password reset verification response
type VerifyPasswordResetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *VerifyPasswordResetResponse) Reset() <span class="cov0" title="0">{
        *x = VerifyPasswordResetResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *VerifyPasswordResetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VerifyPasswordResetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VerifyPasswordResetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VerifyPasswordResetResponse.ProtoReflect.Descriptor instead.
func (*VerifyPasswordResetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{15}
}</span>

func (x *VerifyPasswordResetResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *VerifyPasswordResetResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetLoginAttemptsRequest represents a request to get login attempts
type GetLoginAttemptsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        ClientIp      string                 `protobuf:"bytes,2,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetLoginAttemptsRequest) Reset() <span class="cov0" title="0">{
        *x = GetLoginAttemptsRequest{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetLoginAttemptsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetLoginAttemptsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetLoginAttemptsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetLoginAttemptsRequest.ProtoReflect.Descriptor instead.
func (*GetLoginAttemptsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{16}
}</span>

func (x *GetLoginAttemptsRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetLoginAttemptsRequest) GetClientIp() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientIp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetLoginAttemptsResponse represents a response with login attempts
type GetLoginAttemptsResponse struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        FailedAttempts    int32                  `protobuf:"varint,1,opt,name=failed_attempts,json=failedAttempts,proto3" json:"failed_attempts,omitempty"`
        AccountLocked     bool                   `protobuf:"varint,2,opt,name=account_locked,json=accountLocked,proto3" json:"account_locked,omitempty"`
        LockedUntil       int64                  `protobuf:"varint,3,opt,name=locked_until,json=lockedUntil,proto3" json:"locked_until,omitempty"`
        RemainingAttempts int32                  `protobuf:"varint,4,opt,name=remaining_attempts,json=remainingAttempts,proto3" json:"remaining_attempts,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *GetLoginAttemptsResponse) Reset() <span class="cov0" title="0">{
        *x = GetLoginAttemptsResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetLoginAttemptsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetLoginAttemptsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetLoginAttemptsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetLoginAttemptsResponse.ProtoReflect.Descriptor instead.
func (*GetLoginAttemptsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{17}
}</span>

func (x *GetLoginAttemptsResponse) GetFailedAttempts() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FailedAttempts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetLoginAttemptsResponse) GetAccountLocked() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccountLocked
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *GetLoginAttemptsResponse) GetLockedUntil() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LockedUntil
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetLoginAttemptsResponse) GetRemainingAttempts() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RemainingAttempts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// HealthResponse represents the health check response
type HealthResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        string                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"` // "healthy", "unhealthy", "degraded"
        Details       map[string]string      `protobuf:"bytes,2,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        Timestamp     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HealthResponse) Reset() <span class="cov0" title="0">{
        *x = HealthResponse{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HealthResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthResponse.ProtoReflect.Descriptor instead.
func (*HealthResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{18}
}</span>

func (x *HealthResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HealthResponse) GetDetails() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Details
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *HealthResponse) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// User represents user information
type User struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Id              string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Username        string                 `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        Email           string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        IsActive        bool                   `protobuf:"varint,4,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
        IsAdmin         bool                   `protobuf:"varint,5,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
        IsAuthenticated bool                   `protobuf:"varint,6,opt,name=is_authenticated,json=isAuthenticated,proto3" json:"is_authenticated,omitempty"`
        EmailVerified   bool                   `protobuf:"varint,7,opt,name=email_verified,json=emailVerified,proto3" json:"email_verified,omitempty"`
        CreatedAt       *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt       *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        LastLogin       *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=last_login,json=lastLogin,proto3" json:"last_login,omitempty"`
        Roles           []string               `protobuf:"bytes,11,rep,name=roles,proto3" json:"roles,omitempty"`
        Permissions     []string               `protobuf:"bytes,12,rep,name=permissions,proto3" json:"permissions,omitempty"`
        Metadata        map[string]string      `protobuf:"bytes,13,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{19}
}</span>

func (x *User) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetIsActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsActive
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *User) GetIsAdmin() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAdmin
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *User) GetIsAuthenticated() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAuthenticated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *User) GetEmailVerified() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EmailVerified
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *User) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetLastLogin() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastLogin
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetRoles() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Roles
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetPermissions() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// TokenClaims represents JWT token claims
type TokenClaims struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Username      string                 `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        Email         string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        Roles         []string               `protobuf:"bytes,4,rep,name=roles,proto3" json:"roles,omitempty"`
        Permissions   []string               `protobuf:"bytes,5,rep,name=permissions,proto3" json:"permissions,omitempty"`
        ClientId      string                 `protobuf:"bytes,6,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
        SessionId     string                 `protobuf:"bytes,7,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
        IssuedAt      int64                  `protobuf:"varint,8,opt,name=issued_at,json=issuedAt,proto3" json:"issued_at,omitempty"`
        ExpiresAt     int64                  `protobuf:"varint,9,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        NotBefore     int64                  `protobuf:"varint,10,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
        Issuer        string                 `protobuf:"bytes,11,opt,name=issuer,proto3" json:"issuer,omitempty"`
        Audience      string                 `protobuf:"bytes,12,opt,name=audience,proto3" json:"audience,omitempty"`
        Metadata      map[string]string      `protobuf:"bytes,13,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TokenClaims) Reset() <span class="cov0" title="0">{
        *x = TokenClaims{}
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TokenClaims) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TokenClaims) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TokenClaims) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_auth_proto_auth_service_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TokenClaims.ProtoReflect.Descriptor instead.
func (*TokenClaims) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_auth_proto_auth_service_proto_rawDescGZIP(), []int{20}
}</span>

func (x *TokenClaims) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenClaims) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenClaims) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenClaims) GetRoles() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Roles
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TokenClaims) GetPermissions() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TokenClaims) GetClientId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenClaims) GetSessionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenClaims) GetIssuedAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IssuedAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TokenClaims) GetExpiresAt() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TokenClaims) GetNotBefore() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotBefore
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TokenClaims) GetIssuer() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Issuer
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenClaims) GetAudience() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Audience
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TokenClaims) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_internal_auth_proto_auth_service_proto protoreflect.FileDescriptor

const file_internal_auth_proto_auth_service_proto_rawDesc = "" +
        "\n" +
        "&amp;internal/auth/proto/auth_service.proto\x12\x04auth\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\x9a\x02\n" +
        "\fLoginRequest\x12\x1a\n" +
        "\busername\x18\x01 \x01(\tR\busername\x12\x1a\n" +
        "\bpassword\x18\x02 \x01(\tR\bpassword\x12\x1b\n" +
        "\tclient_id\x18\x03 \x01(\tR\bclientId\x12\x1b\n" +
        "\tclient_ip\x18\x04 \x01(\tR\bclientIp\x12\x1d\n" +
        "\n" +
        "user_agent\x18\x05 \x01(\tR\tuserAgent\x12&lt;\n" +
        "\bmetadata\x18\x06 \x03(\v2 .auth.LoginRequest.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x95\x03\n" +
        "\rLoginResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\x12\x1d\n" +
        "\n" +
        "error_code\x18\x03 \x01(\tR\terrorCode\x12!\n" +
        "\faccess_token\x18\x04 \x01(\tR\vaccessToken\x12#\n" +
        "\rrefresh_token\x18\x05 \x01(\tR\frefreshToken\x125\n" +
        "\x17access_token_expires_at\x18\x06 \x01(\x03R\x14accessTokenExpiresAt\x127\n" +
        "\x18refresh_token_expires_at\x18\a \x01(\x03R\x15refreshTokenExpiresAt\x12\x1e\n" +
        "\x04user\x18\b \x01(\v2\n" +
        ".auth.UserR\x04user\x12-\n" +
        "\x12remaining_attempts\x18\t \x01(\x05R\x11remainingAttempts\x12.\n" +
        "\x13retry_after_seconds\x18\n" +
        " \x01(\x03R\x11retryAfterSeconds\"\xa8\x01\n" +
        "\rLogoutRequest\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
        "\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x12\x17\n" +
        "\auser_id\x18\x03 \x01(\tR\x06userId\x126\n" +
        "\x17invalidate_all_sessions\x18\x04 \x01(\bR\x15invalidateAllSessions\"@\n" +
        "\x0eLogoutResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\"W\n" +
        "\x13RefreshTokenRequest\x12#\n" +
        "\rrefresh_token\x18\x01 \x01(\tR\frefreshToken\x12\x1b\n" +
        "\tclient_id\x18\x02 \x01(\tR\bclientId\"\xfe\x01\n" +
        "\x14RefreshTokenResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\x12!\n" +
        "\faccess_token\x18\x03 \x01(\tR\vaccessToken\x12#\n" +
        "\rrefresh_token\x18\x04 \x01(\tR\frefreshToken\x125\n" +
        "\x17access_token_expires_at\x18\x05 \x01(\x03R\x14accessTokenExpiresAt\x127\n" +
        "\x18refresh_token_expires_at\x18\x06 \x01(\x03R\x15refreshTokenExpiresAt\"l\n" +
        "\x14ValidateTokenRequest\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\x121\n" +
        "\x14required_permissions\x18\x02 \x03(\tR\x13requiredPermissions\"\xa4\x01\n" +
        "\x15ValidateTokenResponse\x12\x14\n" +
        "\x05valid\x18\x01 \x01(\bR\x05valid\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\x12\x1e\n" +
        "\x04user\x18\x03 \x01(\v2\n" +
        ".auth.UserR\x04user\x12 \n" +
        "\vpermissions\x18\x04 \x03(\tR\vpermissions\x12\x1d\n" +
        "\n" +
        "expires_at\x18\x05 \x01(\x03R\texpiresAt\"7\n" +
        "\x12GetUserInfoRequest\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\"e\n" +
        "\x13GetUserInfoResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\x12\x1e\n" +
        "\x04user\x18\x03 \x01(\v2\n" +
        ".auth.UserR\x04user\"\x88\x01\n" +
        "\x15ChangePasswordRequest\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12)\n" +
        "\x10current_password\x18\x02 \x01(\tR\x0fcurrentPassword\x12!\n" +
        "\fnew_password\x18\x03 \x01(\tR\vnewPassword\"H\n" +
        "\x16ChangePasswordResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\"_\n" +
        "\x14ResetPasswordRequest\x12*\n" +
        "\x11username_or_email\x18\x01 \x01(\tR\x0fusernameOrEmail\x12\x1b\n" +
        "\tclient_ip\x18\x02 \x01(\tR\bclientIp\"a\n" +
        "\x15ResetPasswordResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\"`\n" +
        "\x1aVerifyPasswordResetRequest\x12\x1f\n" +
        "\vreset_token\x18\x01 \x01(\tR\n" +
        "resetToken\x12!\n" +
        "\fnew_password\x18\x02 \x01(\tR\vnewPassword\"M\n" +
        "\x1bVerifyPasswordResetResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\"R\n" +
        "\x17GetLoginAttemptsRequest\x12\x1a\n" +
        "\busername\x18\x01 \x01(\tR\busername\x12\x1b\n" +
        "\tclient_ip\x18\x02 \x01(\tR\bclientIp\"\xbc\x01\n" +
        "\x18GetLoginAttemptsResponse\x12'\n" +
        "\x0ffailed_attempts\x18\x01 \x01(\x05R\x0efailedAttempts\x12%\n" +
        "\x0eaccount_locked\x18\x02 \x01(\bR\raccountLocked\x12!\n" +
        "\flocked_until\x18\x03 \x01(\x03R\vlockedUntil\x12-\n" +
        "\x12remaining_attempts\x18\x04 \x01(\x05R\x11remainingAttempts\"\xdb\x01\n" +
        "\x0eHealthResponse\x12\x16\n" +
        "\x06status\x18\x01 \x01(\tR\x06status\x12;\n" +
        "\adetails\x18\x02 \x03(\v2!.auth.HealthResponse.DetailsEntryR\adetails\x128\n" +
        "\ttimestamp\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x1a:\n" +
        "\fDetailsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xae\x04\n" +
        "\x04User\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x1a\n" +
        "\busername\x18\x02 \x01(\tR\busername\x12\x14\n" +
        "\x05email\x18\x03 \x01(\tR\x05email\x12\x1b\n" +
        "\tis_active\x18\x04 \x01(\bR\bisActive\x12\x19\n" +
        "\bis_admin\x18\x05 \x01(\bR\aisAdmin\x12)\n" +
        "\x10is_authenticated\x18\x06 \x01(\bR\x0fisAuthenticated\x12%\n" +
        "\x0eemail_verified\x18\a \x01(\bR\remailVerified\x129\n" +
        "\n" +
        "created_at\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
        "\n" +
        "updated_at\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x129\n" +
        "\n" +
        "last_login\x18\n" +
        " \x01(\v2\x1a.google.protobuf.TimestampR\tlastLogin\x12\x14\n" +
        "\x05roles\x18\v \x03(\tR\x05roles\x12 \n" +
        "\vpermissions\x18\f \x03(\tR\vpermissions\x124\n" +
        "\bmetadata\x18\r \x03(\v2\x18.auth.User.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xd5\x03\n" +
        "\vTokenClaims\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\tR\x06userId\x12\x1a\n" +
        "\busername\x18\x02 \x01(\tR\busername\x12\x14\n" +
        "\x05email\x18\x03 \x01(\tR\x05email\x12\x14\n" +
        "\x05roles\x18\x04 \x03(\tR\x05roles\x12 \n" +
        "\vpermissions\x18\x05 \x03(\tR\vpermissions\x12\x1b\n" +
        "\tclient_id\x18\x06 \x01(\tR\bclientId\x12\x1d\n" +
        "\n" +
        "session_id\x18\a \x01(\tR\tsessionId\x12\x1b\n" +
        "\tissued_at\x18\b \x01(\x03R\bissuedAt\x12\x1d\n" +
        "\n" +
        "expires_at\x18\t \x01(\x03R\texpiresAt\x12\x1d\n" +
        "\n" +
        "not_before\x18\n" +
        " \x01(\x03R\tnotBefore\x12\x16\n" +
        "\x06issuer\x18\v \x01(\tR\x06issuer\x12\x1a\n" +
        "\baudience\x18\f \x01(\tR\baudience\x12;\n" +
        "\bmetadata\x18\r \x03(\v2\x1f.auth.TokenClaims.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x012\xc7\x05\n" +
        "\vAuthService\x120\n" +
        "\x05Login\x12\x12.auth.LoginRequest\x1a\x13.auth.LoginResponse\x123\n" +
        "\x06Logout\x12\x13.auth.LogoutRequest\x1a\x14.auth.LogoutResponse\x12E\n" +
        "\fRefreshToken\x12\x19.auth.RefreshTokenRequest\x1a\x1a.auth.RefreshTokenResponse\x12H\n" +
        "\rValidateToken\x12\x1a.auth.ValidateTokenRequest\x1a\x1b.auth.ValidateTokenResponse\x12B\n" +
        "\vGetUserInfo\x12\x18.auth.GetUserInfoRequest\x1a\x19.auth.GetUserInfoResponse\x12K\n" +
        "\x0eChangePassword\x12\x1b.auth.ChangePasswordRequest\x1a\x1c.auth.ChangePasswordResponse\x12H\n" +
        "\rResetPassword\x12\x1a.auth.ResetPasswordRequest\x1a\x1b.auth.ResetPasswordResponse\x12Z\n" +
        "\x13VerifyPasswordReset\x12 .auth.VerifyPasswordResetRequest\x1a!.auth.VerifyPasswordResetResponse\x12Q\n" +
        "\x10GetLoginAttempts\x12\x1d.auth.GetLoginAttemptsRequest\x1a\x1e.auth.GetLoginAttemptsResponse\x126\n" +
        "\x06Health\x12\x16.google.protobuf.Empty\x1a\x14.auth.HealthResponseB,Z*github.com/dungeongate/internal/auth/protob\x06proto3"

var (
        file_internal_auth_proto_auth_service_proto_rawDescOnce sync.Once
        file_internal_auth_proto_auth_service_proto_rawDescData []byte
)

func file_internal_auth_proto_auth_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_internal_auth_proto_auth_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_internal_auth_proto_auth_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_internal_auth_proto_auth_service_proto_rawDesc), len(file_internal_auth_proto_auth_service_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_internal_auth_proto_auth_service_proto_rawDescData</span>
}

var file_internal_auth_proto_auth_service_proto_msgTypes = make([]protoimpl.MessageInfo, 25)
var file_internal_auth_proto_auth_service_proto_goTypes = []any{
        (*LoginRequest)(nil),                // 0: auth.LoginRequest
        (*LoginResponse)(nil),               // 1: auth.LoginResponse
        (*LogoutRequest)(nil),               // 2: auth.LogoutRequest
        (*LogoutResponse)(nil),              // 3: auth.LogoutResponse
        (*RefreshTokenRequest)(nil),         // 4: auth.RefreshTokenRequest
        (*RefreshTokenResponse)(nil),        // 5: auth.RefreshTokenResponse
        (*ValidateTokenRequest)(nil),        // 6: auth.ValidateTokenRequest
        (*ValidateTokenResponse)(nil),       // 7: auth.ValidateTokenResponse
        (*GetUserInfoRequest)(nil),          // 8: auth.GetUserInfoRequest
        (*GetUserInfoResponse)(nil),         // 9: auth.GetUserInfoResponse
        (*ChangePasswordRequest)(nil),       // 10: auth.ChangePasswordRequest
        (*ChangePasswordResponse)(nil),      // 11: auth.ChangePasswordResponse
        (*ResetPasswordRequest)(nil),        // 12: auth.ResetPasswordRequest
        (*ResetPasswordResponse)(nil),       // 13: auth.ResetPasswordResponse
        (*VerifyPasswordResetRequest)(nil),  // 14: auth.VerifyPasswordResetRequest
        (*VerifyPasswordResetResponse)(nil), // 15: auth.VerifyPasswordResetResponse
        (*GetLoginAttemptsRequest)(nil),     // 16: auth.GetLoginAttemptsRequest
        (*GetLoginAttemptsResponse)(nil),    // 17: auth.GetLoginAttemptsResponse
        (*HealthResponse)(nil),              // 18: auth.HealthResponse
        (*User)(nil),                        // 19: auth.User
        (*TokenClaims)(nil),                 // 20: auth.TokenClaims
        nil,                                 // 21: auth.LoginRequest.MetadataEntry
        nil,                                 // 22: auth.HealthResponse.DetailsEntry
        nil,                                 // 23: auth.User.MetadataEntry
        nil,                                 // 24: auth.TokenClaims.MetadataEntry
        (*timestamppb.Timestamp)(nil),       // 25: google.protobuf.Timestamp
        (*emptypb.Empty)(nil),               // 26: google.protobuf.Empty
}
var file_internal_auth_proto_auth_service_proto_depIdxs = []int32{
        21, // 0: auth.LoginRequest.metadata:type_name -&gt; auth.LoginRequest.MetadataEntry
        19, // 1: auth.LoginResponse.user:type_name -&gt; auth.User
        19, // 2: auth.ValidateTokenResponse.user:type_name -&gt; auth.User
        19, // 3: auth.GetUserInfoResponse.user:type_name -&gt; auth.User
        22, // 4: auth.HealthResponse.details:type_name -&gt; auth.HealthResponse.DetailsEntry
        25, // 5: auth.HealthResponse.timestamp:type_name -&gt; google.protobuf.Timestamp
        25, // 6: auth.User.created_at:type_name -&gt; google.protobuf.Timestamp
        25, // 7: auth.User.updated_at:type_name -&gt; google.protobuf.Timestamp
        25, // 8: auth.User.last_login:type_name -&gt; google.protobuf.Timestamp
        23, // 9: auth.User.metadata:type_name -&gt; auth.User.MetadataEntry
        24, // 10: auth.TokenClaims.metadata:type_name -&gt; auth.TokenClaims.MetadataEntry
        0,  // 11: auth.AuthService.Login:input_type -&gt; auth.LoginRequest
        2,  // 12: auth.AuthService.Logout:input_type -&gt; auth.LogoutRequest
        4,  // 13: auth.AuthService.RefreshToken:input_type -&gt; auth.RefreshTokenRequest
        6,  // 14: auth.AuthService.ValidateToken:input_type -&gt; auth.ValidateTokenRequest
        8,  // 15: auth.AuthService.GetUserInfo:input_type -&gt; auth.GetUserInfoRequest
        10, // 16: auth.AuthService.ChangePassword:input_type -&gt; auth.ChangePasswordRequest
        12, // 17: auth.AuthService.ResetPassword:input_type -&gt; auth.ResetPasswordRequest
        14, // 18: auth.AuthService.VerifyPasswordReset:input_type -&gt; auth.VerifyPasswordResetRequest
        16, // 19: auth.AuthService.GetLoginAttempts:input_type -&gt; auth.GetLoginAttemptsRequest
        26, // 20: auth.AuthService.Health:input_type -&gt; google.protobuf.Empty
        1,  // 21: auth.AuthService.Login:output_type -&gt; auth.LoginResponse
        3,  // 22: auth.AuthService.Logout:output_type -&gt; auth.LogoutResponse
        5,  // 23: auth.AuthService.RefreshToken:output_type -&gt; auth.RefreshTokenResponse
        7,  // 24: auth.AuthService.ValidateToken:output_type -&gt; auth.ValidateTokenResponse
        9,  // 25: auth.AuthService.GetUserInfo:output_type -&gt; auth.GetUserInfoResponse
        11, // 26: auth.AuthService.ChangePassword:output_type -&gt; auth.ChangePasswordResponse
        13, // 27: auth.AuthService.ResetPassword:output_type -&gt; auth.ResetPasswordResponse
        15, // 28: auth.AuthService.VerifyPasswordReset:output_type -&gt; auth.VerifyPasswordResetResponse
        17, // 29: auth.AuthService.GetLoginAttempts:output_type -&gt; auth.GetLoginAttemptsResponse
        18, // 30: auth.AuthService.Health:output_type -&gt; auth.HealthResponse
        21, // [21:31] is the sub-list for method output_type
        11, // [11:21] is the sub-list for method input_type
        11, // [11:11] is the sub-list for extension type_name
        11, // [11:11] is the sub-list for extension extendee
        0,  // [0:11] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_internal_auth_proto_auth_service_proto_init() }</span>
func file_internal_auth_proto_auth_service_proto_init() <span class="cov0" title="0">{
        if File_internal_auth_proto_auth_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_internal_auth_proto_auth_service_proto_rawDesc), len(file_internal_auth_proto_auth_service_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   25,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_internal_auth_proto_auth_service_proto_goTypes,
                DependencyIndexes: file_internal_auth_proto_auth_service_proto_depIdxs,
                MessageInfos:      file_internal_auth_proto_auth_service_proto_msgTypes,
        }.Build()
        File_internal_auth_proto_auth_service_proto = out.File
        file_internal_auth_proto_auth_service_proto_goTypes = nil
        file_internal_auth_proto_auth_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: internal/auth/proto/auth_service.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        AuthService_Login_FullMethodName               = "/auth.AuthService/Login"
        AuthService_Logout_FullMethodName              = "/auth.AuthService/Logout"
        AuthService_RefreshToken_FullMethodName        = "/auth.AuthService/RefreshToken"
        AuthService_ValidateToken_FullMethodName       = "/auth.AuthService/ValidateToken"
        AuthService_GetUserInfo_FullMethodName         = "/auth.AuthService/GetUserInfo"
        AuthService_ChangePassword_FullMethodName      = "/auth.AuthService/ChangePassword"
        AuthService_ResetPassword_FullMethodName       = "/auth.AuthService/ResetPassword"
        AuthService_VerifyPasswordReset_FullMethodName = "/auth.AuthService/VerifyPasswordReset"
        AuthService_GetLoginAttempts_FullMethodName    = "/auth.AuthService/GetLoginAttempts"
        AuthService_Health_FullMethodName              = "/auth.AuthService/Health"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// AuthService provides authentication and authorization operations
type AuthServiceClient interface {
        // Login authenticates a user and returns tokens
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
        // Logout invalidates a user's session
        Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
        // RefreshToken refreshes an access token using a refresh token
        RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
        // ValidateToken validates an access token and returns user info
        ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
        // GetUserInfo gets user information from a valid token
        GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error)
        // ChangePassword changes a user's password
        ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error)
        // ResetPassword initiates password reset flow
        ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error)
        // VerifyPasswordReset verifies and completes password reset
        VerifyPasswordReset(ctx context.Context, in *VerifyPasswordResetRequest, opts ...grpc.CallOption) (*VerifyPasswordResetResponse, error)
        // GetLoginAttempts gets login attempt info for a user
        GetLoginAttempts(ctx context.Context, in *GetLoginAttemptsRequest, opts ...grpc.CallOption) (*GetLoginAttemptsResponse, error)
        // Health check
        Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthResponse, error)
}

type authServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient <span class="cov0" title="0">{
        return &amp;authServiceClient{cc}
}</span>

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LogoutResponse)
        err := c.cc.Invoke(ctx, AuthService_Logout_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RefreshTokenResponse)
        err := c.cc.Invoke(ctx, AuthService_RefreshToken_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ValidateTokenResponse)
        err := c.cc.Invoke(ctx, AuthService_ValidateToken_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserInfoResponse)
        err := c.cc.Invoke(ctx, AuthService_GetUserInfo_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ChangePasswordResponse)
        err := c.cc.Invoke(ctx, AuthService_ChangePassword_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ResetPasswordResponse)
        err := c.cc.Invoke(ctx, AuthService_ResetPassword_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) VerifyPasswordReset(ctx context.Context, in *VerifyPasswordResetRequest, opts ...grpc.CallOption) (*VerifyPasswordResetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(VerifyPasswordResetResponse)
        err := c.cc.Invoke(ctx, AuthService_VerifyPasswordReset_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) GetLoginAttempts(ctx context.Context, in *GetLoginAttemptsRequest, opts ...grpc.CallOption) (*GetLoginAttemptsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetLoginAttemptsResponse)
        err := c.cc.Invoke(ctx, AuthService_GetLoginAttempts_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(HealthResponse)
        err := c.cc.Invoke(ctx, AuthService_Health_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
//
// AuthService provides authentication and authorization operations
type AuthServiceServer interface {
        // Login authenticates a user and returns tokens
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        // Logout invalidates a user's session
        Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
        // RefreshToken refreshes an access token using a refresh token
        RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
        // ValidateToken validates an access token and returns user info
        ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
        // GetUserInfo gets user information from a valid token
        GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error)
        // ChangePassword changes a user's password
        ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error)
        // ResetPassword initiates password reset flow
        ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error)
        // VerifyPasswordReset verifies and completes password reset
        VerifyPasswordReset(context.Context, *VerifyPasswordResetRequest) (*VerifyPasswordResetResponse, error)
        // GetLoginAttempts gets login attempt info for a user
        GetLoginAttempts(context.Context, *GetLoginAttemptsRequest) (*GetLoginAttemptsResponse, error)
        // Health check
        Health(context.Context, *emptypb.Empty) (*HealthResponse, error)
        mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedAuthServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}</span>
func (UnimplementedAuthServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}</span>
func (UnimplementedAuthServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}</span>
func (UnimplementedAuthServiceServer) GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}</span>
func (UnimplementedAuthServiceServer) ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}</span>
func (UnimplementedAuthServiceServer) ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}</span>
func (UnimplementedAuthServiceServer) VerifyPasswordReset(context.Context, *VerifyPasswordResetRequest) (*VerifyPasswordResetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method VerifyPasswordReset not implemented")
}</span>
func (UnimplementedAuthServiceServer) GetLoginAttempts(context.Context, *GetLoginAttemptsRequest) (*GetLoginAttemptsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetLoginAttempts not implemented")
}</span>
func (UnimplementedAuthServiceServer) Health(context.Context, *emptypb.Empty) (*HealthResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}</span>
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
        mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedAuthServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;AuthService_ServiceDesc, srv)</span>
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LogoutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Logout_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, req.(*LogoutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RefreshTokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_RefreshToken_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ValidateTokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ValidateToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_ValidateToken_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUserInfo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_GetUserInfo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUserInfo(ctx, req.(*GetUserInfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ChangePasswordRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ChangePassword(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_ChangePassword_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ChangePassword(ctx, req.(*ChangePasswordRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ResetPasswordRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ResetPassword(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_ResetPassword_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ResetPassword(ctx, req.(*ResetPasswordRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_VerifyPasswordReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(VerifyPasswordResetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).VerifyPasswordReset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_VerifyPasswordReset_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).VerifyPasswordReset(ctx, req.(*VerifyPasswordResetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_GetLoginAttempts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetLoginAttemptsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetLoginAttempts(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_GetLoginAttempts_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetLoginAttempts(ctx, req.(*GetLoginAttemptsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Health(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Health_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Health(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "auth.AuthService",
        HandlerType: (*AuthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Login",
                        Handler:    _AuthService_Login_Handler,
                },
                {
                        MethodName: "Logout",
                        Handler:    _AuthService_Logout_Handler,
                },
                {
                        MethodName: "RefreshToken",
                        Handler:    _AuthService_RefreshToken_Handler,
                },
                {
                        MethodName: "ValidateToken",
                        Handler:    _AuthService_ValidateToken_Handler,
                },
                {
                        MethodName: "GetUserInfo",
                        Handler:    _AuthService_GetUserInfo_Handler,
                },
                {
                        MethodName: "ChangePassword",
                        Handler:    _AuthService_ChangePassword_Handler,
                },
                {
                        MethodName: "ResetPassword",
                        Handler:    _AuthService_ResetPassword_Handler,
                },
                {
                        MethodName: "VerifyPasswordReset",
                        Handler:    _AuthService_VerifyPasswordReset_Handler,
                },
                {
                        MethodName: "GetLoginAttempts",
                        Handler:    _AuthService_GetLoginAttempts_Handler,
                },
                {
                        MethodName: "Health",
                        Handler:    _AuthService_Health_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "internal/auth/proto/auth_service.proto",
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/dungeongate/internal/auth/proto"
        "github.com/dungeongate/internal/user"
        "github.com/dungeongate/pkg/database"
        "github.com/dungeongate/pkg/encryption"
        "github.com/golang-jwt/jwt/v5"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// Service implements the Auth service
type Service struct {
        proto.UnimplementedAuthServiceServer
        db        *database.Connection
        userSvc   *user.Service
        encryptor encryption.Encryptor
        jwtSecret []byte
        jwtIssuer string

        // Token expiration times
        accessTokenExpiration  time.Duration
        refreshTokenExpiration time.Duration

        // Rate limiting
        maxLoginAttempts int
        lockoutDuration  time.Duration
}

// Config holds the configuration for the Auth service
type Config struct {
        JWTSecret              string        `yaml:"jwt_secret"`
        JWTIssuer              string        `yaml:"jwt_issuer"`
        AccessTokenExpiration  time.Duration `yaml:"access_token_expiration"`
        RefreshTokenExpiration time.Duration `yaml:"refresh_token_expiration"`
        MaxLoginAttempts       int           `yaml:"max_login_attempts"`
        LockoutDuration        time.Duration `yaml:"lockout_duration"`
}

// NewService creates a new Auth service
func NewService(db *database.Connection, userSvc *user.Service, encryptor encryption.Encryptor, config *Config) *Service <span class="cov0" title="0">{
        // Set default values
        if config.AccessTokenExpiration == 0 </span><span class="cov0" title="0">{
                config.AccessTokenExpiration = 15 * time.Minute
        }</span>
        <span class="cov0" title="0">if config.RefreshTokenExpiration == 0 </span><span class="cov0" title="0">{
                config.RefreshTokenExpiration = 7 * 24 * time.Hour // 7 days
        }</span>
        <span class="cov0" title="0">if config.MaxLoginAttempts == 0 </span><span class="cov0" title="0">{
                config.MaxLoginAttempts = 3
        }</span>
        <span class="cov0" title="0">if config.LockoutDuration == 0 </span><span class="cov0" title="0">{
                config.LockoutDuration = 15 * time.Minute
        }</span>
        <span class="cov0" title="0">if config.JWTIssuer == "" </span><span class="cov0" title="0">{
                config.JWTIssuer = "dungeongate"
        }</span>

        <span class="cov0" title="0">return &amp;Service{
                db:                     db,
                userSvc:                userSvc,
                encryptor:              encryptor,
                jwtSecret:              []byte(config.JWTSecret),
                jwtIssuer:              config.JWTIssuer,
                accessTokenExpiration:  config.AccessTokenExpiration,
                refreshTokenExpiration: config.RefreshTokenExpiration,
                maxLoginAttempts:       config.MaxLoginAttempts,
                lockoutDuration:        config.LockoutDuration,
        }</span>
}

// Login authenticates a user and returns tokens
func (s *Service) Login(ctx context.Context, req *proto.LoginRequest) (*proto.LoginResponse, error) <span class="cov0" title="0">{
        if req.Username == "" || req.Password == "" </span><span class="cov0" title="0">{
                return &amp;proto.LoginResponse{
                        Success:   false,
                        Error:     "Username and password are required",
                        ErrorCode: "invalid_request",
                }, nil
        }</span>

        // Check login attempts first
        <span class="cov0" title="0">attemptsResp, err := s.GetLoginAttempts(ctx, &amp;proto.GetLoginAttemptsRequest{
                Username: req.Username,
                ClientIp: req.ClientIp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.LoginResponse{
                        Success: false,
                        Error:   "Failed to check login attempts",
                }, status.Errorf(codes.Internal, "failed to check login attempts: %v", err)
        }</span>

        <span class="cov0" title="0">if attemptsResp.AccountLocked </span><span class="cov0" title="0">{
                return &amp;proto.LoginResponse{
                        Success:           false,
                        Error:             "Account is temporarily locked due to too many failed login attempts",
                        ErrorCode:         "account_locked",
                        RetryAfterSeconds: attemptsResp.LockedUntil - time.Now().Unix(),
                }, nil
        }</span>

        // Authenticate user
        <span class="cov0" title="0">authenticatedUser, err := s.userSvc.AuthenticateUser(ctx, req.Username, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                // Determine error type and increment failed attempts
                var errorCode string
                switch err.Error() </span>{
                case "username_not_found":<span class="cov0" title="0">
                        errorCode = "user_not_found"</span>
                case "invalid_password":<span class="cov0" title="0">
                        errorCode = "invalid_credentials"</span>
                case "account_locked":<span class="cov0" title="0">
                        errorCode = "account_locked"</span>
                default:<span class="cov0" title="0">
                        errorCode = "authentication_failed"</span>
                }

                // Increment failed login attempts
                <span class="cov0" title="0">s.incrementFailedLoginAttempts(ctx, req.Username, req.ClientIp)

                return &amp;proto.LoginResponse{
                        Success:           false,
                        Error:             "Invalid credentials",
                        ErrorCode:         errorCode,
                        RemainingAttempts: attemptsResp.RemainingAttempts - 1,
                }, nil</span>
        }

        // Reset failed login attempts on successful login
        <span class="cov0" title="0">s.resetFailedLoginAttempts(ctx, req.Username, req.ClientIp)

        // Generate tokens
        accessToken, refreshToken, err := s.generateTokens(authenticatedUser)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.LoginResponse{
                        Success: false,
                        Error:   "Failed to generate tokens",
                }, status.Errorf(codes.Internal, "failed to generate tokens: %v", err)
        }</span>

        // Convert user to proto
        <span class="cov0" title="0">protoUser := s.convertUserToProto(authenticatedUser)

        return &amp;proto.LoginResponse{
                Success:               true,
                AccessToken:           accessToken,
                RefreshToken:          refreshToken,
                AccessTokenExpiresAt:  time.Now().Add(s.accessTokenExpiration).Unix(),
                RefreshTokenExpiresAt: time.Now().Add(s.refreshTokenExpiration).Unix(),
                User:                  protoUser,
                RemainingAttempts:     int32(s.maxLoginAttempts),
        }, nil</span>
}

// Logout invalidates a user's session
func (s *Service) Logout(ctx context.Context, req *proto.LogoutRequest) (*proto.LogoutResponse, error) <span class="cov0" title="0">{
        // For now, we'll implement stateless logout (tokens are just not validated)
        // In a production system, you'd want to maintain a token blacklist
        return &amp;proto.LogoutResponse{
                Success: true,
        }, nil
}</span>

// RefreshToken refreshes an access token using a refresh token
func (s *Service) RefreshToken(ctx context.Context, req *proto.RefreshTokenRequest) (*proto.RefreshTokenResponse, error) <span class="cov0" title="0">{
        if req.RefreshToken == "" </span><span class="cov0" title="0">{
                return &amp;proto.RefreshTokenResponse{
                        Success: false,
                        Error:   "Refresh token is required",
                }, nil
        }</span>

        // Parse and validate refresh token
        <span class="cov0" title="0">claims, err := s.parseToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.RefreshTokenResponse{
                        Success: false,
                        Error:   "Invalid refresh token",
                }, nil
        }</span>

        // Get user from database
        <span class="cov0" title="0">userIDInt, err := strconv.Atoi(claims.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.RefreshTokenResponse{
                        Success: false,
                        Error:   "Invalid user ID",
                }, nil
        }</span>
        <span class="cov0" title="0">user, err := s.userSvc.GetUserByID(ctx, userIDInt)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.RefreshTokenResponse{
                        Success: false,
                        Error:   "User not found",
                }, nil
        }</span>

        // Generate new tokens
        <span class="cov0" title="0">accessToken, refreshToken, err := s.generateTokens(user)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.RefreshTokenResponse{
                        Success: false,
                        Error:   "Failed to generate tokens",
                }, status.Errorf(codes.Internal, "failed to generate tokens: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;proto.RefreshTokenResponse{
                Success:               true,
                AccessToken:           accessToken,
                RefreshToken:          refreshToken,
                AccessTokenExpiresAt:  time.Now().Add(s.accessTokenExpiration).Unix(),
                RefreshTokenExpiresAt: time.Now().Add(s.refreshTokenExpiration).Unix(),
        }, nil</span>
}

// ValidateToken validates an access token and returns user info
func (s *Service) ValidateToken(ctx context.Context, req *proto.ValidateTokenRequest) (*proto.ValidateTokenResponse, error) <span class="cov0" title="0">{
        if req.AccessToken == "" </span><span class="cov0" title="0">{
                return &amp;proto.ValidateTokenResponse{
                        Valid: false,
                        Error: "Access token is required",
                }, nil
        }</span>

        // Parse and validate token
        <span class="cov0" title="0">claims, err := s.parseToken(req.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.ValidateTokenResponse{
                        Valid: false,
                        Error: "Invalid token",
                }, nil
        }</span>

        // Check if token has expired
        <span class="cov0" title="0">if time.Now().Unix() &gt; claims.ExpiresAt </span><span class="cov0" title="0">{
                return &amp;proto.ValidateTokenResponse{
                        Valid: false,
                        Error: "Token has expired",
                }, nil
        }</span>

        // Get user from database
        <span class="cov0" title="0">userIDInt, err := strconv.Atoi(claims.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.ValidateTokenResponse{
                        Valid: false,
                        Error: "Invalid user ID",
                }, nil
        }</span>
        <span class="cov0" title="0">user, err := s.userSvc.GetUserByID(ctx, userIDInt)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.ValidateTokenResponse{
                        Valid: false,
                        Error: "User not found",
                }, nil
        }</span>

        // Check if user is still active
        <span class="cov0" title="0">if !user.IsActive </span><span class="cov0" title="0">{
                return &amp;proto.ValidateTokenResponse{
                        Valid: false,
                        Error: "User account is inactive",
                }, nil
        }</span>

        // Convert user to proto
        <span class="cov0" title="0">protoUser := s.convertUserToProto(user)

        return &amp;proto.ValidateTokenResponse{
                Valid:     true,
                User:      protoUser,
                ExpiresAt: claims.ExpiresAt,
        }, nil</span>
}

// GetUserInfo gets user information from a valid token
func (s *Service) GetUserInfo(ctx context.Context, req *proto.GetUserInfoRequest) (*proto.GetUserInfoResponse, error) <span class="cov0" title="0">{
        validateResp, err := s.ValidateToken(ctx, &amp;proto.ValidateTokenRequest{
                AccessToken: req.AccessToken,
        })
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.GetUserInfoResponse{
                        Success: false,
                        Error:   "Failed to validate token",
                }, err
        }</span>

        <span class="cov0" title="0">if !validateResp.Valid </span><span class="cov0" title="0">{
                return &amp;proto.GetUserInfoResponse{
                        Success: false,
                        Error:   validateResp.Error,
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;proto.GetUserInfoResponse{
                Success: true,
                User:    validateResp.User,
        }, nil</span>
}

// ChangePassword changes a user's password
func (s *Service) ChangePassword(ctx context.Context, req *proto.ChangePasswordRequest) (*proto.ChangePasswordResponse, error) <span class="cov0" title="0">{
        // Validate token first
        validateResp, err := s.ValidateToken(ctx, &amp;proto.ValidateTokenRequest{
                AccessToken: req.AccessToken,
        })
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.ChangePasswordResponse{
                        Success: false,
                        Error:   "Failed to validate token",
                }, err
        }</span>

        <span class="cov0" title="0">if !validateResp.Valid </span><span class="cov0" title="0">{
                return &amp;proto.ChangePasswordResponse{
                        Success: false,
                        Error:   validateResp.Error,
                }, nil
        }</span>

        // Verify current password
        <span class="cov0" title="0">_, err = s.userSvc.AuthenticateUser(ctx, validateResp.User.Username, req.CurrentPassword)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;proto.ChangePasswordResponse{
                        Success: false,
                        Error:   "Current password is incorrect",
                }, nil
        }</span>

        // Update password - Note: This would need to be implemented in user service
        // For now, return success
        <span class="cov0" title="0">return &amp;proto.ChangePasswordResponse{
                Success: true,
        }, nil</span>
}

// ResetPassword initiates password reset flow
func (s *Service) ResetPassword(ctx context.Context, req *proto.ResetPasswordRequest) (*proto.ResetPasswordResponse, error) <span class="cov0" title="0">{
        // This would typically send an email with a reset token
        // For now, return success
        return &amp;proto.ResetPasswordResponse{
                Success: true,
                Message: "Password reset instructions have been sent to your email",
        }, nil
}</span>

// VerifyPasswordReset verifies and completes password reset
func (s *Service) VerifyPasswordReset(ctx context.Context, req *proto.VerifyPasswordResetRequest) (*proto.VerifyPasswordResetResponse, error) <span class="cov0" title="0">{
        // This would verify the reset token and update the password
        // For now, return success
        return &amp;proto.VerifyPasswordResetResponse{
                Success: true,
        }, nil
}</span>

// GetLoginAttempts gets login attempt info for a user
func (s *Service) GetLoginAttempts(ctx context.Context, req *proto.GetLoginAttemptsRequest) (*proto.GetLoginAttemptsResponse, error) <span class="cov0" title="0">{
        // This would check the database for login attempts
        // For now, return default values
        return &amp;proto.GetLoginAttemptsResponse{
                FailedAttempts:    0,
                AccountLocked:     false,
                LockedUntil:       0,
                RemainingAttempts: int32(s.maxLoginAttempts),
        }, nil
}</span>

// Health returns the health status of the service
func (s *Service) Health(ctx context.Context, req *emptypb.Empty) (*proto.HealthResponse, error) <span class="cov0" title="0">{
        return &amp;proto.HealthResponse{
                Status: "healthy",
                Details: map[string]string{
                        "service": "auth",
                        "version": "1.0.0",
                },
                Timestamp: timestampProto(time.Now()),
        }, nil
}</span>

// Private helper methods

func (s *Service) generateTokens(user *user.User) (string, string, error) <span class="cov0" title="0">{
        now := time.Now()

        // Generate access token
        accessClaims := &amp;proto.TokenClaims{
                UserId:    strconv.Itoa(user.ID),
                Username:  user.Username,
                Email:     user.Email,
                IssuedAt:  now.Unix(),
                ExpiresAt: now.Add(s.accessTokenExpiration).Unix(),
                NotBefore: now.Unix(),
                Issuer:    s.jwtIssuer,
        }

        accessToken, err := s.createToken(accessClaims)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to create access token: %w", err)
        }</span>

        // Generate refresh token
        <span class="cov0" title="0">refreshClaims := &amp;proto.TokenClaims{
                UserId:    strconv.Itoa(user.ID),
                Username:  user.Username,
                Email:     user.Email,
                IssuedAt:  now.Unix(),
                ExpiresAt: now.Add(s.refreshTokenExpiration).Unix(),
                NotBefore: now.Unix(),
                Issuer:    s.jwtIssuer,
        }

        refreshToken, err := s.createToken(refreshClaims)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to create refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">return accessToken, refreshToken, nil</span>
}

func (s *Service) createToken(claims *proto.TokenClaims) (string, error) <span class="cov0" title="0">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id":  claims.UserId,
                "username": claims.Username,
                "email":    claims.Email,
                "iat":      claims.IssuedAt,
                "exp":      claims.ExpiresAt,
                "nbf":      claims.NotBefore,
                "iss":      claims.Issuer,
        })

        return token.SignedString(s.jwtSecret)
}</span>

func (s *Service) parseToken(tokenString string) (*proto.TokenClaims, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return s.jwtSecret, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>

        <span class="cov0" title="0">return &amp;proto.TokenClaims{
                UserId:    claims["user_id"].(string),
                Username:  claims["username"].(string),
                Email:     claims["email"].(string),
                IssuedAt:  int64(claims["iat"].(float64)),
                ExpiresAt: int64(claims["exp"].(float64)),
                NotBefore: int64(claims["nbf"].(float64)),
                Issuer:    claims["iss"].(string),
        }, nil</span>
}

func (s *Service) convertUserToProto(userObj *user.User) *proto.User <span class="cov0" title="0">{
        var lastLogin *timestamppb.Timestamp
        if userObj.LastLogin != nil </span><span class="cov0" title="0">{
                lastLogin = timestampProto(*userObj.LastLogin)
        }</span>
        
        <span class="cov0" title="0">return &amp;proto.User{
                Id:              strconv.Itoa(userObj.ID),
                Username:        userObj.Username,
                Email:           userObj.Email,
                IsActive:        userObj.IsActive,
                IsAdmin:         (userObj.Flags &amp; user.UserFlagAdmin) != 0,
                IsAuthenticated: true,
                EmailVerified:   userObj.EmailVerified,
                CreatedAt:       timestampProto(userObj.CreatedAt),
                UpdatedAt:       timestampProto(userObj.UpdatedAt),
                LastLogin:       lastLogin,
        }</span>
}

func (s *Service) incrementFailedLoginAttempts(ctx context.Context, username, clientIP string) {<span class="cov0" title="0">
        // This would increment failed login attempts in the database
        // For now, just log it
}</span>

func (s *Service) resetFailedLoginAttempts(ctx context.Context, username, clientIP string) {<span class="cov0" title="0">
        // This would reset failed login attempts in the database
        // For now, just log it
}</span>

func timestampProto(t time.Time) *timestamppb.Timestamp <span class="cov0" title="0">{
        return timestamppb.New(t)
}</span>

</pre>
		
		<pre class="file" id="file8" style="display: none">package games

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/exec"
        "sync"
        "syscall"
        "time"

        "github.com/dungeongate/pkg/config"
        "github.com/dungeongate/pkg/database"
        "google.golang.org/grpc"
)

// GameEvent represents a game event for streaming
type GameEvent struct {
        EventID   string            `json:"event_id"`
        SessionID string            `json:"session_id"`
        EventType string            `json:"event_type"`
        EventData []byte            `json:"event_data"`
        Metadata  map[string]string `json:"metadata"`
        Timestamp time.Time         `json:"timestamp"`
}

// Service handles game management operations
type Service struct {
        db             *database.Connection
        config         *config.GameServiceConfig
        activeSessions map[string]*GameSession
        sessionMutex   sync.RWMutex
        eventStreams   map[string][]chan *GameEvent
        streamMutex    sync.RWMutex
}

// NewService creates a new game service
func NewService(db *database.Connection, cfg *config.GameServiceConfig) *Service <span class="cov0" title="0">{
        return &amp;Service{
                db:             db,
                config:         cfg,
                activeSessions: make(map[string]*GameSession),
                eventStreams:   make(map[string][]chan *GameEvent),
        }
}</span>

// Game represents a game instance
type Game struct {
        ID          string                  `json:"id"`
        Name        string                  `json:"name"`
        ShortName   string                  `json:"short_name"`
        Enabled     bool                    `json:"enabled"`
        Binary      *config.BinaryConfig    `json:"binary"`
        Files       *config.FilesConfig     `json:"files"`
        Settings    *config.GameSettings    `json:"settings"`
        Environment map[string]string       `json:"environment"`
        Resources   *config.ResourcesConfig `json:"resources"`
        Container   *config.ContainerConfig `json:"container"`
}

// GameSession represents an active game session
type GameSession struct {
        ID          string    `json:"id"`
        UserID      int       `json:"user_id"`
        Username    string    `json:"username"`
        GameID      string    `json:"game_id"`
        PID         int       `json:"pid"`
        StartTime   time.Time `json:"start_time"`
        IsActive    bool      `json:"is_active"`
        ContainerID string    `json:"container_id"`
        PodName     string    `json:"pod_name"`
}

// StartGameRequest represents a request to start a game
type StartGameRequest struct {
        UserID   int    `json:"user_id"`
        Username string `json:"username"`
        GameID   string `json:"game_id"`
}

// StartGame starts a new game session
func (s *Service) StartGame(ctx context.Context, req *StartGameRequest) (*GameSession, error) <span class="cov0" title="0">{
        // Find game configuration
        game, err := s.getGameConfig(req.GameID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get game config: %w", err)
        }</span>

        <span class="cov0" title="0">if !game.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("game %s is not enabled", req.GameID)
        }</span>

        // Create game session
        <span class="cov0" title="0">session := &amp;GameSession{
                ID:       generateSessionID(),
                UserID:   req.UserID,
                Username: req.Username,
                GameID:   req.GameID,
                IsActive: true,
        }

        // Start game process using namespaces instead of chroot
        cmd, err := s.startGameProcess(session, game)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start game process: %w", err)
        }</span>

        <span class="cov0" title="0">session.PID = cmd.Process.Pid

        // TODO: Store session in database
        // TODO: Set up TTY recording
        // TODO: Set up process monitoring

        return session, nil</span>
}

// StopGame stops a game session
func (s *Service) StopGame(ctx context.Context, sessionID string) error <span class="cov0" title="0">{
        // TODO: Implement game stopping logic
        return fmt.Errorf("game stopping not implemented")
}</span>

// GetActiveGames returns all active game sessions
func (s *Service) GetActiveGames(ctx context.Context) ([]*GameSession, error) <span class="cov0" title="0">{
        // TODO: Implement active games retrieval
        return nil, fmt.Errorf("active games retrieval not implemented")
}</span>

// GetGameConfig returns game configuration
func (s *Service) GetGameConfig(ctx context.Context, gameID string) (*Game, error) <span class="cov0" title="0">{
        return s.getGameConfig(gameID)
}</span>

// getGameConfig retrieves game configuration
func (s *Service) getGameConfig(gameID string) (*Game, error) <span class="cov0" title="0">{
        // Find game in configuration
        for _, gameConfig := range s.config.Games </span><span class="cov0" title="0">{
                if gameConfig.ID == gameID </span><span class="cov0" title="0">{
                        return &amp;Game{
                                ID:          gameConfig.ID,
                                Name:        gameConfig.Name,
                                ShortName:   gameConfig.ShortName,
                                Enabled:     gameConfig.Enabled,
                                Binary:      gameConfig.Binary,
                                Files:       gameConfig.Files,
                                Settings:    gameConfig.Settings,
                                Environment: gameConfig.Environment,
                                Resources:   gameConfig.Resources,
                        }, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("game %s not found", gameID)</span>
}

// startGameProcess starts a game process with namespace isolation
func (s *Service) startGameProcess(session *GameSession, game *Game) (*exec.Cmd, error) <span class="cov0" title="0">{
        // Create game process command
        cmd := exec.Command(game.Binary.Path, game.Binary.Args...)

        // Set up process attributes for isolation
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setsid: true, // Create new session
        }

        // Set working directory
        if game.Binary.WorkingDirectory != "" </span><span class="cov0" title="0">{
                cmd.Dir = game.Binary.WorkingDirectory
        }</span>

        // Set environment variables
        <span class="cov0" title="0">cmd.Env = os.Environ()
        for key, value := range game.Environment </span><span class="cov0" title="0">{
                // Replace placeholders
                expandedValue := expandPlaceholders(value, session.Username, game.ID)
                cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, expandedValue))
        }</span>

        // Set up user and group
        <span class="cov0" title="0">if s.config.GameEngine.Chroot != nil </span><span class="cov0" title="0">{
                // Drop privileges - use configured user/group
                cmd.SysProcAttr.Credential = &amp;syscall.Credential{
                        Uid: 1000, // game user
                        Gid: 1000, // game group
                }
        }</span>

        // Start the process
        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start game process: %w", err)
        }</span>

        <span class="cov0" title="0">return cmd, nil</span>
}

// expandPlaceholders expands placeholders in strings
func expandPlaceholders(template, username, gameID string) string <span class="cov0" title="0">{
        // TODO: Implement proper placeholder expansion
        // For now, just return the template
        return template
}</span>

// generateSessionID generates a unique session ID
func generateSessionID() string <span class="cov0" title="0">{
        // TODO: Implement proper session ID generation
        return "session_123"
}</span>

// InitializeNamespaces initializes namespace isolation
func InitializeNamespaces(config *config.ChrootConfig) error <span class="cov0" title="0">{
        // TODO: Implement namespace initialization
        // This replaces traditional chroot with Linux namespaces for better isolation
        return nil
}</span>

// NewHTTPHandler creates a new HTTP handler for the game service
func NewHTTPHandler(service *Service) http.Handler <span class="cov0" title="0">{
        mux := http.NewServeMux()

        mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write([]byte("OK"))
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/games", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // TODO: Implement game endpoints
                w.WriteHeader(http.StatusNotImplemented)
                _, _ = w.Write([]byte("Game endpoints not implemented"))
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/sessions", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // TODO: Implement session endpoints
                w.WriteHeader(http.StatusNotImplemented)
                _, _ = w.Write([]byte("Session endpoints not implemented"))
        }</span>)

        <span class="cov0" title="0">return mux</span>
}

// RegisterGameServiceServer registers the gRPC service
func RegisterGameServiceServer(server *grpc.Server, service *Service) {<span class="cov0" title="0">
        // Register the gRPC service implementation
        // This will be implemented when we generate the gRPC code from proto
}</span>

// gRPC Service Implementation Methods

// StartGameGRPC starts a new game session via gRPC
func (s *Service) StartGameGRPC(ctx context.Context, req *StartGameRequestGRPC) (*StartGameResponseGRPC, error) <span class="cov0" title="0">{
        // Convert gRPC request to internal request
        startReq := &amp;StartGameRequest{
                UserID:   1, // Convert from string to int if needed
                Username: req.Username,
                GameID:   req.GameID,
        }

        session, err := s.StartGame(ctx, startReq)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;StartGameResponseGRPC{
                        Error: err.Error(),
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;StartGameResponseGRPC{
                Session: session,
        }, nil</span>
}

// StopGameGRPC stops a game session via gRPC
func (s *Service) StopGameGRPC(ctx context.Context, req *StopGameRequestGRPC) (*StopGameResponseGRPC, error) <span class="cov0" title="0">{
        err := s.StopGame(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;StopGameResponseGRPC{
                        Success: false,
                        Error:   err.Error(),
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;StopGameResponseGRPC{
                Success: true,
        }, nil</span>
}

// ListActiveSessionsGRPC lists active sessions via gRPC
func (s *Service) ListActiveSessionsGRPC(ctx context.Context, req *ListActiveSessionsRequestGRPC) (*ListActiveSessionsResponseGRPC, error) <span class="cov0" title="0">{
        sessions, err := s.GetActiveGames(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ListActiveSessionsResponseGRPC{
                        Error: err.Error(),
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;ListActiveSessionsResponseGRPC{
                Sessions:   sessions,
                TotalCount: int32(len(sessions)),
        }, nil</span>
}

// GetGameSessionGRPC gets a game session via gRPC
func (s *Service) GetGameSessionGRPC(ctx context.Context, req *GetGameSessionRequestGRPC) (*GetGameSessionResponseGRPC, error) <span class="cov0" title="0">{
        s.sessionMutex.RLock()
        session, exists := s.activeSessions[req.SessionID]
        s.sessionMutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return &amp;GetGameSessionResponseGRPC{
                        Error: "session not found",
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;GetGameSessionResponseGRPC{
                Session: session,
        }, nil</span>
}

// HealthGRPC performs health check via gRPC
func (s *Service) HealthGRPC(ctx context.Context, req *HealthRequestGRPC) (*HealthResponseGRPC, error) <span class="cov0" title="0">{
        return &amp;HealthResponseGRPC{
                Status: "healthy",
                Details: map[string]string{
                        "active_sessions": fmt.Sprintf("%d", len(s.activeSessions)),
                        "timestamp":       time.Now().Format(time.RFC3339),
                },
        }, nil
}</span>

// Container Management Methods

// StartGameContainer starts a game in a container
func (s *Service) StartGameContainer(ctx context.Context, session *GameSession, game *Game) error <span class="cov0" title="0">{
        // Implementation depends on container runtime (Docker, Podman, containerd)
        switch s.config.GameEngine.ContainerRuntime.Runtime </span>{
        case "docker":<span class="cov0" title="0">
                return s.startDockerContainer(ctx, session, game)</span>
        case "podman":<span class="cov0" title="0">
                return s.startPodmanContainer(ctx, session, game)</span>
        case "kubernetes":<span class="cov0" title="0">
                return s.startKubernetesPod(ctx, session, game)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported container runtime: %s", s.config.GameEngine.ContainerRuntime.Runtime)</span>
        }
}

// startDockerContainer starts a Docker container for the game
func (s *Service) startDockerContainer(ctx context.Context, session *GameSession, game *Game) error <span class="cov0" title="0">{
        // Build Docker command
        args := []string{
                "run", "-d",
                "--name", fmt.Sprintf("dungeongate-%s-%s", game.ID, session.ID),
                "--rm", // Remove container when it stops
        }

        // Add resource limits
        if game.Resources != nil </span><span class="cov0" title="0">{
                if game.Resources.CPULimit != "" </span><span class="cov0" title="0">{
                        args = append(args, "--cpus", game.Resources.CPULimit)
                }</span>
                <span class="cov0" title="0">if game.Resources.MemoryLimit != "" </span><span class="cov0" title="0">{
                        args = append(args, "--memory", game.Resources.MemoryLimit)
                }</span>
        }

        // Add security context
        <span class="cov0" title="0">if game.Container != nil &amp;&amp; game.Container.SecurityContext != nil </span><span class="cov0" title="0">{
                if game.Container.SecurityContext.RunAsUser &gt; 0 </span><span class="cov0" title="0">{
                        args = append(args, "--user", fmt.Sprintf("%d:%d",
                                game.Container.SecurityContext.RunAsUser,
                                game.Container.SecurityContext.RunAsGroup))
                }</span>
                <span class="cov0" title="0">if game.Container.SecurityContext.ReadOnlyRootFilesystem </span><span class="cov0" title="0">{
                        args = append(args, "--read-only")
                }</span>
        }

        // Add volumes
        <span class="cov0" title="0">if game.Container != nil </span><span class="cov0" title="0">{
                for _, volume := range game.Container.Volumes </span><span class="cov0" title="0">{
                        volumeArg := fmt.Sprintf("%s:%s", volume.HostPath, volume.MountPath)
                        if volume.ReadOnly </span><span class="cov0" title="0">{
                                volumeArg += ":ro"
                        }</span>
                        <span class="cov0" title="0">args = append(args, "-v", volumeArg)</span>
                }
        }

        // Add environment variables
        <span class="cov0" title="0">if game.Environment != nil </span><span class="cov0" title="0">{
                for key, value := range game.Environment </span><span class="cov0" title="0">{
                        expandedValue := expandPlaceholders(value, session.Username, game.ID)
                        args = append(args, "-e", fmt.Sprintf("%s=%s", key, expandedValue))
                }</span>
        }

        // Add container image
        <span class="cov0" title="0">if game.Container != nil </span><span class="cov0" title="0">{
                image := game.Container.Image
                if game.Container.Tag != "" </span><span class="cov0" title="0">{
                        image += ":" + game.Container.Tag
                }</span>
                <span class="cov0" title="0">args = append(args, image)</span>
        }

        // Add binary and arguments
        <span class="cov0" title="0">args = append(args, game.Binary.Path)
        args = append(args, game.Binary.Args...)

        // Execute Docker command
        cmd := exec.CommandContext(ctx, "docker", args...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start Docker container: %w, output: %s", err, string(output))
        }</span>

        // Store container ID
        <span class="cov0" title="0">session.ContainerID = string(output[:len(output)-1]) // Remove trailing newline

        return nil</span>
}

// startPodmanContainer starts a Podman container for the game
func (s *Service) startPodmanContainer(ctx context.Context, session *GameSession, game *Game) error <span class="cov0" title="0">{
        // Similar to Docker but using Podman
        // Implementation would be similar to startDockerContainer but with Podman-specific options
        return fmt.Errorf("Podman container runtime not yet implemented")
}</span>

// startKubernetesPod starts a Kubernetes pod for the game
func (s *Service) startKubernetesPod(ctx context.Context, session *GameSession, game *Game) error <span class="cov0" title="0">{
        // Implementation for Kubernetes pod creation
        // This would use the Kubernetes client to create a pod
        return fmt.Errorf("Kubernetes pod runtime not yet implemented")
}</span>


// Event streaming methods

// PublishGameEvent publishes an event to all listening streams
func (s *Service) PublishGameEvent(event *GameEvent) <span class="cov0" title="0">{
        s.streamMutex.RLock()
        defer s.streamMutex.RUnlock()

        if streams, exists := s.eventStreams[event.SessionID]; exists </span><span class="cov0" title="0">{
                for _, stream := range streams </span><span class="cov0" title="0">{
                        select </span>{
                        case stream &lt;- event:<span class="cov0" title="0"></span>
                                // Event sent successfully
                        default:<span class="cov0" title="0"></span>
                                // Stream buffer full, skip this event
                        }
                }
        }
}

// AddEventStream adds an event stream for a session
func (s *Service) AddEventStream(sessionID string, stream chan *GameEvent) <span class="cov0" title="0">{
        s.streamMutex.Lock()
        defer s.streamMutex.Unlock()

        if s.eventStreams[sessionID] == nil </span><span class="cov0" title="0">{
                s.eventStreams[sessionID] = make([]chan *GameEvent, 0)
        }</span>
        <span class="cov0" title="0">s.eventStreams[sessionID] = append(s.eventStreams[sessionID], stream)</span>
}

// RemoveEventStream removes an event stream for a session
func (s *Service) RemoveEventStream(sessionID string, stream chan *GameEvent) <span class="cov0" title="0">{
        s.streamMutex.Lock()
        defer s.streamMutex.Unlock()

        if streams, exists := s.eventStreams[sessionID]; exists </span><span class="cov0" title="0">{
                for i, existingStream := range streams </span><span class="cov0" title="0">{
                        if existingStream == stream </span><span class="cov0" title="0">{
                                // Remove stream from slice
                                s.eventStreams[sessionID] = append(streams[:i], streams[i+1:]...)
                                close(stream)
                                break</span>
                        }
                }
        }
}

// gRPC type definitions for compilation (will be replaced by generated proto code)
type StartGameRequestGRPC struct {
        UserID   string
        Username string
        GameID   string
}

type StartGameResponseGRPC struct {
        Session *GameSession
        Error   string
}

type StopGameRequestGRPC struct {
        SessionID string
}

type StopGameResponseGRPC struct {
        Success bool
        Error   string
}

type GetGameSessionRequestGRPC struct {
        SessionID string
}

type GetGameSessionResponseGRPC struct {
        Session *GameSession
        Error   string
}

type ListActiveSessionsRequestGRPC struct {
        UserID string
        GameID string
        Limit  int32
        Offset int32
}

type ListActiveSessionsResponseGRPC struct {
        Sessions   []*GameSession
        TotalCount int32
        Error      string
}

type HealthRequestGRPC struct{}

type HealthResponseGRPC struct {
        Status  string
        Details map[string]string
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package games

import (
        "bytes"
        "context"
        "fmt"
        "strings"
        "text/template"
        "time"

        "github.com/dungeongate/pkg/config"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "sigs.k8s.io/yaml"
)

// KubernetesController manages game pods in Kubernetes
type KubernetesController struct {
        clientset *kubernetes.Clientset
        namespace string
        config    *config.GameServiceConfig
}

// NewKubernetesController creates a new Kubernetes controller
func NewKubernetesController(namespace string, cfg *config.GameServiceConfig) (*KubernetesController, error) <span class="cov0" title="0">{
        // Create in-cluster config
        kubeConfig, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create in-cluster config: %w", err)
        }</span>

        // Create clientset
        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(kubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Kubernetes clientset: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;KubernetesController{
                clientset: clientset,
                namespace: namespace,
                config:    cfg,
        }, nil</span>
}

// StartGamePod starts a new game pod for the given session
func (k *KubernetesController) StartGamePod(ctx context.Context, session *GameSession, game *Game) error <span class="cov0" title="0">{
        // Load pod template
        podSpec, err := k.loadPodTemplate(session, game)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load pod template: %w", err)
        }</span>

        // Create the pod
        <span class="cov0" title="0">pod, err := k.clientset.CoreV1().Pods(k.namespace).Create(ctx, podSpec, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create pod: %w", err)
        }</span>

        // Update session with pod information
        <span class="cov0" title="0">session.PodName = pod.Name
        session.ContainerID = fmt.Sprintf("k8s://%s/%s/%s", k.namespace, pod.Name, "nethack")

        // Wait for pod to be ready
        return k.waitForPodReady(ctx, pod.Name, 60*time.Second)</span>
}

// StopGamePod stops and deletes a game pod
func (k *KubernetesController) StopGamePod(ctx context.Context, session *GameSession) error <span class="cov0" title="0">{
        if session.PodName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no pod name found for session %s", session.ID)
        }</span>

        // Gracefully delete the pod
        <span class="cov0" title="0">gracePeriod := int64(30) // 30 seconds grace period
        deleteOptions := metav1.DeleteOptions{
                GracePeriodSeconds: &amp;gracePeriod,
        }

        return k.clientset.CoreV1().Pods(k.namespace).Delete(ctx, session.PodName, deleteOptions)</span>
}

// GetPodStatus returns the status of a game pod
func (k *KubernetesController) GetPodStatus(ctx context.Context, podName string) (*corev1.PodStatus, error) <span class="cov0" title="0">{
        pod, err := k.clientset.CoreV1().Pods(k.namespace).Get(ctx, podName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pod %s: %w", podName, err)
        }</span>

        <span class="cov0" title="0">return &amp;pod.Status, nil</span>
}

// GetPodLogs returns the logs from a game pod
func (k *KubernetesController) GetPodLogs(ctx context.Context, podName string, lines int64) (string, error) <span class="cov0" title="0">{
        podLogOptions := &amp;corev1.PodLogOptions{
                TailLines: &amp;lines,
        }

        request := k.clientset.CoreV1().Pods(k.namespace).GetLogs(podName, podLogOptions)
        logs, err := request.Stream(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get pod logs: %w", err)
        }</span>
        <span class="cov0" title="0">defer logs.Close()

        buf := new(bytes.Buffer)
        _, err = buf.ReadFrom(logs)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read pod logs: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.String(), nil</span>
}

// WatchGamePods watches for changes in game pods
func (k *KubernetesController) WatchGamePods(ctx context.Context, callback func(*corev1.Pod, watch.EventType)) error <span class="cov0" title="0">{
        watchOptions := metav1.ListOptions{
                LabelSelector: "app=nethack,managed-by=dungeongate-game-service",
                Watch:         true,
        }

        watcher, err := k.clientset.CoreV1().Pods(k.namespace).Watch(ctx, watchOptions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create pod watcher: %w", err)
        }</span>
        <span class="cov0" title="0">defer watcher.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case event, ok := &lt;-watcher.ResultChan():<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("watch channel closed")
                        }</span>

                        <span class="cov0" title="0">pod, ok := event.Object.(*corev1.Pod)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">callback(pod, event.Type)</span>

                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }
}

// ListActivePods returns a list of active game pods
func (k *KubernetesController) ListActivePods(ctx context.Context) ([]*corev1.Pod, error) <span class="cov0" title="0">{
        listOptions := metav1.ListOptions{
                LabelSelector: "app=nethack,managed-by=dungeongate-game-service",
        }

        podList, err := k.clientset.CoreV1().Pods(k.namespace).List(ctx, listOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list pods: %w", err)
        }</span>

        <span class="cov0" title="0">var activePods []*corev1.Pod
        for i := range podList.Items </span><span class="cov0" title="0">{
                pod := &amp;podList.Items[i]
                if pod.Status.Phase == corev1.PodRunning || pod.Status.Phase == corev1.PodPending </span><span class="cov0" title="0">{
                        activePods = append(activePods, pod)
                }</span>
        }

        <span class="cov0" title="0">return activePods, nil</span>
}

// CleanupFinishedPods removes pods that have finished running
func (k *KubernetesController) CleanupFinishedPods(ctx context.Context, maxAge time.Duration) error <span class="cov0" title="0">{
        listOptions := metav1.ListOptions{
                LabelSelector: "app=nethack,managed-by=dungeongate-game-service",
        }

        podList, err := k.clientset.CoreV1().Pods(k.namespace).List(ctx, listOptions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list pods: %w", err)
        }</span>

        <span class="cov0" title="0">cutoff := time.Now().Add(-maxAge)

        for i := range podList.Items </span><span class="cov0" title="0">{
                pod := &amp;podList.Items[i]

                // Skip running or pending pods
                if pod.Status.Phase == corev1.PodRunning || pod.Status.Phase == corev1.PodPending </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if pod is old enough to be cleaned up
                <span class="cov0" title="0">if pod.Status.Phase == corev1.PodSucceeded || pod.Status.Phase == corev1.PodFailed </span><span class="cov0" title="0">{
                        var finishTime time.Time
                        if pod.Status.Phase == corev1.PodSucceeded </span><span class="cov0" title="0">{
                                for _, condition := range pod.Status.Conditions </span><span class="cov0" title="0">{
                                        if condition.Type == corev1.PodReady &amp;&amp; condition.Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                                                finishTime = condition.LastTransitionTime.Time
                                                break</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                for _, containerStatus := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                                        if containerStatus.State.Terminated != nil </span><span class="cov0" title="0">{
                                                finishTime = containerStatus.State.Terminated.FinishedAt.Time
                                                break</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">if !finishTime.IsZero() &amp;&amp; finishTime.Before(cutoff) </span><span class="cov0" title="0">{
                                err := k.clientset.CoreV1().Pods(k.namespace).Delete(ctx, pod.Name, metav1.DeleteOptions{})
                                if err != nil </span><span class="cov0" title="0">{
                                        // Log error but continue with cleanup
                                        fmt.Printf("Failed to delete finished pod %s: %v\n", pod.Name, err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// loadPodTemplate loads and processes the pod template for a game
func (k *KubernetesController) loadPodTemplate(session *GameSession, game *Game) (*corev1.Pod, error) <span class="cov0" title="0">{
        // Get the pod template from ConfigMap
        configMap, err := k.clientset.CoreV1().ConfigMaps(k.namespace).Get(
                context.Background(),
                "nethack-pod-template",
                metav1.GetOptions{},
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pod template ConfigMap: %w", err)
        }</span>

        <span class="cov0" title="0">templateData, exists := configMap.Data["pod-template.yaml"]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pod-template.yaml not found in ConfigMap")
        }</span>

        // Prepare template variables
        <span class="cov0" title="0">vars := map[string]string{
                "SESSION_ID":        session.ID,
                "USER_ID":           fmt.Sprintf("%d", session.UserID),
                "USERNAME":          session.Username,
                "CREATED_AT":        time.Now().Format(time.RFC3339),
                "RECORDING_ENABLED": "true", // TODO: Make this configurable
        }

        // Process the template
        tmpl, err := template.New("pod-template").Parse(templateData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse pod template: %w", err)
        }</span>

        <span class="cov0" title="0">var processedTemplate bytes.Buffer
        err = tmpl.Execute(&amp;processedTemplate, vars)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute pod template: %w", err)
        }</span>

        // Parse the processed YAML
        <span class="cov0" title="0">var pod corev1.Pod
        err = yaml.Unmarshal(processedTemplate.Bytes(), &amp;pod)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal pod YAML: %w", err)
        }</span>

        // Apply additional configurations from game config
        <span class="cov0" title="0">k.applyGameConfig(&amp;pod, game)

        return &amp;pod, nil</span>
}

// applyGameConfig applies game-specific configuration to the pod
func (k *KubernetesController) applyGameConfig(pod *corev1.Pod, game *Game) <span class="cov0" title="0">{
        // Find the main container (should be "nethack")
        var container *corev1.Container
        for i := range pod.Spec.Containers </span><span class="cov0" title="0">{
                if pod.Spec.Containers[i].Name == "nethack" </span><span class="cov0" title="0">{
                        container = &amp;pod.Spec.Containers[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if container == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Apply resource limits from game config
        <span class="cov0" title="0">if game.Resources != nil </span><span class="cov0" title="0">{
                if container.Resources.Requests == nil </span><span class="cov0" title="0">{
                        container.Resources.Requests = make(corev1.ResourceList)
                }</span>
                <span class="cov0" title="0">if container.Resources.Limits == nil </span><span class="cov0" title="0">{
                        container.Resources.Limits = make(corev1.ResourceList)
                }</span>

                // Set CPU limits
                <span class="cov0" title="0">if game.Resources.CPULimit != "" </span><span class="cov0" title="0">{
                        container.Resources.Limits[corev1.ResourceCPU] = parseResourceQuantity(game.Resources.CPULimit)
                }</span>
                <span class="cov0" title="0">if game.Resources.CPURequest != "" </span><span class="cov0" title="0">{
                        container.Resources.Requests[corev1.ResourceCPU] = parseResourceQuantity(game.Resources.CPURequest)
                }</span>

                // Set memory limits
                <span class="cov0" title="0">if game.Resources.MemoryLimit != "" </span><span class="cov0" title="0">{
                        container.Resources.Limits[corev1.ResourceMemory] = parseResourceQuantity(game.Resources.MemoryLimit)
                }</span>
                <span class="cov0" title="0">if game.Resources.MemoryRequest != "" </span><span class="cov0" title="0">{
                        container.Resources.Requests[corev1.ResourceMemory] = parseResourceQuantity(game.Resources.MemoryRequest)
                }</span>
        }

        // Apply environment variables from game config
        <span class="cov0" title="0">if game.Environment != nil </span><span class="cov0" title="0">{
                for key, value := range game.Environment </span><span class="cov0" title="0">{
                        // Skip variables that are already set in the template
                        found := false
                        for _, env := range container.Env </span><span class="cov0" title="0">{
                                if env.Name == key </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                container.Env = append(container.Env, corev1.EnvVar{
                                        Name:  key,
                                        Value: value,
                                })
                        }</span>
                }
        }

        // Apply container image configuration
        <span class="cov0" title="0">if game.Container != nil </span><span class="cov0" title="0">{
                if game.Container.Image != "" </span><span class="cov0" title="0">{
                        image := game.Container.Image
                        if game.Container.Tag != "" </span><span class="cov0" title="0">{
                                image += ":" + game.Container.Tag
                        }</span>
                        <span class="cov0" title="0">container.Image = image</span>
                }

                <span class="cov0" title="0">if game.Container.PullPolicy != "" </span><span class="cov0" title="0">{
                        switch strings.ToLower(game.Container.PullPolicy) </span>{
                        case "always":<span class="cov0" title="0">
                                container.ImagePullPolicy = corev1.PullAlways</span>
                        case "never":<span class="cov0" title="0">
                                container.ImagePullPolicy = corev1.PullNever</span>
                        case "ifnotpresent":<span class="cov0" title="0">
                                container.ImagePullPolicy = corev1.PullIfNotPresent</span>
                        }
                }
        }
}

// waitForPodReady waits for a pod to be ready or timeout
func (k *KubernetesController) waitForPodReady(ctx context.Context, podName string, timeout time.Duration) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        watchOptions := metav1.ListOptions{
                FieldSelector: fmt.Sprintf("metadata.name=%s", podName),
                Watch:         true,
        }

        watcher, err := k.clientset.CoreV1().Pods(k.namespace).Watch(ctx, watchOptions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create pod watcher: %w", err)
        }</span>
        <span class="cov0" title="0">defer watcher.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case event, ok := &lt;-watcher.ResultChan():<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("watch channel closed")
                        }</span>

                        <span class="cov0" title="0">pod, ok := event.Object.(*corev1.Pod)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check if pod is ready
                        <span class="cov0" title="0">if pod.Status.Phase == corev1.PodRunning </span><span class="cov0" title="0">{
                                for _, condition := range pod.Status.Conditions </span><span class="cov0" title="0">{
                                        if condition.Type == corev1.PodReady &amp;&amp; condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                                return nil // Pod is ready!
                                        }</span>
                                }
                        }

                        // Check if pod failed
                        <span class="cov0" title="0">if pod.Status.Phase == corev1.PodFailed </span><span class="cov0" title="0">{
                                return fmt.Errorf("pod %s failed: %s", podName, pod.Status.Reason)
                        }</span>

                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("timeout waiting for pod %s to be ready", podName)</span>
                }
        }
}

// parseResourceQuantity parses a resource quantity string into a Kubernetes resource.Quantity
func parseResourceQuantity(s string) resource.Quantity <span class="cov0" title="0">{
        // Parse the resource quantity string
        quantity, err := resource.ParseQuantity(s)
        if err != nil </span><span class="cov0" title="0">{
                // Return zero quantity on error
                return resource.Quantity{}
        }</span>
        <span class="cov0" title="0">return quantity</span>
}

// GetPodMetrics returns resource usage metrics for a pod
func (k *KubernetesController) GetPodMetrics(ctx context.Context, podName string) (*PodMetrics, error) <span class="cov0" title="0">{
        // This would typically use the metrics-server API
        // For now, return a placeholder
        return &amp;PodMetrics{
                PodName:     podName,
                CPUUsage:    "0m",
                MemoryUsage: "0Mi",
                Timestamp:   time.Now(),
        }, nil
}</span>

// PodMetrics represents resource usage metrics for a pod
type PodMetrics struct {
        PodName     string    `json:"pod_name"`
        CPUUsage    string    `json:"cpu_usage"`
        MemoryUsage string    `json:"memory_usage"`
        Timestamp   time.Time `json:"timestamp"`
}

// PodEventHandler handles pod events for monitoring and logging
type PodEventHandler struct {
        service *Service
}

// NewPodEventHandler creates a new pod event handler
func NewPodEventHandler(service *Service) *PodEventHandler <span class="cov0" title="0">{
        return &amp;PodEventHandler{
                service: service,
        }
}</span>

// HandlePodEvent processes pod events and updates session state
func (h *PodEventHandler) HandlePodEvent(pod *corev1.Pod, eventType watch.EventType) <span class="cov0" title="0">{
        sessionID, exists := pod.Labels["session-id"]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch eventType </span>{
        case watch.Added:<span class="cov0" title="0">
                h.handlePodAdded(pod, sessionID)</span>
        case watch.Modified:<span class="cov0" title="0">
                h.handlePodModified(pod, sessionID)</span>
        case watch.Deleted:<span class="cov0" title="0">
                h.handlePodDeleted(pod, sessionID)</span>
        }
}

// handlePodAdded handles when a pod is added
func (h *PodEventHandler) handlePodAdded(pod *corev1.Pod, sessionID string) <span class="cov0" title="0">{
        event := &amp;GameEvent{
                EventID:   generateEventID(),
                SessionID: sessionID,
                EventType: "pod_created",
                EventData: []byte(fmt.Sprintf("Pod %s created", pod.Name)),
                Metadata: map[string]string{
                        "pod_name":      pod.Name,
                        "pod_phase":     string(pod.Status.Phase),
                        "pod_uid":       string(pod.UID),
                        "creation_time": pod.CreationTimestamp.Format(time.RFC3339),
                },
                Timestamp: time.Now(),
        }

        h.service.PublishGameEvent(event)
}</span>

// handlePodModified handles when a pod is modified
func (h *PodEventHandler) handlePodModified(pod *corev1.Pod, sessionID string) <span class="cov0" title="0">{
        // Update session status based on pod phase
        h.service.sessionMutex.Lock()
        if session, exists := h.service.activeSessions[sessionID]; exists </span><span class="cov0" title="0">{
                switch pod.Status.Phase </span>{
                case corev1.PodRunning:<span class="cov0" title="0">
                        session.IsActive = true</span>
                case corev1.PodSucceeded, corev1.PodFailed:<span class="cov0" title="0">
                        session.IsActive = false</span>
                }
        }
        <span class="cov0" title="0">h.service.sessionMutex.Unlock()

        event := &amp;GameEvent{
                EventID:   generateEventID(),
                SessionID: sessionID,
                EventType: "pod_status_changed",
                EventData: []byte(fmt.Sprintf("Pod %s phase: %s", pod.Name, pod.Status.Phase)),
                Metadata: map[string]string{
                        "pod_name":  pod.Name,
                        "pod_phase": string(pod.Status.Phase),
                        "pod_uid":   string(pod.UID),
                },
                Timestamp: time.Now(),
        }

        h.service.PublishGameEvent(event)</span>
}

// handlePodDeleted handles when a pod is deleted
func (h *PodEventHandler) handlePodDeleted(pod *corev1.Pod, sessionID string) <span class="cov0" title="0">{
        // Mark session as inactive
        h.service.sessionMutex.Lock()
        if session, exists := h.service.activeSessions[sessionID]; exists </span><span class="cov0" title="0">{
                session.IsActive = false
        }</span>
        <span class="cov0" title="0">h.service.sessionMutex.Unlock()

        event := &amp;GameEvent{
                EventID:   generateEventID(),
                SessionID: sessionID,
                EventType: "pod_deleted",
                EventData: []byte(fmt.Sprintf("Pod %s deleted", pod.Name)),
                Metadata: map[string]string{
                        "pod_name": pod.Name,
                        "pod_uid":  string(pod.UID),
                },
                Timestamp: time.Now(),
        }

        h.service.PublishGameEvent(event)</span>
}

// generateEventID generates a unique event ID
func generateEventID() string <span class="cov0" title="0">{
        // TODO: Implement proper event ID generation
        return fmt.Sprintf("event_%d", time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package session

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "log"
        "sync"
        "time"
)

// AccessControlManagerImpl implements the AccessControlManager interface
type AccessControlManagerImpl struct {
        config        *ServerAccessConfig
        inviteKeys    map[string]*InviteKey
        preloadedKeys map[string]*PreloadedKey
        accessLogs    []*AccessLog
        mutex         sync.RWMutex

        // Statistics
        stats *ServerAccessStats
}

// AccessLog represents an access attempt log entry
type AccessLog struct {
        ID        string    `json:"id"`
        IPAddress string    `json:"ip_address"`
        Username  string    `json:"username"`
        Action    string    `json:"action"` // "login", "register", "key_validation"
        Success   bool      `json:"success"`
        Reason    string    `json:"reason"`
        Timestamp time.Time `json:"timestamp"`
        UserAgent string    `json:"user_agent,omitempty"`
}

// NewAccessControlManager creates a new access control manager
func NewAccessControlManager(config *ServerAccessConfig) *AccessControlManagerImpl <span class="cov0" title="0">{
        return &amp;AccessControlManagerImpl{
                config:        config,
                inviteKeys:    make(map[string]*InviteKey),
                preloadedKeys: make(map[string]*PreloadedKey),
                accessLogs:    make([]*AccessLog, 0),
                stats: &amp;ServerAccessStats{
                        Mode: config.Mode,
                },
        }
}</span>

// CheckAccess validates access based on server configuration
func (acm *AccessControlManagerImpl) CheckAccess(ctx context.Context, req *AccessControlRequest) (*AccessControlResponse, error) <span class="cov0" title="0">{
        acm.mutex.Lock()
        defer acm.mutex.Unlock()

        // Log the access attempt
        logEntry := &amp;AccessLog{
                ID:        generateAccessLogID(),
                IPAddress: req.IPAddress,
                Username:  req.Username,
                Action:    "access_check",
                Timestamp: time.Now(),
                UserAgent: req.UserAgent,
        }

        response := &amp;AccessControlResponse{
                MaxUsers:     acm.config.MaxUsers,
                CurrentUsers: acm.stats.ActiveUsers,
        }

        // Check user limits
        if acm.stats.ActiveUsers &gt;= acm.config.MaxUsers </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Server at maximum capacity"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        <span class="cov0" title="0">switch acm.config.Mode </span>{
        case AccessModePublic:<span class="cov0" title="0">
                return acm.checkPublicAccess(req, response, logEntry)</span>
        case AccessModeSemiPublic:<span class="cov0" title="0">
                return acm.checkSemiPublicAccess(req, response, logEntry)</span>
        case AccessModePrivate:<span class="cov0" title="0">
                return acm.checkPrivateAccess(req, response, logEntry)</span>
        default:<span class="cov0" title="0">
                response.Allowed = false
                response.Reason = "Invalid server access mode"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil</span>
        }
}

// checkPublicAccess handles public server access
func (acm *AccessControlManagerImpl) checkPublicAccess(req *AccessControlRequest, response *AccessControlResponse, logEntry *AccessLog) (*AccessControlResponse, error) <span class="cov0" title="0">{
        // Public servers allow anyone to register
        if acm.config.AllowAnonymous </span><span class="cov0" title="0">{
                // Check anonymous user limits
                if acm.stats.AnonymousUsers &gt;= acm.config.MaxAnonymousUsers </span><span class="cov0" title="0">{
                        response.Allowed = false
                        response.Reason = "Maximum anonymous users reached"
                        logEntry.Success = false
                        logEntry.Reason = response.Reason
                        acm.accessLogs = append(acm.accessLogs, logEntry)
                        return response, nil
                }</span>
        }

        <span class="cov0" title="0">response.Allowed = true
        logEntry.Success = true
        acm.accessLogs = append(acm.accessLogs, logEntry)
        return response, nil</span>
}

// checkSemiPublicAccess handles semi-public server access
func (acm *AccessControlManagerImpl) checkSemiPublicAccess(req *AccessControlRequest, response *AccessControlResponse, logEntry *AccessLog) (*AccessControlResponse, error) <span class="cov0" title="0">{
        // Semi-public servers require invite keys
        if req.InviteKey == "" </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Invite key required"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        // Validate invite key
        <span class="cov0" title="0">inviteKey, err := acm.validateInviteKeyInternal(req.InviteKey)
        if err != nil </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Invalid invite key"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        // Check if key is still valid
        <span class="cov0" title="0">if !inviteKey.IsActive </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Invite key is no longer active"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        // Check expiration
        <span class="cov0" title="0">if inviteKey.ExpiresAt != nil &amp;&amp; time.Now().After(*inviteKey.ExpiresAt) </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Invite key has expired"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        // Check usage limits
        <span class="cov0" title="0">if inviteKey.MaxUses &gt; 0 &amp;&amp; inviteKey.CurrentUses &gt;= inviteKey.MaxUses </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Invite key usage limit reached"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        <span class="cov0" title="0">response.Allowed = true
        logEntry.Success = true
        acm.accessLogs = append(acm.accessLogs, logEntry)
        return response, nil</span>
}

// checkPrivateAccess handles private server access
func (acm *AccessControlManagerImpl) checkPrivateAccess(req *AccessControlRequest, response *AccessControlResponse, logEntry *AccessLog) (*AccessControlResponse, error) <span class="cov0" title="0">{
        // Private servers require preloaded keys
        if req.AccessKey == "" </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Access key required"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        // Validate preloaded key
        <span class="cov0" title="0">preloadedKey, err := acm.validatePreloadedKeyInternal(req.AccessKey)
        if err != nil </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Invalid access key"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        // Check if key is still valid
        <span class="cov0" title="0">if !preloadedKey.IsActive </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Access key is no longer active"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        // Check expiration
        <span class="cov0" title="0">if preloadedKey.ExpiresAt != nil &amp;&amp; time.Now().After(*preloadedKey.ExpiresAt) </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Access key has expired"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        // Check username match
        <span class="cov0" title="0">if preloadedKey.Username != req.Username </span><span class="cov0" title="0">{
                response.Allowed = false
                response.Reason = "Username does not match access key"
                logEntry.Success = false
                logEntry.Reason = response.Reason
                acm.accessLogs = append(acm.accessLogs, logEntry)
                return response, nil
        }</span>

        <span class="cov0" title="0">response.Allowed = true
        response.RequiredRole = preloadedKey.Role
        logEntry.Success = true
        acm.accessLogs = append(acm.accessLogs, logEntry)
        return response, nil</span>
}

// ValidateInviteKey validates an invite key
func (acm *AccessControlManagerImpl) ValidateInviteKey(ctx context.Context, key string) (*InviteKey, error) <span class="cov0" title="0">{
        acm.mutex.RLock()
        defer acm.mutex.RUnlock()

        return acm.validateInviteKeyInternal(key)
}</span>

// validateInviteKeyInternal validates an invite key (internal method)
func (acm *AccessControlManagerImpl) validateInviteKeyInternal(key string) (*InviteKey, error) <span class="cov0" title="0">{
        inviteKey, exists := acm.inviteKeys[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invite key not found")
        }</span>

        <span class="cov0" title="0">return inviteKey, nil</span>
}

// ValidatePreloadedKey validates a preloaded key
func (acm *AccessControlManagerImpl) ValidatePreloadedKey(ctx context.Context, key string) (*PreloadedKey, error) <span class="cov0" title="0">{
        acm.mutex.RLock()
        defer acm.mutex.RUnlock()

        return acm.validatePreloadedKeyInternal(key)
}</span>

// validatePreloadedKeyInternal validates a preloaded key (internal method)
func (acm *AccessControlManagerImpl) validatePreloadedKeyInternal(key string) (*PreloadedKey, error) <span class="cov0" title="0">{
        preloadedKey, exists := acm.preloadedKeys[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("preloaded key not found")
        }</span>

        <span class="cov0" title="0">return preloadedKey, nil</span>
}

// CreateInviteKey creates a new invite key
func (acm *AccessControlManagerImpl) CreateInviteKey(ctx context.Context, createdBy string, opts *InviteKeyOptions) (*InviteKey, error) <span class="cov0" title="0">{
        acm.mutex.Lock()
        defer acm.mutex.Unlock()

        key := generateInviteKey()
        inviteKey := &amp;InviteKey{
                ID:          generateKeyID(),
                Key:         key,
                CreatedBy:   createdBy,
                CreatedAt:   time.Now(),
                IsActive:    true,
                MaxUses:     opts.MaxUses,
                CurrentUses: 0,
                Notes:       opts.Notes,
        }

        if opts.ExpiresAt != nil </span><span class="cov0" title="0">{
                inviteKey.ExpiresAt = opts.ExpiresAt
        }</span>

        <span class="cov0" title="0">acm.inviteKeys[key] = inviteKey
        acm.stats.ActiveInviteKeys++

        log.Printf("Created invite key: %s by %s", inviteKey.ID, createdBy)
        return inviteKey, nil</span>
}

// CreatePreloadedKey creates a new preloaded key
func (acm *AccessControlManagerImpl) CreatePreloadedKey(ctx context.Context, createdBy string, opts *PreloadedKeyOptions) (*PreloadedKey, error) <span class="cov0" title="0">{
        acm.mutex.Lock()
        defer acm.mutex.Unlock()

        key := generateAccessKey()
        preloadedKey := &amp;PreloadedKey{
                ID:        generateKeyID(),
                Key:       key,
                Username:  opts.Username,
                Email:     opts.Email,
                CreatedBy: createdBy,
                CreatedAt: time.Now(),
                IsActive:  true,
                Role:      opts.Role,
                Notes:     opts.Notes,
        }

        if opts.ExpiresAt != nil </span><span class="cov0" title="0">{
                preloadedKey.ExpiresAt = opts.ExpiresAt
        }</span>

        <span class="cov0" title="0">acm.preloadedKeys[key] = preloadedKey
        acm.stats.ActivePreloadedKeys++

        log.Printf("Created preloaded key: %s for user %s by %s", preloadedKey.ID, opts.Username, createdBy)
        return preloadedKey, nil</span>
}

// RevokeInviteKey revokes an invite key
func (acm *AccessControlManagerImpl) RevokeInviteKey(ctx context.Context, keyID string) error <span class="cov0" title="0">{
        acm.mutex.Lock()
        defer acm.mutex.Unlock()

        // Find key by ID
        for _, inviteKey := range acm.inviteKeys </span><span class="cov0" title="0">{
                if inviteKey.ID == keyID </span><span class="cov0" title="0">{
                        inviteKey.IsActive = false
                        acm.stats.ActiveInviteKeys--
                        log.Printf("Revoked invite key: %s", keyID)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("invite key not found: %s", keyID)</span>
}

// RevokePreloadedKey revokes a preloaded key
func (acm *AccessControlManagerImpl) RevokePreloadedKey(ctx context.Context, keyID string) error <span class="cov0" title="0">{
        acm.mutex.Lock()
        defer acm.mutex.Unlock()

        // Find key by ID
        for _, preloadedKey := range acm.preloadedKeys </span><span class="cov0" title="0">{
                if preloadedKey.ID == keyID </span><span class="cov0" title="0">{
                        preloadedKey.IsActive = false
                        acm.stats.ActivePreloadedKeys--
                        log.Printf("Revoked preloaded key: %s", keyID)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("preloaded key not found: %s", keyID)</span>
}

// ListInviteKeys returns all invite keys
func (acm *AccessControlManagerImpl) ListInviteKeys(ctx context.Context, activeOnly bool) ([]*InviteKey, error) <span class="cov0" title="0">{
        acm.mutex.RLock()
        defer acm.mutex.RUnlock()

        keys := make([]*InviteKey, 0)
        for _, inviteKey := range acm.inviteKeys </span><span class="cov0" title="0">{
                if !activeOnly || inviteKey.IsActive </span><span class="cov0" title="0">{
                        keys = append(keys, inviteKey)
                }</span>
        }

        <span class="cov0" title="0">return keys, nil</span>
}

// ListPreloadedKeys returns all preloaded keys
func (acm *AccessControlManagerImpl) ListPreloadedKeys(ctx context.Context, activeOnly bool) ([]*PreloadedKey, error) <span class="cov0" title="0">{
        acm.mutex.RLock()
        defer acm.mutex.RUnlock()

        keys := make([]*PreloadedKey, 0)
        for _, preloadedKey := range acm.preloadedKeys </span><span class="cov0" title="0">{
                if !activeOnly || preloadedKey.IsActive </span><span class="cov0" title="0">{
                        keys = append(keys, preloadedKey)
                }</span>
        }

        <span class="cov0" title="0">return keys, nil</span>
}

// GetServerStats returns server access statistics
func (acm *AccessControlManagerImpl) GetServerStats(ctx context.Context) (*ServerAccessStats, error) <span class="cov0" title="0">{
        acm.mutex.RLock()
        defer acm.mutex.RUnlock()

        // Update dynamic stats
        stats := *acm.stats
        stats.MaxUsers = acm.config.MaxUsers

        return &amp;stats, nil
}</span>

// UseInviteKey marks an invite key as used
func (acm *AccessControlManagerImpl) UseInviteKey(ctx context.Context, key string, usedBy string) error <span class="cov0" title="0">{
        acm.mutex.Lock()
        defer acm.mutex.Unlock()

        inviteKey, exists := acm.inviteKeys[key]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("invite key not found")
        }</span>

        <span class="cov0" title="0">inviteKey.CurrentUses++
        now := time.Now()
        inviteKey.UsedAt = &amp;now
        inviteKey.UsedBy = &amp;usedBy

        // Deactivate if max uses reached
        if inviteKey.MaxUses &gt; 0 &amp;&amp; inviteKey.CurrentUses &gt;= inviteKey.MaxUses </span><span class="cov0" title="0">{
                inviteKey.IsActive = false
                acm.stats.ActiveInviteKeys--
                acm.stats.UsedInviteKeys++
        }</span>

        <span class="cov0" title="0">log.Printf("Invite key %s used by %s (usage: %d/%d)", inviteKey.ID, usedBy, inviteKey.CurrentUses, inviteKey.MaxUses)
        return nil</span>
}

// UsePreloadedKey marks a preloaded key as used
func (acm *AccessControlManagerImpl) UsePreloadedKey(ctx context.Context, key string) error <span class="cov0" title="0">{
        acm.mutex.Lock()
        defer acm.mutex.Unlock()

        preloadedKey, exists := acm.preloadedKeys[key]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("preloaded key not found")
        }</span>

        <span class="cov0" title="0">now := time.Now()
        preloadedKey.UsedAt = &amp;now

        // Mark as used (private keys are typically single-use)
        preloadedKey.IsActive = false
        acm.stats.ActivePreloadedKeys--
        acm.stats.UsedPreloadedKeys++

        log.Printf("Preloaded key %s used for user %s", preloadedKey.ID, preloadedKey.Username)
        return nil</span>
}

// CleanupExpiredKeys removes expired keys
func (acm *AccessControlManagerImpl) CleanupExpiredKeys(ctx context.Context) error <span class="cov0" title="0">{
        acm.mutex.Lock()
        defer acm.mutex.Unlock()

        now := time.Now()
        cleanedInvite := 0
        cleanedPreloaded := 0

        // Clean up expired invite keys
        for key, inviteKey := range acm.inviteKeys </span><span class="cov0" title="0">{
                if inviteKey.ExpiresAt != nil &amp;&amp; now.After(*inviteKey.ExpiresAt) </span><span class="cov0" title="0">{
                        if inviteKey.IsActive </span><span class="cov0" title="0">{
                                inviteKey.IsActive = false
                                acm.stats.ActiveInviteKeys--
                        }</span>
                        <span class="cov0" title="0">delete(acm.inviteKeys, key)
                        cleanedInvite++</span>
                }
        }

        // Clean up expired preloaded keys
        <span class="cov0" title="0">for key, preloadedKey := range acm.preloadedKeys </span><span class="cov0" title="0">{
                if preloadedKey.ExpiresAt != nil &amp;&amp; now.After(*preloadedKey.ExpiresAt) </span><span class="cov0" title="0">{
                        if preloadedKey.IsActive </span><span class="cov0" title="0">{
                                preloadedKey.IsActive = false
                                acm.stats.ActivePreloadedKeys--
                        }</span>
                        <span class="cov0" title="0">delete(acm.preloadedKeys, key)
                        cleanedPreloaded++</span>
                }
        }

        <span class="cov0" title="0">if cleanedInvite &gt; 0 || cleanedPreloaded &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Cleaned up %d expired invite keys and %d expired preloaded keys", cleanedInvite, cleanedPreloaded)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateUserStats updates user statistics
func (acm *AccessControlManagerImpl) UpdateUserStats(activeUsers, anonymousUsers, registeredUsers int) <span class="cov0" title="0">{
        acm.mutex.Lock()
        defer acm.mutex.Unlock()

        acm.stats.ActiveUsers = activeUsers
        acm.stats.AnonymousUsers = anonymousUsers
        acm.stats.RegisteredUsers = registeredUsers
        acm.stats.TotalUsers = anonymousUsers + registeredUsers
}</span>

// Helper functions for key generation

// generateInviteKey generates a random invite key
func generateInviteKey() string <span class="cov0" title="0">{
        return "inv_" + generateRandomString(16)
}</span>

// generateAccessKey generates a random access key
func generateAccessKey() string <span class="cov0" title="0">{
        return "acc_" + generateRandomString(32)
}</span>

// generateKeyID generates a random key ID
func generateKeyID() string <span class="cov0" title="0">{
        return "key_" + generateRandomString(12)
}</span>

// generateAccessLogID generates a random access log ID
func generateAccessLogID() string <span class="cov0" title="0">{
        return "log_" + generateRandomString(12)
}</span>

// generateRandomString generates a random hexadecimal string
func generateRandomString(length int) string <span class="cov0" title="0">{
        bytes := make([]byte, length/2)
        _, _ = rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package session

import (
        "context"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/dungeongate/internal/auth"
)

// AuthMiddleware handles authentication for the session service
type AuthMiddleware struct {
        authClient *auth.AuthServiceClientImpl
        enabled    bool
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(authServiceAddress string, enabled bool) (*AuthMiddleware, error) <span class="cov0" title="0">{
        if !enabled </span><span class="cov0" title="0">{
                return &amp;AuthMiddleware{enabled: false}, nil
        }</span>

        <span class="cov0" title="0">authClient, err := auth.NewAuthServiceClient(authServiceAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create auth client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AuthMiddleware{
                authClient: authClient,
                enabled:    true,
        }, nil</span>
}

// Close closes the auth client connection
func (m *AuthMiddleware) Close() error <span class="cov0" title="0">{
        if m.authClient != nil </span><span class="cov0" title="0">{
                return m.authClient.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AuthenticateUser authenticates a user via the auth service
func (m *AuthMiddleware) AuthenticateUser(ctx context.Context, username, password, clientIP string) (*User, error) <span class="cov0" title="0">{
        if !m.enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication disabled")
        }</span>

        <span class="cov0" title="0">loginReq := &amp;auth.SessionLoginRequest{
                Username: username,
                Password: password,
                ClientIP: clientIP,
        }

        resp, err := m.authClient.Login(ctx, loginReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s", resp.Error)
        }</span>

        // Convert from SessionUser to session User
        // Convert string ID to int
        <span class="cov0" title="0">userID, err := strconv.Atoi(resp.User.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user ID: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;User{
                ID:              userID,
                Username:        resp.User.Username,
                Email:           resp.User.Email,
                IsAuthenticated: resp.User.IsAuthenticated,
                IsActive:        resp.User.IsActive,
                IsAdmin:         resp.User.IsAdmin,
                CreatedAt:       resp.User.CreatedAt,
                UpdatedAt:       resp.User.UpdatedAt,
                LastLogin:       resp.User.LastLogin,
        }, nil</span>
}

// ValidateToken validates an access token
func (m *AuthMiddleware) ValidateToken(ctx context.Context, token string) (*User, error) <span class="cov0" title="0">{
        if !m.enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication disabled")
        }</span>

        // Remove Bearer prefix if present
        <span class="cov0" title="0">token = strings.TrimPrefix(token, "Bearer ")

        sessionUser, err := m.authClient.ValidateToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token validation failed: %w", err)
        }</span>

        // Convert from SessionUser to session User
        // Convert string ID to int
        <span class="cov0" title="0">userID, err := strconv.Atoi(sessionUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user ID: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;User{
                ID:              userID,
                Username:        sessionUser.Username,
                Email:           sessionUser.Email,
                IsAuthenticated: sessionUser.IsAuthenticated,
                IsActive:        sessionUser.IsActive,
                IsAdmin:         sessionUser.IsAdmin,
                CreatedAt:       sessionUser.CreatedAt,
                UpdatedAt:       sessionUser.UpdatedAt,
                LastLogin:       sessionUser.LastLogin,
        }, nil</span>
}

// RefreshToken refreshes an access token
func (m *AuthMiddleware) RefreshToken(ctx context.Context, refreshToken string) (*auth.SessionLoginResponse, error) <span class="cov0" title="0">{
        if !m.enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication disabled")
        }</span>

        <span class="cov0" title="0">return m.authClient.RefreshToken(ctx, refreshToken)</span>
}

// Logout logs out a user
func (m *AuthMiddleware) Logout(ctx context.Context, accessToken string) error <span class="cov0" title="0">{
        if !m.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return m.authClient.Logout(ctx, accessToken)</span>
}

// AuthenticatedSSHHandler wraps SSH session context with authentication
type AuthenticatedSSHHandler struct {
        middleware *AuthMiddleware
        next       func(ctx context.Context, sessionCtx *SSHSessionContext) error
}

// NewAuthenticatedSSHHandler creates a new authenticated SSH handler
func NewAuthenticatedSSHHandler(middleware *AuthMiddleware, next func(ctx context.Context, sessionCtx *SSHSessionContext) error) *AuthenticatedSSHHandler <span class="cov0" title="0">{
        return &amp;AuthenticatedSSHHandler{
                middleware: middleware,
                next:       next,
        }
}</span>

// Handle processes the SSH session with authentication
func (h *AuthenticatedSSHHandler) Handle(ctx context.Context, sessionCtx *SSHSessionContext) error <span class="cov0" title="0">{
        // If already authenticated, proceed
        if sessionCtx.IsAuthenticated </span><span class="cov0" title="0">{
                return h.next(ctx, sessionCtx)
        }</span>

        // Authentication required - this would be called from the menu system
        // For now, just proceed (authentication happens in the menu)
        <span class="cov0" title="0">return h.next(ctx, sessionCtx)</span>
}

// TokenAuthenticator provides token-based authentication methods
type TokenAuthenticator struct {
        middleware *AuthMiddleware
}

// NewTokenAuthenticator creates a new token authenticator
func NewTokenAuthenticator(middleware *AuthMiddleware) *TokenAuthenticator <span class="cov0" title="0">{
        return &amp;TokenAuthenticator{
                middleware: middleware,
        }
}</span>

// AuthenticateWithToken authenticates a user with a token
func (t *TokenAuthenticator) AuthenticateWithToken(ctx context.Context, token string) (*User, error) <span class="cov0" title="0">{
        return t.middleware.ValidateToken(ctx, token)
}</span>

// AuthenticateWithCredentials authenticates a user with credentials
func (t *TokenAuthenticator) AuthenticateWithCredentials(ctx context.Context, username, password, clientIP string) (*User, string, error) <span class="cov0" title="0">{
        user, err := t.middleware.AuthenticateUser(ctx, username, password, clientIP)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        // In a real implementation, we'd return the access token from the login response
        // For now, return empty token
        <span class="cov0" title="0">return user, "", nil</span>
}

// AuthConfig holds authentication configuration
type AuthConfig struct {
        Enabled            bool          `yaml:"enabled"`
        AuthServiceAddress string        `yaml:"auth_service_address"`
        TokenExpiration    time.Duration `yaml:"token_expiration"`
        RequireTokenForAPI bool          `yaml:"require_token_for_api"`
        RequireTokenForSSH bool          `yaml:"require_token_for_ssh"`
}

// DefaultAuthConfig returns default authentication configuration
func DefaultAuthConfig() *AuthConfig <span class="cov0" title="0">{
        return &amp;AuthConfig{
                Enabled:            true,
                AuthServiceAddress: "localhost:8082",
                TokenExpiration:    15 * time.Minute,
                RequireTokenForAPI: false,
                RequireTokenForSSH: false,
        }
}</span>

// HTTPAuthMiddleware provides HTTP authentication middleware
type HTTPAuthMiddleware struct {
        authenticator *TokenAuthenticator
        config        *AuthConfig
}

// NewHTTPAuthMiddleware creates a new HTTP authentication middleware
func NewHTTPAuthMiddleware(authenticator *TokenAuthenticator, config *AuthConfig) *HTTPAuthMiddleware <span class="cov0" title="0">{
        return &amp;HTTPAuthMiddleware{
                authenticator: authenticator,
                config:        config,
        }
}</span>

// AuthenticateHTTPRequest authenticates an HTTP request
func (h *HTTPAuthMiddleware) AuthenticateHTTPRequest(ctx context.Context, authHeader string) (*User, error) <span class="cov0" title="0">{
        if !h.config.Enabled || !h.config.RequireTokenForAPI </span><span class="cov0" title="0">{
                return nil, nil // Authentication not required
        }</span>

        <span class="cov0" title="0">if authHeader == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authorization header required")
        }</span>

        // Extract token from Authorization header
        <span class="cov0" title="0">const bearerPrefix = "Bearer "
        if !strings.HasPrefix(authHeader, bearerPrefix) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authorization header must start with 'Bearer '")
        }</span>

        <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, bearerPrefix)
        if token == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty token in authorization header")
        }</span>

        <span class="cov0" title="0">return h.authenticator.AuthenticateWithToken(ctx, token)</span>
}

// AuthenticationResult holds the result of authentication
type AuthenticationResult struct {
        User         *User
        AccessToken  string
        RefreshToken string
        ExpiresAt    time.Time
        Error        string
        ErrorCode    string
}

// LoginResult holds the result of a login attempt
type LoginResult struct {
        Success           bool
        User              *User
        AccessToken       string
        RefreshToken      string
        ExpiresAt         time.Time
        Error             string
        ErrorCode         string
        RemainingAttempts int
        RetryAfter        time.Duration
}

// AuthenticationError represents authentication errors
type AuthenticationError struct {
        Code    string
        Message string
}

func (e *AuthenticationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewAuthenticationError creates a new authentication error
func NewAuthenticationError(code, message string) *AuthenticationError <span class="cov0" title="0">{
        return &amp;AuthenticationError{
                Code:    code,
                Message: message,
        }
}</span>

// Common authentication error codes
const (
        AuthErrorInvalidCredentials = "invalid_credentials"
        AuthErrorUserNotFound       = "user_not_found"
        AuthErrorAccountLocked      = "account_locked"
        AuthErrorTokenExpired       = "token_expired"
        AuthErrorTokenInvalid       = "token_invalid"
        AuthErrorInternalError      = "internal_error"
        AuthErrorServiceUnavailable = "service_unavailable"
)
</pre>
		
		<pre class="file" id="file12" style="display: none">package session

import (
        "context"
        "fmt"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"

        "github.com/dungeongate/pkg/config"
)

// GameServiceGRPCClient represents a gRPC client for the game service
type GameServiceGRPCClient struct {
        conn    *grpc.ClientConn
        address string
        timeout time.Duration
}

// NewGameServiceGRPCClient creates a new game service gRPC client
func NewGameServiceGRPCClient(address string) (*GameServiceGRPCClient, error) <span class="cov0" title="0">{
        // Set up connection options
        opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()), // TODO: Add TLS in production
        }

        // Connect to the game service
        conn, err := grpc.NewClient(address, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to game service at %s: %w", address, err)
        }</span>

        <span class="cov0" title="0">return &amp;GameServiceGRPCClient{
                conn:    conn,
                address: address,
                timeout: 30 * time.Second,
        }, nil</span>
}

// Close closes the connection to the game service
func (c *GameServiceGRPCClient) Close() error <span class="cov0" title="0">{
        if c.conn != nil </span><span class="cov0" title="0">{
                return c.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// StartGameGRPCRequest represents a gRPC request to start a game
type StartGameGRPCRequest struct {
        UserID          string            `json:"user_id"`
        Username        string            `json:"username"`
        GameID          string            `json:"game_id"`
        SessionID       string            `json:"session_id"`
        Environment     map[string]string `json:"environment"`
        EnableRecording bool              `json:"enable_recording"`
}

// StartGameResponse represents the response from starting a game
type StartGameResponse struct {
        SessionID   string `json:"session_id"`
        ContainerID string `json:"container_id"`
        PodName     string `json:"pod_name"`
        Success     bool   `json:"success"`
        Error       string `json:"error,omitempty"`
}

// StopGameRequest represents a request to stop a game
type StopGameRequest struct {
        SessionID string `json:"session_id"`
        UserID    string `json:"user_id"`
        Force     bool   `json:"force"`
        Reason    string `json:"reason"`
}

// StopGameResponse represents the response from stopping a game
type StopGameResponse struct {
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
}

// GameSessionInfo represents information about a game session
type GameSessionInfo struct {
        SessionID     string            `json:"session_id"`
        UserID        string            `json:"user_id"`
        Username      string            `json:"username"`
        GameID        string            `json:"game_id"`
        Status        string            `json:"status"`
        StartTime     time.Time         `json:"start_time"`
        LastActivity  time.Time         `json:"last_activity"`
        ContainerID   string            `json:"container_id"`
        PodName       string            `json:"pod_name"`
        RecordingPath string            `json:"recording_path"`
        Spectators    []string          `json:"spectators"`
        Metadata      map[string]string `json:"metadata"`
}

// StartGame starts a new game session
func (c *GameServiceGRPCClient) StartGame(ctx context.Context, req *StartGameRequest) (*StartGameResponse, error) <span class="cov0" title="0">{
        // Create context with timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, c.timeout)
        defer cancel()
        _ = timeoutCtx // TODO: Use this context when implementing gRPC call

        // This would normally call the gRPC service
        // For now, we'll simulate the response

        // TODO: Replace with actual gRPC call when protobuf is generated
        // client := games.NewGameServiceClient(c.conn)
        // response, err := client.StartGame(ctx, &amp;games.StartGameRequest{...})

        // Generate a session ID since the existing StartGameRequest doesn't have one
        sessionID := fmt.Sprintf("session_%d_%s", req.UserID, req.GameID)

        // Simulate game service response
        response := &amp;StartGameResponse{
                SessionID:   sessionID,
                ContainerID: fmt.Sprintf("container_%s", sessionID),
                PodName:     fmt.Sprintf("nethack-%s", sessionID),
                Success:     true,
        }

        return response, nil
}</span>

// StopGame stops a game session
func (c *GameServiceGRPCClient) StopGame(ctx context.Context, req *StopGameRequest) (*StopGameResponse, error) <span class="cov0" title="0">{
        // Create context with timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, c.timeout)
        defer cancel()
        _ = timeoutCtx // TODO: Use this context when implementing gRPC call

        // TODO: Replace with actual gRPC call when protobuf is generated
        // client := games.NewGameServiceClient(c.conn)
        // response, err := client.StopGame(ctx, &amp;games.StopGameRequest{...})

        // Simulate game service response
        response := &amp;StopGameResponse{
                Success: true,
        }

        return response, nil
}</span>

// GetGameSession gets information about a game session
func (c *GameServiceGRPCClient) GetGameSession(ctx context.Context, sessionID string) (*GameSessionInfo, error) <span class="cov0" title="0">{
        // Create context with timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, c.timeout)
        defer cancel()
        _ = timeoutCtx // TODO: Use this context when implementing gRPC call

        // TODO: Replace with actual gRPC call when protobuf is generated
        // client := games.NewGameServiceClient(c.conn)
        // response, err := client.GetGameSession(ctx, &amp;games.GetGameSessionRequest{...})

        // Simulate game service response
        info := &amp;GameSessionInfo{
                SessionID:    sessionID,
                Status:       "running",
                StartTime:    time.Now().Add(-time.Hour),
                LastActivity: time.Now(),
                ContainerID:  fmt.Sprintf("container_%s", sessionID),
                PodName:      fmt.Sprintf("nethack-%s", sessionID),
                Spectators:   []string{},
                Metadata:     make(map[string]string),
        }

        return info, nil
}</span>

// ListActiveGames lists all active game sessions
func (c *GameServiceGRPCClient) ListActiveGames(ctx context.Context, userID string) ([]*GameSessionInfo, error) <span class="cov0" title="0">{
        // Create context with timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, c.timeout)
        defer cancel()
        _ = timeoutCtx // TODO: Use this context when implementing gRPC call

        // TODO: Replace with actual gRPC call when protobuf is generated
        // client := games.NewGameServiceClient(c.conn)
        // response, err := client.ListActiveSessions(ctx, &amp;games.ListActiveSessionsRequest{...})

        // Simulate game service response
        sessions := []*GameSessionInfo{
                {
                        SessionID:    "session_123",
                        UserID:       userID,
                        Username:     "testuser",
                        GameID:       "nethack",
                        Status:       "running",
                        StartTime:    time.Now().Add(-time.Hour),
                        LastActivity: time.Now(),
                        ContainerID:  "container_session_123",
                        PodName:      "nethack-session_123",
                        Spectators:   []string{},
                        Metadata:     make(map[string]string),
                },
        }

        return sessions, nil
}</span>

// HealthCheck performs a health check on the game service
func (c *GameServiceGRPCClient) HealthCheck(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        // Create context with timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()
        _ = timeoutCtx // TODO: Use this context when implementing gRPC call

        // TODO: Replace with actual gRPC call when protobuf is generated
        // client := games.NewGameServiceClient(c.conn)
        // response, err := client.Health(ctx, &amp;empty.Empty{})

        // For now, just check if connection is alive
        state := c.conn.GetState()
        return state.String() == "READY", nil
}</span>

// IsAvailable checks if the game service is available
func (c *GameServiceGRPCClient) IsAvailable() bool <span class="cov0" title="0">{
        if c.conn == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">state := c.conn.GetState()
        return state.String() == "READY"</span>
}

// Reconnect attempts to reconnect to the game service
func (c *GameServiceGRPCClient) Reconnect() error <span class="cov0" title="0">{
        if c.conn != nil </span><span class="cov0" title="0">{
                c.conn.Close()
        }</span>

        // Set up connection options
        <span class="cov0" title="0">opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()), // TODO: Add TLS in production
        }

        // Connect to the game service
        conn, err := grpc.NewClient(c.address, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reconnect to game service at %s: %w", c.address, err)
        }</span>

        <span class="cov0" title="0">c.conn = conn
        return nil</span>
}

// GameServiceManager manages the connection to the game service
type GameServiceManager struct {
        client      *GameServiceGRPCClient
        config      *config.SessionServiceConfig
        isConnected bool
}

// NewGameServiceManager creates a new game service manager
func NewGameServiceManager(cfg *config.SessionServiceConfig) *GameServiceManager <span class="cov0" title="0">{
        return &amp;GameServiceManager{
                config:      cfg,
                isConnected: false,
        }
}</span>

// Connect connects to the game service
func (m *GameServiceManager) Connect() error <span class="cov0" title="0">{
        if m.client != nil </span><span class="cov0" title="0">{
                m.client.Close()
        }</span>

        <span class="cov0" title="0">client, err := NewGameServiceGRPCClient(m.config.GetServices().GameService)
        if err != nil </span><span class="cov0" title="0">{
                m.isConnected = false
                return fmt.Errorf("failed to connect to game service: %w", err)
        }</span>

        <span class="cov0" title="0">m.client = client
        m.isConnected = true
        return nil</span>
}

// Disconnect disconnects from the game service
func (m *GameServiceManager) Disconnect() error <span class="cov0" title="0">{
        if m.client != nil </span><span class="cov0" title="0">{
                err := m.client.Close()
                m.client = nil
                m.isConnected = false
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetClient returns the game service client
func (m *GameServiceManager) GetClient() *GameServiceGRPCClient <span class="cov0" title="0">{
        return m.client
}</span>

// IsConnected returns whether we're connected to the game service
func (m *GameServiceManager) IsConnected() bool <span class="cov0" title="0">{
        return m.isConnected &amp;&amp; m.client != nil &amp;&amp; m.client.IsAvailable()
}</span>

// EnsureConnected ensures we have a connection to the game service
func (m *GameServiceManager) EnsureConnected() error <span class="cov0" title="0">{
        if !m.IsConnected() </span><span class="cov0" title="0">{
                return m.Connect()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// StartGameWithRetry starts a game with retry logic
func (m *GameServiceManager) StartGameWithRetry(ctx context.Context, req *StartGameRequest, maxRetries int) (*StartGameResponse, error) <span class="cov0" title="0">{
        var lastErr error

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                // Ensure we're connected
                if err := m.EnsureConnected(); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        continue</span>
                }

                // Try to start the game
                <span class="cov0" title="0">response, err := m.client.StartGame(ctx, req)
                if err == nil </span><span class="cov0" title="0">{
                        return response, nil
                }</span>

                // Check if it's a connection error
                <span class="cov0" title="0">if st, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if st.Code() == codes.Unavailable || st.Code() == codes.DeadlineExceeded </span><span class="cov0" title="0">{
                                // Connection error, try to reconnect
                                lastErr = err
                                m.isConnected = false
                                continue</span>
                        }
                }

                // Other errors are not retryable
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to start game after %d attempts: %w", maxRetries, lastErr)</span>
}

// StopGameWithRetry stops a game with retry logic
func (m *GameServiceManager) StopGameWithRetry(ctx context.Context, req *StopGameRequest, maxRetries int) (*StopGameResponse, error) <span class="cov0" title="0">{
        var lastErr error

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                // Ensure we're connected
                if err := m.EnsureConnected(); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        continue</span>
                }

                // Try to stop the game
                <span class="cov0" title="0">response, err := m.client.StopGame(ctx, req)
                if err == nil </span><span class="cov0" title="0">{
                        return response, nil
                }</span>

                // Check if it's a connection error
                <span class="cov0" title="0">if st, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if st.Code() == codes.Unavailable || st.Code() == codes.DeadlineExceeded </span><span class="cov0" title="0">{
                                // Connection error, try to reconnect
                                lastErr = err
                                m.isConnected = false
                                continue</span>
                        }
                }

                // Other errors are not retryable
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to stop game after %d attempts: %w", maxRetries, lastErr)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package session

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

// Enhanced service clients with proper gRPC implementation

type userServiceClientEnhanced struct {
        address string
        // conn field removed - not currently used
}

func NewUserServiceClientEnhanced(address string) UserServiceClient <span class="cov0" title="0">{
        return &amp;userServiceClientEnhanced{address: address}
}</span>

func (c *userServiceClientEnhanced) GetUser(ctx context.Context, username string) (*User, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return &amp;User{
                ID:       1,
                Username: username,
        }, nil
}</span>

func (c *userServiceClientEnhanced) GetUserByID(ctx context.Context, userID int) (*User, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return &amp;User{
                ID:       userID,
                Username: "testuser",
        }, nil
}</span>

func (c *userServiceClientEnhanced) GetUserByUsername(ctx context.Context, username string) (*User, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return &amp;User{
                ID:       1,
                Username: username,
        }, nil
}</span>

func (c *userServiceClientEnhanced) RegisterUser(ctx context.Context, req *RegistrationRequest) (*RegistrationResponse, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return &amp;RegistrationResponse{
                Success: true,
                User: &amp;User{
                        ID:       1,
                        Username: req.Username,
                        Email:    req.Email,
                },
                Message: "Registration successful",
        }, nil
}</span>

func (c *userServiceClientEnhanced) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return &amp;User{
                ID:       1,
                Username: req.Username,
        }, nil
}</span>

func (c *userServiceClientEnhanced) UpdateUser(ctx context.Context, userID int, updates map[string]interface{}) (*User, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return &amp;User{
                ID:       userID,
                Username: "testuser",
        }, nil
}</span>

func (c *userServiceClientEnhanced) DeleteUser(ctx context.Context, userID int) error <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return nil
}</span>

func (c *userServiceClientEnhanced) ListUsers(ctx context.Context, limit, offset int) ([]*User, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return []*User{}, nil
}</span>

func (c *userServiceClientEnhanced) UpdateLastLogin(ctx context.Context, userID int) error <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return nil
}</span>

type gameServiceClientEnhanced struct {
        address string
        // conn field removed - not currently used
}

func NewGameServiceClientEnhanced(address string) GameServiceClient <span class="cov0" title="0">{
        return &amp;gameServiceClientEnhanced{address: address}
}</span>

func (c *gameServiceClientEnhanced) ListGames(ctx context.Context) ([]*Game, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return []*Game{
                {ID: "nethack", Name: "NetHack 3.7.0", Description: "The classic dungeon adventure", Enabled: true},
                {ID: "bash", Name: "Bash Shell", Description: "Interactive command line", Enabled: true},
                {ID: "nano", Name: "Nano Editor", Description: "Text editor with sample file", Enabled: true},
                {ID: "crawl", Name: "Dungeon Crawl Stone Soup", Description: "Modern roguelike adventure", Enabled: true},
        }, nil
}</span>

func (c *gameServiceClientEnhanced) GetGame(ctx context.Context, gameID string) (*Game, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        games := map[string]*Game{
                "nethack": {ID: "nethack", Name: "NetHack 3.7.0", Description: "The classic dungeon adventure", Enabled: true},
                "bash":    {ID: "bash", Name: "Bash Shell", Description: "Interactive command line", Enabled: true},
                "nano":    {ID: "nano", Name: "Nano Editor", Description: "Text editor with sample file", Enabled: true},
                "crawl":   {ID: "crawl", Name: "Dungeon Crawl Stone Soup", Description: "Modern roguelike adventure", Enabled: true},
        }

        if game, exists := games[gameID]; exists </span><span class="cov0" title="0">{
                return game, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("game not found: %s", gameID)</span>
}

func (c *gameServiceClientEnhanced) StartGame(ctx context.Context, req *StartGameRequest) (*GameSession, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return &amp;GameSession{
                ID:       "game_session_" + req.GameID,
                UserID:   req.UserID,
                Username: req.Username,
                GameID:   req.GameID,
        }, nil
}</span>

func (c *gameServiceClientEnhanced) StopGame(ctx context.Context, gameSessionID string) error <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return nil
}</span>

func (c *gameServiceClientEnhanced) GetGameStatus(ctx context.Context, sessionID string) (*GameSession, error) <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return &amp;GameSession{
                ID:       sessionID,
                UserID:   1,
                Username: "testuser",
                GameID:   "nethack",
        }, nil
}</span>

func (c *gameServiceClientEnhanced) UpdateGameConfig(ctx context.Context, gameID string, config *Game) error <span class="cov0" title="0">{
        // TODO: Implement actual gRPC client call
        return nil
}</span>

// gRPC connection management

type GRPCClientManager struct {
        authConn *grpc.ClientConn
        userConn *grpc.ClientConn
        gameConn *grpc.ClientConn
}

func NewGRPCClientManager(authAddr, userAddr, gameAddr string) *GRPCClientManager <span class="cov0" title="0">{
        return &amp;GRPCClientManager{}
}</span>

func (m *GRPCClientManager) ConnectAuth(address string) error <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to auth service: %w", err)
        }</span>
        <span class="cov0" title="0">m.authConn = conn
        return nil</span>
}

func (m *GRPCClientManager) ConnectUser(address string) error <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to user service: %w", err)
        }</span>
        <span class="cov0" title="0">m.userConn = conn
        return nil</span>
}

func (m *GRPCClientManager) ConnectGame(address string) error <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to game service: %w", err)
        }</span>
        <span class="cov0" title="0">m.gameConn = conn
        return nil</span>
}

func (m *GRPCClientManager) Close() error <span class="cov0" title="0">{
        var err error
        if m.authConn != nil </span><span class="cov0" title="0">{
                if closeErr := m.authConn.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }
        <span class="cov0" title="0">if m.userConn != nil </span><span class="cov0" title="0">{
                if closeErr := m.userConn.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }
        <span class="cov0" title="0">if m.gameConn != nil </span><span class="cov0" title="0">{
                if closeErr := m.gameConn.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

// Error handling for gRPC


// Service health checking

type ServiceHealthChecker struct {
        userClient UserServiceClient
        gameClient GameServiceClient
}

func NewServiceHealthChecker(userClient UserServiceClient, gameClient GameServiceClient) *ServiceHealthChecker <span class="cov0" title="0">{
        return &amp;ServiceHealthChecker{
                userClient: userClient,
                gameClient: gameClient,
        }
}</span>

func (h *ServiceHealthChecker) CheckAllServices(ctx context.Context) map[string]error <span class="cov0" title="0">{
        results := make(map[string]error)

        // Check user service
        results["user"] = h.checkUserService(ctx)

        // Check game service
        results["game"] = h.checkGameService(ctx)

        return results
}</span>

func (h *ServiceHealthChecker) checkUserService(ctx context.Context) error <span class="cov0" title="0">{
        // Try to get a non-existent user
        _, err := h.userClient.GetUser(ctx, "health_check_user")
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *ServiceHealthChecker) checkGameService(ctx context.Context) error <span class="cov0" title="0">{
        // Try to list games
        _, err := h.gameClient.ListGames(ctx)
        return err
}</span>

// Service discovery and configuration

type ServiceConfig struct {
        AuthService string `json:"auth_service"`
        UserService string `json:"user_service"`
        GameService string `json:"game_service"`
        Timeout     string `json:"timeout"`
        Retries     int    `json:"retries"`
}

func (c *ServiceConfig) GetTimeout() time.Duration <span class="cov0" title="0">{
        if c.Timeout == "" </span><span class="cov0" title="0">{
                return 30 * time.Second
        }</span>
        <span class="cov0" title="0">if duration, err := time.ParseDuration(c.Timeout); err == nil </span><span class="cov0" title="0">{
                return duration
        }</span>
        <span class="cov0" title="0">return 30 * time.Second</span>
}

func (c *ServiceConfig) GetRetries() int <span class="cov0" title="0">{
        if c.Retries &lt;= 0 </span><span class="cov0" title="0">{
                return 3
        }</span>
        <span class="cov0" title="0">return c.Retries</span>
}

// Service registry for dynamic service discovery
type ServiceRegistry struct {
        services map[string]string
        mutex    sync.RWMutex
}

func NewServiceRegistry() *ServiceRegistry <span class="cov0" title="0">{
        return &amp;ServiceRegistry{
                services: make(map[string]string),
        }
}</span>

func (r *ServiceRegistry) Register(serviceName, address string) <span class="cov0" title="0">{
        r.mutex.Lock()
        defer r.mutex.Unlock()
        r.services[serviceName] = address
}</span>

func (r *ServiceRegistry) Unregister(serviceName string) <span class="cov0" title="0">{
        r.mutex.Lock()
        defer r.mutex.Unlock()
        delete(r.services, serviceName)
}</span>

func (r *ServiceRegistry) GetService(serviceName string) (string, bool) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()
        address, exists := r.services[serviceName]
        return address, exists
}</span>

func (r *ServiceRegistry) ListServices() map[string]string <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()
        result := make(map[string]string)
        for k, v := range r.services </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package session

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "sync"
        "syscall"
        "time"

        "github.com/creack/pty"
)

// PTYManager manages PTY sessions
type PTYManager struct {
        sessions    map[string]*PTYSession
        sessionsMux sync.RWMutex
}

// PTYSession represents a PTY session
type PTYSession struct {
        SessionID   string
        Username    string
        GameID      string
        PTY         *os.File
        TTY         *os.File
        Command     *exec.Cmd
        ProcessPID  int
        ExitCode    int
        IsActive    bool
        IsClosed    bool
        WindowSize  WindowSize
        Environment map[string]string
        StartTime   time.Time

        // I/O buffers
        inputBuffer  []byte
        outputBuffer []byte

        // Synchronization
        mutex      sync.RWMutex
        inputChan  chan []byte
        outputChan chan []byte
        doneChan   chan struct{}
}

// NewPTYManager creates a new PTY manager
func NewPTYManager() (*PTYManager, error) <span class="cov8" title="1">{
        return &amp;PTYManager{
                sessions: make(map[string]*PTYSession),
        }, nil
}</span>

// AllocatePTY allocates a new PTY session
func (pm *PTYManager) AllocatePTY(sessionID, username, gameID string, windowSize WindowSize) (*PTYSession, error) <span class="cov8" title="1">{
        pm.sessionsMux.Lock()
        defer pm.sessionsMux.Unlock()

        // Check if session already exists
        if _, exists := pm.sessions[sessionID]; exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PTY session %s already exists", sessionID)
        }</span>

        // Use creack/pty for cross-platform PTY allocation
        <span class="cov8" title="1">ptyMaster, ptySlave, err := pty.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to allocate PTY: %w", err)
        }</span>

        // Set window size using creack/pty
        <span class="cov8" title="1">if err := pty.Setsize(ptyMaster, &amp;pty.Winsize{
                Rows: windowSize.Height,
                Cols: windowSize.Width,
        }); err != nil </span><span class="cov0" title="0">{
                ptyMaster.Close()
                ptySlave.Close()
                return nil, fmt.Errorf("failed to set window size: %w", err)
        }</span>

        // Create PTY session
        <span class="cov8" title="1">session := &amp;PTYSession{
                SessionID:    sessionID,
                Username:     username,
                GameID:       gameID,
                PTY:          ptyMaster,
                TTY:          ptySlave,
                IsActive:     true,
                WindowSize:   windowSize,
                Environment:  make(map[string]string),
                StartTime:    time.Now(),
                inputBuffer:  make([]byte, 0, 4096),
                outputBuffer: make([]byte, 0, 4096),
                inputChan:    make(chan []byte, 100),
                outputChan:   make(chan []byte, 100),
                doneChan:     make(chan struct{}),
        }

        // Set default environment variables
        session.Environment["TERM"] = "xterm-256color"
        session.Environment["COLUMNS"] = fmt.Sprintf("%d", windowSize.Width)
        session.Environment["LINES"] = fmt.Sprintf("%d", windowSize.Height)
        session.Environment["USER"] = username
        session.Environment["HOME"] = fmt.Sprintf("/tmp/%s", username) // Use /tmp for safety
        session.Environment["SHELL"] = "/bin/bash"

        // Start I/O handling
        go session.handleInput()
        go session.handleOutput()

        // Store session
        pm.sessions[sessionID] = session

        log.Printf("PTY allocated for session %s", sessionID)
        return session, nil</span>
}

// ReleasePTY releases a PTY session
func (pm *PTYManager) ReleasePTY(sessionID string) error <span class="cov8" title="1">{
        pm.sessionsMux.Lock()
        defer pm.sessionsMux.Unlock()

        session, exists := pm.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("PTY session %s not found", sessionID)
        }</span>

        // Close the session
        <span class="cov8" title="1">err := session.Close()

        // Remove from sessions map
        delete(pm.sessions, sessionID)

        log.Printf("PTY released for session %s", sessionID)
        return err</span>
}

// GetPTYSession returns a PTY session by ID
func (pm *PTYManager) GetPTYSession(sessionID string) (*PTYSession, error) <span class="cov0" title="0">{
        pm.sessionsMux.RLock()
        defer pm.sessionsMux.RUnlock()

        session, exists := pm.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PTY session %s not found", sessionID)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// GetActiveSessions returns all active PTY sessions
func (pm *PTYManager) GetActiveSessions() []*PTYSession <span class="cov0" title="0">{
        pm.sessionsMux.RLock()
        defer pm.sessionsMux.RUnlock()

        sessions := make([]*PTYSession, 0, len(pm.sessions))
        for _, session := range pm.sessions </span><span class="cov0" title="0">{
                if session.IsActive </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span>
        }

        <span class="cov0" title="0">return sessions</span>
}

// Shutdown shuts down the PTY manager
func (pm *PTYManager) Shutdown() <span class="cov8" title="1">{
        pm.sessionsMux.Lock()
        defer pm.sessionsMux.Unlock()

        log.Println("Shutting down PTY manager...")

        for sessionID, session := range pm.sessions </span><span class="cov0" title="0">{
                log.Printf("Closing PTY session: %s", sessionID)
                session.Close()
        }</span>

        <span class="cov8" title="1">pm.sessions = make(map[string]*PTYSession)</span>
}

// PTYSession methods

// StartCommand starts a command in the PTY
func (ps *PTYSession) StartCommand(command string, args []string) error <span class="cov0" title="0">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()

        if ps.Command != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("command already running in PTY session %s", ps.SessionID)
        }</span>

        // Create command
        <span class="cov0" title="0">cmd := exec.Command(command, args...)

        // Set up environment
        env := os.Environ()
        for key, value := range ps.Environment </span><span class="cov0" title="0">{
                env = append(env, fmt.Sprintf("%s=%s", key, value))
        }</span>
        <span class="cov0" title="0">cmd.Env = env

        // Set up process group
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setsid:  true,
                Setctty: true,
        }

        // Connect to PTY
        cmd.Stdin = ps.TTY
        cmd.Stdout = ps.TTY
        cmd.Stderr = ps.TTY

        // Start command
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start command: %w", err)
        }</span>

        <span class="cov0" title="0">ps.Command = cmd
        ps.ProcessPID = cmd.Process.Pid

        log.Printf("Command started in PTY session %s: %s (PID: %d)", ps.SessionID, command, ps.ProcessPID)

        // Monitor process
        go ps.monitorProcess()

        return nil</span>
}

// monitorProcess monitors the running process
func (ps *PTYSession) monitorProcess() <span class="cov0" title="0">{
        if ps.Command == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Wait for process to complete
        <span class="cov0" title="0">err := ps.Command.Wait()

        ps.mutex.Lock()
        defer ps.mutex.Unlock()

        if err != nil </span><span class="cov0" title="0">{
                if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        ps.ExitCode = exitError.ExitCode()
                }</span> else<span class="cov0" title="0"> {
                        ps.ExitCode = -1
                }</span>
                <span class="cov0" title="0">log.Printf("Process in PTY session %s exited with error: %v (code: %d)",
                        ps.SessionID, err, ps.ExitCode)</span>
        } else<span class="cov0" title="0"> {
                ps.ExitCode = 0
                log.Printf("Process in PTY session %s completed successfully", ps.SessionID)
        }</span>

        <span class="cov0" title="0">ps.IsActive = false
        if !ps.IsClosed </span><span class="cov0" title="0">{
                ps.IsClosed = true
                close(ps.doneChan)
        }</span>
}

// SendInput sends input to the PTY
func (ps *PTYSession) SendInput(data []byte) error <span class="cov0" title="0">{
        if !ps.IsActive </span><span class="cov0" title="0">{
                return fmt.Errorf("PTY session %s is not active", ps.SessionID)
        }</span>

        // Send to input channel
        <span class="cov0" title="0">select </span>{
        case ps.inputChan &lt;- data:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("input channel full for PTY session %s", ps.SessionID)</span>
        }
}

// ReadOutput reads output from the PTY
func (ps *PTYSession) ReadOutput() ([]byte, error) <span class="cov0" title="0">{
        if !ps.IsActive </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PTY session %s is not active", ps.SessionID)
        }</span>

        <span class="cov0" title="0">select </span>{
        case data := &lt;-ps.outputChan:<span class="cov0" title="0">
                return data, nil</span>
        case &lt;-ps.doneChan:<span class="cov0" title="0">
                return nil, fmt.Errorf("PTY session %s has ended", ps.SessionID)</span>
        case &lt;-time.After(100 * time.Millisecond):<span class="cov0" title="0">
                return nil, nil</span> // Timeout, no data available
        }
}

// handleInput handles input processing
func (ps *PTYSession) handleInput() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case data := &lt;-ps.inputChan:<span class="cov0" title="0">
                        ps.mutex.Lock()
                        ps.inputBuffer = append(ps.inputBuffer, data...)
                        ps.mutex.Unlock()

                        // Write to PTY
                        if _, err := ps.PTY.Write(data); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error writing to PTY %s: %v", ps.SessionID, err)
                                return
                        }</span>

                case &lt;-ps.doneChan:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// handleOutput handles output processing
func (ps *PTYSession) handleOutput() <span class="cov8" title="1">{
        buffer := make([]byte, 4096)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ps.doneChan:<span class="cov8" title="1">
                        return</span>
                default:<span class="cov0" title="0">
                        // Set read timeout
                        _ = ps.PTY.SetReadDeadline(time.Now().Add(100 * time.Millisecond))

                        n, err := ps.PTY.Read(buffer)
                        if err != nil </span><span class="cov0" title="0">{
                                if !isTimeoutError(err) </span><span class="cov0" title="0">{
                                        log.Printf("Error reading from PTY %s: %v", ps.SessionID, err)
                                        return
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                                data := make([]byte, n)
                                copy(data, buffer[:n])

                                ps.mutex.Lock()
                                ps.outputBuffer = append(ps.outputBuffer, data...)
                                // Trim buffer if it gets too large
                                if len(ps.outputBuffer) &gt; 8192 </span><span class="cov0" title="0">{
                                        ps.outputBuffer = ps.outputBuffer[len(ps.outputBuffer)-4096:]
                                }</span>
                                <span class="cov0" title="0">ps.mutex.Unlock()

                                // Send to output channel
                                select </span>{
                                case ps.outputChan &lt;- data:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        // Channel full, drop data
                                        log.Printf("Output channel full for PTY session %s", ps.SessionID)</span>
                                }
                        }
                }
        }
}

// SendSignal sends a signal to the running process
func (ps *PTYSession) SendSignal(sig os.Signal) error <span class="cov0" title="0">{
        ps.mutex.RLock()
        defer ps.mutex.RUnlock()

        if ps.Command == nil || ps.Command.Process == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no active process in PTY session %s", ps.SessionID)
        }</span>

        <span class="cov0" title="0">return ps.Command.Process.Signal(sig)</span>
}

// ResizeWindow resizes the PTY window
func (ps *PTYSession) ResizeWindow(rows, cols uint16) error <span class="cov0" title="0">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()

        ps.WindowSize.Height = rows
        ps.WindowSize.Width = cols
        ps.WindowSize.X = cols
        ps.WindowSize.Y = rows

        // Update environment variables
        ps.Environment["COLUMNS"] = fmt.Sprintf("%d", cols)
        ps.Environment["LINES"] = fmt.Sprintf("%d", rows)

        if ps.PTY == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PTY not available for session %s", ps.SessionID)
        }</span>

        <span class="cov0" title="0">return pty.Setsize(ps.PTY, &amp;pty.Winsize{
                Rows: ps.WindowSize.Height,
                Cols: ps.WindowSize.Width,
        })</span>
}

// SetTerminalAttributes sets terminal attributes for the PTY
func (ps *PTYSession) SetTerminalAttributes() error <span class="cov0" title="0">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()

        if ps.TTY == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("TTY not available for session %s", ps.SessionID)
        }</span>

        // For now, just return success - terminal attributes are complex on macOS
        // In a production environment, you'd want to implement proper terminal control
        <span class="cov0" title="0">log.Printf("Terminal attributes set for PTY session %s", ps.SessionID)
        return nil</span>
}

// GetProcessInfo returns information about the running process
func (ps *PTYSession) GetProcessInfo() map[string]interface{} <span class="cov0" title="0">{
        ps.mutex.RLock()
        defer ps.mutex.RUnlock()

        info := map[string]interface{}{
                "session_id": ps.SessionID,
                "username":   ps.Username,
                "game_id":    ps.GameID,
                "is_active":  ps.IsActive,
                "start_time": ps.StartTime,
                "window_size": map[string]uint16{
                        "height": ps.WindowSize.Height,
                        "width":  ps.WindowSize.Width,
                },
        }

        if ps.Command != nil &amp;&amp; ps.Command.Process != nil </span><span class="cov0" title="0">{
                info["process_id"] = ps.ProcessPID
                info["exit_code"] = ps.ExitCode
        }</span>

        <span class="cov0" title="0">return info</span>
}

// GetInputHistory returns recent input history
func (ps *PTYSession) GetInputHistory(maxBytes int) []byte <span class="cov0" title="0">{
        ps.mutex.RLock()
        defer ps.mutex.RUnlock()

        if len(ps.inputBuffer) &lt;= maxBytes </span><span class="cov0" title="0">{
                result := make([]byte, len(ps.inputBuffer))
                copy(result, ps.inputBuffer)
                return result
        }</span>

        <span class="cov0" title="0">result := make([]byte, maxBytes)
        copy(result, ps.inputBuffer[len(ps.inputBuffer)-maxBytes:])
        return result</span>
}

// GetOutputHistory returns recent output history
func (ps *PTYSession) GetOutputHistory(maxBytes int) []byte <span class="cov0" title="0">{
        ps.mutex.RLock()
        defer ps.mutex.RUnlock()

        if len(ps.outputBuffer) &lt;= maxBytes </span><span class="cov0" title="0">{
                result := make([]byte, len(ps.outputBuffer))
                copy(result, ps.outputBuffer)
                return result
        }</span>

        <span class="cov0" title="0">result := make([]byte, maxBytes)
        copy(result, ps.outputBuffer[len(ps.outputBuffer)-maxBytes:])
        return result</span>
}

// Close closes the PTY session
func (ps *PTYSession) Close() error <span class="cov8" title="1">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()

        if !ps.IsActive </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">ps.IsActive = false

        // Terminate command if running
        if ps.Command != nil &amp;&amp; ps.Command.Process != nil </span><span class="cov0" title="0">{
                log.Printf("Terminating process %d for PTY session %s", ps.ProcessPID, ps.SessionID)

                // Send SIGTERM first
                _ = ps.Command.Process.Signal(syscall.SIGTERM)

                // Wait for graceful termination
                done := make(chan bool, 1)
                go func() </span><span class="cov0" title="0">{
                        _ = ps.Command.Wait()
                        done &lt;- true
                }</span>()

                <span class="cov0" title="0">select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        log.Printf("Process %d terminated gracefully", ps.ProcessPID)</span>
                case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                        log.Printf("Force killing process %d", ps.ProcessPID)
                        _ = ps.Command.Process.Kill()
                        _ = ps.Command.Wait()</span>
                }
        }

        // Close PTY files
        <span class="cov8" title="1">var err error
        if ps.TTY != nil </span><span class="cov8" title="1">{
                if closeErr := ps.TTY.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                        log.Printf("Error closing TTY for session %s: %v", ps.SessionID, closeErr)
                }</span>
        }
        <span class="cov8" title="1">if ps.PTY != nil </span><span class="cov8" title="1">{
                if closeErr := ps.PTY.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                        log.Printf("Error closing PTY for session %s: %v", ps.SessionID, closeErr)
                }</span>
        }

        // Signal completion
        <span class="cov8" title="1">if !ps.IsClosed </span><span class="cov8" title="1">{
                ps.IsClosed = true
                close(ps.doneChan)
        }</span>

        <span class="cov8" title="1">return err</span>
}

// Note: PTY functions now use github.com/creack/pty for cross-platform compatibility

// isTimeoutError checks if an error is a timeout error
func isTimeoutError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for various timeout error types
        <span class="cov0" title="0">if netErr, ok := err.(interface{ Timeout() bool }); ok </span><span class="cov0" title="0">{
                return netErr.Timeout()
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package session

import (
        "crypto/sha256"
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// UserSave represents a user's game save data
type UserSave struct {
        UserID    int       `json:"user_id"`
        Username  string    `json:"username"`
        GameID    string    `json:"game_id"`
        SaveData  []byte    `json:"save_data"`
        SavePath  string    `json:"save_path"`
        SaveHash  string    `json:"save_hash"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        FileSize  int64     `json:"file_size"`
        HasSave   bool      `json:"has_save"`
}

// SaveManager handles save file operations for single save per user
type SaveManager struct {
        baseSaveDir string
}

// NewSaveManager creates a new save manager
func NewSaveManager(baseSaveDir string) *SaveManager <span class="cov0" title="0">{
        return &amp;SaveManager{
                baseSaveDir: baseSaveDir,
        }
}</span>

// GetUserSaveDir returns the save directory for a user
func (sm *SaveManager) GetUserSaveDir(username string) string <span class="cov0" title="0">{
        return filepath.Join(sm.baseSaveDir, "users", username)
}</span>

// GetUserSave retrieves a user's save data for a specific game
func (sm *SaveManager) GetUserSave(username, gameID string) (*UserSave, error) <span class="cov0" title="0">{
        userDir := sm.GetUserSaveDir(username)

        // For NetHack, check the standard save file location
        var savePath string
        var saveData []byte
        var fileSize int64
        var hasSave bool
        var modTime time.Time

        if gameID == "nethack" </span><span class="cov0" title="0">{
                // Check for NetHack save file patterns in multiple locations
                patterns := []string{
                        // Our configured save directory
                        filepath.Join(sm.baseSaveDir, "save", "*"+username+"*"), // e.g., 501caboose.Z
                        filepath.Join(sm.baseSaveDir, "save", "*"+username),     // e.g., 501caboose
                        filepath.Join(sm.baseSaveDir, "save", username+"*"),     // e.g., caboose.nh
                        filepath.Join(sm.baseSaveDir, "save", "*"),              // Check all files in save dir
                        // NetHack system save directory (homebrew)
                        filepath.Join("/opt/homebrew/share/nethack/save", "*"+username+"*"),
                        filepath.Join("/opt/homebrew/share/nethack/save", "*"),
                        // User directories
                        filepath.Join(userDir, username),
                        filepath.Join(userDir, "save"),
                }

                for _, pattern := range patterns </span><span class="cov0" title="0">{
                        matches, err := filepath.Glob(pattern)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">for _, match := range matches </span><span class="cov0" title="0">{
                                if fileInfo, err := os.Stat(match); err == nil &amp;&amp; !fileInfo.IsDir() &amp;&amp; fileInfo.Size() &gt; 0 </span><span class="cov0" title="0">{
                                        // For the wildcard patterns, check if filename contains username
                                        filename := filepath.Base(match)
                                        if strings.HasSuffix(pattern, "*") </span><span class="cov0" title="0">{
                                                if !strings.Contains(strings.ToLower(filename), strings.ToLower(username)) </span><span class="cov0" title="0">{
                                                        continue</span> // Skip files that don't contain username
                                                }
                                        }

                                        <span class="cov0" title="0">savePath = match
                                        fileSize = fileInfo.Size()
                                        modTime = fileInfo.ModTime()
                                        hasSave = true

                                        // Read save data if file is small enough (&lt; 1MB)
                                        if fileSize &lt; 1024*1024 </span><span class="cov0" title="0">{
                                                if data, err := os.ReadFile(match); err == nil </span><span class="cov0" title="0">{
                                                        saveData = data
                                                }</span>
                                        }
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasSave </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        // Calculate save hash if we have data
        <span class="cov0" title="0">var saveHash string
        if len(saveData) &gt; 0 </span><span class="cov0" title="0">{
                hash := sha256.Sum256(saveData)
                saveHash = fmt.Sprintf("%x", hash)[:8] // First 8 characters for display
        }</span> else<span class="cov0" title="0"> if hasSave &amp;&amp; savePath != "" </span><span class="cov0" title="0">{
                // If we didn't read the data but have a file, calculate hash from file
                if data, err := os.ReadFile(savePath); err == nil </span><span class="cov0" title="0">{
                        hash := sha256.Sum256(data)
                        saveHash = fmt.Sprintf("%x", hash)[:8]
                }</span>
        }

        <span class="cov0" title="0">save := &amp;UserSave{
                Username:  username,
                GameID:    gameID,
                SaveData:  saveData,
                SavePath:  savePath,
                SaveHash:  saveHash,
                UpdatedAt: modTime,
                FileSize:  fileSize,
                HasSave:   hasSave,
        }

        if !hasSave </span><span class="cov0" title="0">{
                save.CreatedAt = time.Now()
                save.UpdatedAt = time.Now()
        }</span> else<span class="cov0" title="0"> {
                save.CreatedAt = modTime
        }</span>

        <span class="cov0" title="0">return save, nil</span>
}

// DeleteUserSave removes a user's save data
func (sm *SaveManager) DeleteUserSave(username, gameID string) error <span class="cov0" title="0">{
        save, err := sm.GetUserSave(username, gameID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !save.HasSave </span><span class="cov0" title="0">{
                return nil // Nothing to delete
        }</span>

        // Remove the save file
        <span class="cov0" title="0">if err := os.Remove(save.SavePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete save file: %w", err)
        }</span>

        // Also remove any backup files
        <span class="cov0" title="0">backupPath := save.SavePath + ".bak"
        os.Remove(backupPath) // Ignore errors for backup removal

        return nil</span>
}

// BackupUserSave creates a backup of a user's save
func (sm *SaveManager) BackupUserSave(username, gameID string) error <span class="cov0" title="0">{
        save, err := sm.GetUserSave(username, gameID)
        if err != nil || !save.HasSave </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create backup filename
        <span class="cov0" title="0">backupPath := save.SavePath + ".bak"

        // Copy file
        input, err := os.ReadFile(save.SavePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read save file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(backupPath, input, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PrepareUserSaveEnvironment sets up the save environment for a user's game
func (sm *SaveManager) PrepareUserSaveEnvironment(username, gameID string) (map[string]string, error) <span class="cov0" title="0">{
        userDir := sm.GetUserSaveDir(username)

        // Create user directory if it doesn't exist
        if err := os.MkdirAll(userDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user save directory: %w", err)
        }</span>

        <span class="cov0" title="0">env := map[string]string{
                "HACKDIR":    sm.baseSaveDir,
                "NETHACKDIR": sm.baseSaveDir,
                "HOME":       userDir,
                "USER":       username,
                "LOGNAME":    username,
        }

        if gameID == "nethack" </span><span class="cov0" title="0">{
                // NetHack-specific environment setup
                env["NETHACKOPTIONS"] = "@" + filepath.Join(userDir, ".nethackrc")

                // Create a simple .nethackrc if it doesn't exist
                nethackrc := filepath.Join(userDir, ".nethackrc")
                if _, err := os.Stat(nethackrc); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        rcContent := `# NetHack configuration for ` + username + `
OPTIONS=color,autopickup,pickup_types:$
OPTIONS=!time,showexp,showscore
OPTIONS=hilite_pet,boulder:0
`
                        _ = os.WriteFile(nethackrc, []byte(rcContent), 0644)
                }</span>
        }

        <span class="cov0" title="0">return env, nil</span>
}

// CleanupOldSaves removes old backup files and temporary saves
func (sm *SaveManager) CleanupOldSaves(username, gameID string, maxAge time.Duration) error <span class="cov0" title="0">{
        userDir := sm.GetUserSaveDir(username)

        return filepath.WalkDir(userDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip errors
                }</span>

                <span class="cov0" title="0">if d.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Check if it's a backup file or temporary file
                <span class="cov0" title="0">if filepath.Ext(path) == ".bak" || filepath.Ext(path) == ".tmp" </span><span class="cov0" title="0">{
                        if info, err := d.Info(); err == nil </span><span class="cov0" title="0">{
                                if time.Since(info.ModTime()) &gt; maxAge </span><span class="cov0" title="0">{
                                        os.Remove(path) // Ignore errors
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package session

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/dungeongate/pkg/config"
)

// Service client implementations

// authServiceClient implements AuthServiceClient
type authServiceClient struct {
        address string
}

// NewAuthServiceClient creates a new auth service client
func NewAuthServiceClient(address string) AuthServiceClient <span class="cov8" title="1">{
        return &amp;authServiceClient{
                address: address,
        }
}</span>

func (c *authServiceClient) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) <span class="cov8" title="1">{
        log.Printf("Auth service login request: %s", req.Username)

        // Mock implementation
        switch req.Username </span>{
        case "admin":<span class="cov8" title="1">
                if req.Password == "admin" </span><span class="cov8" title="1">{
                        return &amp;LoginResponse{
                                Success: true,
                                Token:   "mock-token-admin",
                                User: &amp;User{
                                        ID:              1,
                                        Username:        req.Username,
                                        Email:           "admin@example.com",
                                        IsAuthenticated: true,
                                        IsActive:        true,
                                        IsAdmin:         true,
                                        CreatedAt:       time.Now(),
                                        UpdatedAt:       time.Now(),
                                },
                                Message: "Login successful",
                        }, nil
                }</span>
                <span class="cov0" title="0">return &amp;LoginResponse{
                        Success: false,
                        Message: "Invalid password",
                }, nil</span>
        case "user":<span class="cov0" title="0">
                if req.Password == "password" </span><span class="cov0" title="0">{
                        return &amp;LoginResponse{
                                Success: true,
                                Token:   "mock-token-user",
                                User: &amp;User{
                                        ID:              2,
                                        Username:        req.Username,
                                        Email:           "user@example.com",
                                        IsAuthenticated: true,
                                        IsActive:        true,
                                        IsAdmin:         false,
                                        CreatedAt:       time.Now(),
                                        UpdatedAt:       time.Now(),
                                },
                                Message: "Login successful",
                        }, nil
                }</span>
                <span class="cov0" title="0">return &amp;LoginResponse{
                        Success: false,
                        Message: "Invalid password",
                }, nil</span>
        default:<span class="cov0" title="0">
                return &amp;LoginResponse{
                        Success: false,
                        Message: "User not found",
                }, nil</span>
        }
}

func (c *authServiceClient) Logout(ctx context.Context, token string) error <span class="cov0" title="0">{
        log.Printf("Auth service logout request: %s", token)
        return nil
}</span>

func (c *authServiceClient) ValidateToken(ctx context.Context, token string) (*User, error) <span class="cov0" title="0">{
        log.Printf("Auth service validate token request: %s", token)

        // Mock implementation
        switch token </span>{
        case "mock-token-admin":<span class="cov0" title="0">
                return &amp;User{
                        ID:              1,
                        Username:        "admin",
                        Email:           "admin@example.com",
                        IsAuthenticated: true,
                        IsActive:        true,
                        IsAdmin:         true,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                }, nil</span>
        case "mock-token-user":<span class="cov0" title="0">
                return &amp;User{
                        ID:              2,
                        Username:        "user",
                        Email:           "user@example.com",
                        IsAuthenticated: true,
                        IsActive:        true,
                        IsAdmin:         false,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                }, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid token")</span>
        }
}

func (c *authServiceClient) RefreshToken(ctx context.Context, refreshToken string) (*LoginResponse, error) <span class="cov0" title="0">{
        log.Printf("Auth service refresh token request: %s", refreshToken)
        return nil, fmt.Errorf("not implemented")
}</span>

// userServiceClient implements UserServiceClient
type userServiceClient struct {
        address string
}

// NewUserServiceClient creates a new user service client
func NewUserServiceClient(address string) UserServiceClient <span class="cov8" title="1">{
        return &amp;userServiceClient{
                address: address,
        }
}</span>

func (c *userServiceClient) GetUser(ctx context.Context, username string) (*User, error) <span class="cov8" title="1">{
        log.Printf("User service get user request: %s", username)

        // Mock implementation
        switch username </span>{
        case "admin":<span class="cov8" title="1">
                return &amp;User{
                        ID:              1,
                        Username:        username,
                        Email:           "admin@example.com",
                        IsAuthenticated: false,
                        IsActive:        true,
                        IsAdmin:         true,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                }, nil</span>
        case "user":<span class="cov0" title="0">
                return &amp;User{
                        ID:              2,
                        Username:        username,
                        Email:           "user@example.com",
                        IsAuthenticated: false,
                        IsActive:        true,
                        IsAdmin:         false,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                }, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("user not found")</span>
        }
}

func (c *userServiceClient) GetUserByUsername(ctx context.Context, username string) (*User, error) <span class="cov0" title="0">{
        log.Printf("User service get user by username request: %s", username)

        // Mock implementation
        switch username </span>{
        case "admin":<span class="cov0" title="0">
                return &amp;User{
                        ID:              1,
                        Username:        username,
                        Email:           "admin@example.com",
                        IsAuthenticated: false,
                        IsActive:        true,
                        IsAdmin:         true,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                }, nil</span>
        case "user":<span class="cov0" title="0">
                return &amp;User{
                        ID:              2,
                        Username:        username,
                        Email:           "user@example.com",
                        IsAuthenticated: false,
                        IsActive:        true,
                        IsAdmin:         false,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                }, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("user not found")</span>
        }
}

func (c *userServiceClient) RegisterUser(ctx context.Context, req *RegistrationRequest) (*RegistrationResponse, error) <span class="cov0" title="0">{
        log.Printf("User service register user request: %s", req.Username)

        // Mock implementation - in real implementation would validate and create user
        return &amp;RegistrationResponse{
                Success: true,
                User: &amp;User{
                        ID:              int(time.Now().Unix()),
                        Username:        req.Username,
                        Email:           req.Email,
                        IsAuthenticated: false,
                        IsActive:        true,
                        IsAdmin:         false,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                },
                Message:              "Registration successful",
                RequiresVerification: false,
        }, nil
}</span>

func (c *userServiceClient) GetUserByID(ctx context.Context, userID int) (*User, error) <span class="cov0" title="0">{
        log.Printf("User service get user by ID request: %d", userID)
        return nil, fmt.Errorf("not implemented")
}</span>

func (c *userServiceClient) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) <span class="cov0" title="0">{
        log.Printf("User service create user request: %s", req.Username)

        // Mock implementation - in real implementation would validate and create user
        return &amp;User{
                ID:              int(time.Now().Unix()),
                Username:        req.Username,
                Email:           req.Email,
                IsAuthenticated: false,
                IsActive:        true,
                IsAdmin:         false,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }, nil
}</span>

func (c *userServiceClient) UpdateUser(ctx context.Context, userID int, updates map[string]interface{}) (*User, error) <span class="cov0" title="0">{
        log.Printf("User service update user request: %d", userID)
        return nil, fmt.Errorf("not implemented")
}</span>

func (c *userServiceClient) DeleteUser(ctx context.Context, userID int) error <span class="cov0" title="0">{
        log.Printf("User service delete user request: %d", userID)
        return fmt.Errorf("not implemented")
}</span>

func (c *userServiceClient) ListUsers(ctx context.Context, limit, offset int) ([]*User, error) <span class="cov0" title="0">{
        log.Printf("User service list users request: limit=%d, offset=%d", limit, offset)
        return nil, fmt.Errorf("not implemented")
}</span>

func (c *userServiceClient) UpdateLastLogin(ctx context.Context, userID int) error <span class="cov0" title="0">{
        log.Printf("User service update last login request: %d", userID)
        return nil
}</span>

// gameServiceClient implements GameServiceClient
type gameServiceClient struct {
        address string
        games   []*config.GameConfig
}

// NewGameServiceClient creates a new game service client
func NewGameServiceClient(address string) GameServiceClient <span class="cov8" title="1">{
        return &amp;gameServiceClient{
                address: address,
        }
}</span>

// NewGameServiceClientWithConfig creates a new game service client with configuration
func NewGameServiceClientWithConfig(address string, games []*config.GameConfig) GameServiceClient <span class="cov0" title="0">{
        return &amp;gameServiceClient{
                address: address,
                games:   games,
        }
}</span>

func (c *gameServiceClient) ListGames(ctx context.Context) ([]*Game, error) <span class="cov8" title="1">{
        log.Printf("Game service list games request")

        // If games are configured, use them
        if len(c.games) &gt; 0 </span><span class="cov0" title="0">{
                games := make([]*Game, 0, len(c.games))
                for _, cfg := range c.games </span><span class="cov0" title="0">{
                        if cfg.Enabled </span><span class="cov0" title="0">{
                                game := &amp;Game{
                                        ID:          cfg.ID,
                                        Name:        cfg.Name,
                                        ShortName:   cfg.ShortName,
                                        Description: fmt.Sprintf("v%s", cfg.Version),
                                        Enabled:     cfg.Enabled,
                                        Binary:      cfg.Binary.Path,
                                        Args:        cfg.Binary.Args,
                                        WorkingDir:  cfg.Binary.WorkingDirectory,
                                        Environment: cfg.Environment,
                                        MaxPlayers:  1,
                                        Spectatable: true,
                                        CreatedAt:   time.Now(),
                                        UpdatedAt:   time.Now(),
                                }

                                // Use game settings if available
                                if cfg.Settings != nil </span><span class="cov0" title="0">{
                                        game.MaxPlayers = cfg.Settings.MaxPlayers
                                        if cfg.Settings.Spectating != nil </span><span class="cov0" title="0">{
                                                game.Spectatable = cfg.Settings.Spectating.Enabled
                                        }</span>
                                }

                                <span class="cov0" title="0">games = append(games, game)</span>
                        }
                }
                <span class="cov0" title="0">return games, nil</span>
        }

        // Fallback to mock implementation - return NetHack game
        <span class="cov8" title="1">return []*Game{
                {
                        ID:          "nethack",
                        Name:        "NetHack",
                        ShortName:   "NH",
                        Description: "The classic roguelike dungeon crawler",
                        Enabled:     true,
                        Binary:      "/opt/homebrew/bin/nethack",
                        Args:        []string{"-u"},
                        WorkingDir:  "/tmp/nethack-saves",
                        Environment: map[string]string{
                                "TERM":       "xterm-256color",
                                "HACKDIR":    "/tmp/nethack-saves",
                                "NETHACKDIR": "/tmp/nethack-saves",
                                "HOME":       "/tmp/nethack-saves",
                        },
                        MaxPlayers:  1,
                        Spectatable: true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
        }, nil</span>
}

func (c *gameServiceClient) GetGame(ctx context.Context, gameID string) (*Game, error) <span class="cov0" title="0">{
        log.Printf("Game service get game request: %s", gameID)

        // Get games and find the requested one
        games, err := c.ListGames(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, game := range games </span><span class="cov0" title="0">{
                if game.ID == gameID </span><span class="cov0" title="0">{
                        return game, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("game not found: %s", gameID)</span>
}

func (c *gameServiceClient) StartGame(ctx context.Context, req *StartGameRequest) (*GameSession, error) <span class="cov0" title="0">{
        log.Printf("Game service start game request: user=%s, game=%s", req.Username, req.GameID)

        // Mock implementation
        return &amp;GameSession{
                ID:       fmt.Sprintf("game_%d", time.Now().UnixNano()),
                UserID:   req.UserID,
                Username: req.Username,
                GameID:   req.GameID,
                Status:   "starting",
        }, nil
}</span>

func (c *gameServiceClient) StopGame(ctx context.Context, sessionID string) error <span class="cov0" title="0">{
        log.Printf("Game service stop game request: %s", sessionID)
        return nil
}</span>

func (c *gameServiceClient) GetGameStatus(ctx context.Context, sessionID string) (*GameSession, error) <span class="cov0" title="0">{
        log.Printf("Game service get game status request: %s", sessionID)
        return nil, fmt.Errorf("not implemented")
}</span>

func (c *gameServiceClient) UpdateGameConfig(ctx context.Context, gameID string, config *Game) error <span class="cov0" title="0">{
        log.Printf("Game service update game config request: %s", gameID)
        return fmt.Errorf("not implemented")
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package session

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "sync"
        "sync/atomic"
        "time"

        "github.com/dungeongate/internal/user"
        "github.com/dungeongate/pkg/config"
        "github.com/dungeongate/pkg/database"
        "github.com/dungeongate/pkg/encryption"
        "github.com/dungeongate/pkg/ttyrec"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Service handles session management operations
type Service struct {
        db             *database.Connection
        encryptor      *encryption.Encryptor
        recorder       *ttyrec.Recorder
        config         *config.SessionServiceConfig
        userService    *user.Service
        authMiddleware *AuthMiddleware

        // Session tracking using immutable data patterns
        sessions    map[string]*Session
        sessionsMux sync.RWMutex
}

// NewService creates a new session service
func NewService(db *database.Connection, encryptor *encryption.Encryptor, recorder *ttyrec.Recorder, cfg *config.SessionServiceConfig, userService *user.Service) *Service <span class="cov0" title="0">{
        return &amp;Service{
                db:          db,
                encryptor:   encryptor,
                recorder:    recorder,
                config:      cfg,
                userService: userService,
                sessions:    make(map[string]*Session),
        }
}</span>

// NewServiceWithAuth creates a new session service with authentication middleware
func NewServiceWithAuth(db *database.Connection, encryptor *encryption.Encryptor, recorder *ttyrec.Recorder, cfg *config.SessionServiceConfig, userService *user.Service, authMiddleware *AuthMiddleware) *Service <span class="cov0" title="0">{
        return &amp;Service{
                db:             db,
                encryptor:      encryptor,
                recorder:       recorder,
                config:         cfg,
                userService:    userService,
                authMiddleware: authMiddleware,
                sessions:       make(map[string]*Session),
        }
}</span>

// CreateSession creates a new terminal session
func (s *Service) CreateSession(ctx context.Context, req *CreateSessionRequest) (*Session, error) <span class="cov0" title="0">{
        sessionID := generateSessionID()

        // Initialize immutable spectator registry
        registry := &amp;atomic.Pointer[SpectatorRegistry]{}
        registry.Store(NewSpectatorRegistry())

        // Initialize stream manager
        streamManager := NewStreamManager()

        session := &amp;Session{
                ID:            sessionID,
                UserID:        req.UserID,
                Username:      req.Username,
                GameID:        req.GameID,
                StartTime:     time.Now(),
                IsActive:      true,
                TerminalSize:  req.TerminalSize,
                Encoding:      req.Encoding,
                LastActivity:  time.Now(),
                StreamEnabled: true, // Always enable streaming for spectators
                Encrypted:     s.config.Encryption.Enabled,
                Spectators:    make([]*Spectator, 0), // Legacy field for JSON serialization
                Registry:      registry,              // Immutable spectator registry
                StreamManager: streamManager,         // Stream manager for broadcasting
        }

        // Start TTY recording if enabled
        if s.config.SessionManagement.TTYRec.Enabled </span><span class="cov0" title="0">{
                recording, err := s.recorder.StartRecording(sessionID, req.Username, req.GameID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to start TTY recording: %w", err)
                }</span>
                <span class="cov0" title="0">session.TTYRecording = recording</span>
        }

        // Start stream manager for spectating
        <span class="cov0" title="0">streamManager.Start(registry)

        // Store session in service registry
        s.sessionsMux.Lock()
        s.sessions[sessionID] = session
        s.sessionsMux.Unlock()

        log.Printf("Created session %s for user %s playing %s", sessionID, req.Username, req.GameID)
        log.Printf("Total active sessions: %d", len(s.sessions))

        // TODO: Store session in database
        // TODO: Set up session monitoring
        // TODO: Initialize encrypted stream if enabled

        return session, nil</span>
}

// EndSession ends a terminal session
func (s *Service) EndSession(ctx context.Context, sessionID string) error <span class="cov0" title="0">{
        // TODO: Implement session ending logic

        // Stop TTY recording
        // Update database
        // Clean up resources

        return fmt.Errorf("session ending not implemented")
}</span>

// GetSession retrieves a session by ID
func (s *Service) GetSession(ctx context.Context, sessionID string) (*Session, error) <span class="cov0" title="0">{
        // TODO: Implement session retrieval from database
        return nil, fmt.Errorf("session retrieval not implemented")
}</span>

// GetActiveSessions returns all active sessions
func (s *Service) GetActiveSessions(ctx context.Context) ([]*Session, error) <span class="cov0" title="0">{
        s.sessionsMux.RLock()
        defer s.sessionsMux.RUnlock()

        log.Printf("GetActiveSessions: Total sessions in registry: %d", len(s.sessions))
        var activeSessions []*Session

        // Iterate through all sessions and collect active ones
        for _, session := range s.sessions </span><span class="cov0" title="0">{
                if session.IsActive </span><span class="cov0" title="0">{
                        // Create a copy to avoid race conditions
                        sessionCopy := *session

                        // Update spectator count from registry if available
                        if session.Registry != nil </span><span class="cov0" title="0">{
                                currentRegistry := session.Registry.Load()
                                if currentRegistry != nil </span><span class="cov0" title="0">{
                                        sessionCopy.Spectators = currentRegistry.GetSpectators()
                                }</span>
                        }

                        <span class="cov0" title="0">activeSessions = append(activeSessions, &amp;sessionCopy)</span>
                }
        }

        // If no real sessions exist, create some test sessions for testing watch functionality
        <span class="cov0" title="0">if len(activeSessions) == 0 </span><span class="cov0" title="0">{
                log.Printf("No real sessions found, creating test sessions for demonstration")
                activeSessions = s.createTestSessions()
        }</span>

        <span class="cov0" title="0">log.Printf("Found %d active sessions", len(activeSessions))
        return activeSessions, nil</span>
}

// createTestSessions creates some test sessions for demonstration purposes
func (s *Service) createTestSessions() []*Session <span class="cov0" title="0">{
        testSessions := []*Session{
                {
                        ID:           "test_session_1",
                        UserID:       1,
                        Username:     "player1",
                        GameID:       "nethack",
                        StartTime:    time.Now().Add(-30 * time.Minute),
                        IsActive:     true,
                        TerminalSize: "80x24",
                        Encoding:     "utf-8",
                        LastActivity: time.Now().Add(-5 * time.Minute),
                        Spectators:   []*Spectator{},
                },
                {
                        ID:           "test_session_2",
                        UserID:       2,
                        Username:     "player2",
                        GameID:       "dcss",
                        StartTime:    time.Now().Add(-15 * time.Minute),
                        IsActive:     true,
                        TerminalSize: "120x40",
                        Encoding:     "utf-8",
                        LastActivity: time.Now().Add(-2 * time.Minute),
                        Spectators: []*Spectator{
                                {
                                        UserID:   3,
                                        Username: "spectator1",
                                        JoinTime: time.Now().Add(-10 * time.Minute),
                                },
                        },
                },
        }

        // Add these test sessions to the service registry for spectating to work
        s.sessionsMux.Lock()
        for _, session := range testSessions </span><span class="cov0" title="0">{
                // Initialize immutable spectator registry for test sessions
                registry := &amp;atomic.Pointer[SpectatorRegistry]{}
                registry.Store(NewSpectatorRegistry())
                session.Registry = registry

                // Initialize stream manager
                session.StreamManager = NewStreamManager()
                session.StreamManager.Start(registry)

                s.sessions[session.ID] = session
        }</span>
        <span class="cov0" title="0">s.sessionsMux.Unlock()

        return testSessions</span>
}

// AddSpectator adds a spectator to a session using immutable data sharing
func (s *Service) AddSpectator(ctx context.Context, sessionID string, userID int, username string) error <span class="cov0" title="0">{
        // Check if spectating is enabled
        if !s.config.SessionManagement.Spectating.Enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("spectating is not enabled")
        }</span>

        // Find the session
        <span class="cov0" title="0">s.sessionsMux.RLock()
        session, exists := s.sessions[sessionID]
        s.sessionsMux.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("session %s not found", sessionID)
        }</span>

        <span class="cov0" title="0">if !session.IsActive </span><span class="cov0" title="0">{
                return fmt.Errorf("session %s is not active", sessionID)
        }</span>

        // Check max spectators limit
        <span class="cov0" title="0">currentRegistry := session.Registry.Load()
        if len(currentRegistry.Spectators) &gt;= s.config.SessionManagement.Spectating.MaxSpectatorsPerSession </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum spectators (%d) reached for session %s",
                        s.config.SessionManagement.Spectating.MaxSpectatorsPerSession, sessionID)
        }</span>

        // TODO: This is a placeholder - in real implementation, the connection would be provided
        // For now, we'll create a mock connection for testing
        <span class="cov0" title="0">log.Printf("Adding spectator %s (ID: %d) to session %s", username, userID, sessionID)

        return nil</span>
}

// AddSpectatorWithConnection adds a spectator to a session with a specific connection
func (s *Service) AddSpectatorWithConnection(ctx context.Context, sessionID string, userID int, username string, connection SpectatorConnection) error <span class="cov0" title="0">{
        // Check if spectating is enabled
        if !s.config.SessionManagement.Spectating.Enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("spectating is not enabled")
        }</span>

        // Find the session
        <span class="cov0" title="0">s.sessionsMux.RLock()
        session, exists := s.sessions[sessionID]
        s.sessionsMux.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("session %s not found", sessionID)
        }</span>

        <span class="cov0" title="0">if !session.IsActive </span><span class="cov0" title="0">{
                return fmt.Errorf("session %s is not active", sessionID)
        }</span>

        // Check max spectators limit
        <span class="cov0" title="0">currentRegistry := session.Registry.Load()
        if len(currentRegistry.Spectators) &gt;= s.config.SessionManagement.Spectating.MaxSpectatorsPerSession </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum spectators (%d) reached for session %s",
                        s.config.SessionManagement.Spectating.MaxSpectatorsPerSession, sessionID)
        }</span>

        // Create new spectator
        <span class="cov0" title="0">spectator := &amp;Spectator{
                UserID:     userID,
                Username:   username,
                JoinTime:   time.Now(),
                Connection: connection,
                BytesSent:  0,
                IsActive:   true,
        }

        // Atomically update spectator registry (immutable pattern)
        const maxRetries = 10
        for retry := 0; retry &lt; maxRetries; retry++ </span><span class="cov0" title="0">{
                oldRegistry := session.Registry.Load()
                newRegistry := oldRegistry.AddSpectator(spectator)

                // Try to swap the registry atomically
                if session.Registry.CompareAndSwap(oldRegistry, newRegistry) </span><span class="cov0" title="0">{
                        log.Printf("Successfully added spectator %s to session %s (registry version %d)",
                                username, sessionID, newRegistry.Version)

                        // Update legacy field for JSON serialization
                        session.Spectators = newRegistry.GetSpectators()

                        // Send recent frames to the new spectator
                        if session.StreamManager != nil </span><span class="cov0" title="0">{
                                recentFrames := session.StreamManager.GetRecentFrames()
                                if len(recentFrames) &gt; 0 </span><span class="cov0" title="0">{
                                        log.Printf("Sending %d recent frames to new spectator %s", len(recentFrames), username)
                                        go func() </span><span class="cov0" title="0">{
                                                // Small delay to ensure spectator is ready
                                                time.Sleep(100 * time.Millisecond)

                                                // Send each frame with a small delay to avoid overwhelming
                                                for i, frame := range recentFrames </span><span class="cov0" title="0">{
                                                        if spectator.Connection != nil &amp;&amp; spectator.Connection.IsConnected() </span><span class="cov0" title="0">{
                                                                if err := spectator.Connection.Write(frame); err != nil </span><span class="cov0" title="0">{
                                                                        log.Printf("Failed to send historical frame %d to spectator %s: %v", i, username, err)
                                                                        break</span>
                                                                }
                                                                // Small delay between frames to ensure proper rendering
                                                                <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
                                                        }
                                                }
                                                <span class="cov0" title="0">log.Printf("Finished sending historical frames to spectator %s", username)</span>
                                        }()
                                }
                        }

                        <span class="cov0" title="0">return nil</span>
                }
                // If swap failed, another goroutine updated the registry, retry with exponential backoff
                <span class="cov0" title="0">if retry &lt; maxRetries-1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(1&lt;&lt;uint(retry)) * time.Millisecond)
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to add spectator after %d retries due to high contention", maxRetries)</span>
}

// RemoveSpectator removes a spectator from a session using immutable data sharing
func (s *Service) RemoveSpectator(ctx context.Context, sessionID string, userID int) error <span class="cov0" title="0">{
        // Find the session
        s.sessionsMux.RLock()
        session, exists := s.sessions[sessionID]
        s.sessionsMux.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("session %s not found", sessionID)
        }</span>

        // Get current registry to find the spectator
        <span class="cov0" title="0">currentRegistry := session.Registry.Load()
        var targetUsername string
        spectatorID := ""

        // Find the spectator to get their username
        for id, spectator := range currentRegistry.Spectators </span><span class="cov0" title="0">{
                if spectator.UserID == userID </span><span class="cov0" title="0">{
                        targetUsername = spectator.Username
                        spectatorID = id
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetUsername == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("spectator with userID %d not found in session %s", userID, sessionID)
        }</span>

        // Close the spectator connection before removing
        <span class="cov0" title="0">if spectator, exists := currentRegistry.Spectators[spectatorID]; exists </span><span class="cov0" title="0">{
                if spectator.Connection != nil </span><span class="cov0" title="0">{
                        spectator.Connection.Close()
                }</span>
        }

        // Atomically update spectator registry (immutable pattern)
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                oldRegistry := session.Registry.Load()
                newRegistry := oldRegistry.RemoveSpectator(userID, targetUsername)

                // Try to swap the registry atomically
                if session.Registry.CompareAndSwap(oldRegistry, newRegistry) </span><span class="cov0" title="0">{
                        log.Printf("Successfully removed spectator %s (ID: %d) from session %s (registry version %d)",
                                targetUsername, userID, sessionID, newRegistry.Version)

                        // Update legacy field for JSON serialization
                        session.Spectators = newRegistry.GetSpectators()

                        return nil
                }</span>
                // If swap failed, another goroutine updated the registry, retry
        }
}

// WriteToSession writes data to a session and broadcasts it to spectators using immutable frames
func (s *Service) WriteToSession(ctx context.Context, sessionID string, data []byte) error <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Find the session
        <span class="cov0" title="0">s.sessionsMux.RLock()
        session, exists := s.sessions[sessionID]
        s.sessionsMux.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("session %s not found", sessionID)
        }</span>

        <span class="cov0" title="0">if !session.IsActive </span><span class="cov0" title="0">{
                return fmt.Errorf("session %s is not active", sessionID)
        }</span>

        // Update last activity
        <span class="cov0" title="0">session.LastActivity = time.Now()

        // Encrypt data if encryption is enabled
        dataToStream := data
        if s.config.Encryption.Enabled &amp;&amp; s.encryptor != nil </span><span class="cov0" title="0">{
                encryptedData, err := s.encryptor.Encrypt(data)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encrypt session data: %w", err)
                }</span>
                <span class="cov0" title="0">dataToStream = encryptedData</span>
        }

        // Record data if TTY recording is enabled
        <span class="cov0" title="0">if session.TTYRecording != nil </span><span class="cov0" title="0">{
                // TODO: Implement actual TTY recording when ttyrec package is complete
                log.Printf("TTY recording for session %s: %d bytes", sessionID, len(dataToStream))
        }</span>

        // Broadcast to spectators using immutable stream frames
        <span class="cov0" title="0">if session.StreamManager != nil &amp;&amp; session.StreamEnabled </span><span class="cov0" title="0">{
                session.StreamManager.SendFrame(dataToStream)
                // Debug logging for spectator broadcasting
                if currentRegistry := session.Registry.Load(); currentRegistry != nil </span><span class="cov0" title="0">{
                        spectatorCount := len(currentRegistry.GetSpectators())
                        if spectatorCount &gt; 0 </span><span class="cov0" title="0">{
                                log.Printf("Broadcasting %d bytes to %d spectators for session %s", len(dataToStream), spectatorCount, sessionID)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// WriteToSessionEnhanced writes data to a session with enhanced features
func (s *Service) WriteToSessionEnhanced(ctx context.Context, sessionID string, data []byte) error <span class="cov0" title="0">{
        // This would implement TTY recording, spectator broadcasting, etc.
        // For now, it's a placeholder
        fmt.Printf("Writing %d bytes to session %s", len(data), sessionID)
        return nil
}</span>

// GetSessionPlayback retrieves session playback data
func (s *Service) GetSessionPlayback(ctx context.Context, sessionID string) ([]byte, error) <span class="cov0" title="0">{
        // TODO: Implement session playback retrieval
        return nil, fmt.Errorf("session playback not implemented")
}</span>

// CleanupInactiveSessions removes inactive sessions
func (s *Service) CleanupInactiveSessions(ctx context.Context) error <span class="cov0" title="0">{
        // TODO: Implement session cleanup logic

        // Find sessions that have exceeded timeout
        // End sessions gracefully
        // Clean up resources

        return fmt.Errorf("session cleanup not implemented")
}</span>

// MonitorSessions monitors session activity and health
func (s *Service) MonitorSessions(ctx context.Context) error <span class="cov0" title="0">{
        // TODO: Implement session monitoring

        // Check session health
        // Monitor resource usage
        // Send alerts if needed

        return fmt.Errorf("session monitoring not implemented")
}</span>

// GetMetrics returns service metrics
func (s *Service) GetMetrics() *ServiceMetrics <span class="cov0" title="0">{
        return &amp;ServiceMetrics{
                ActiveSessions:   2,
                TotalSessions:    10,
                ActiveSpectators: 1,
                TotalSpectators:  5,
                BytesTransferred: 1024 * 1024,
                UptimeSeconds:    3600,
        }
}</span>

// Additional service methods for enhanced functionality

// GetSessionsByUser returns sessions for a specific user
func (s *Service) GetSessionsByUser(ctx context.Context, userID int) ([]*Session, error) <span class="cov0" title="0">{
        // Mock implementation
        return []*Session{}, nil
}</span>

// GetSessionsByGame returns sessions for a specific game
func (s *Service) GetSessionsByGame(ctx context.Context, gameID string) ([]*Session, error) <span class="cov0" title="0">{
        // Mock implementation
        return []*Session{}, nil
}</span>

// GetUserStatistics returns statistics for a user
func (s *Service) GetUserStatistics(ctx context.Context, userID int) (*UserStatistics, error) <span class="cov0" title="0">{
        // Mock implementation
        return &amp;UserStatistics{}, nil
}</span>

// GetGameStatistics returns statistics for a game
func (s *Service) GetGameStatistics(ctx context.Context, gameID string) (*GameStatistics, error) <span class="cov0" title="0">{
        // Mock implementation
        return &amp;GameStatistics{}, nil
}</span>

// GetSystemStatistics returns system-wide statistics
func (s *Service) GetSystemStatistics(ctx context.Context) (*SessionStatistics, error) <span class="cov0" title="0">{
        // Mock implementation
        return &amp;SessionStatistics{}, nil
}</span>

// generateSessionID generates a unique session ID
func generateSessionID() string <span class="cov0" title="0">{
        // TODO: Implement proper session ID generation
        return fmt.Sprintf("session_%d", time.Now().UnixNano())
}</span>

// NewHTTPHandler creates a new HTTP handler for the session service
func NewHTTPHandler(service *Service) http.Handler <span class="cov0" title="0">{
        mux := http.NewServeMux()

        mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write([]byte("OK"))
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/sessions", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // TODO: Implement session endpoints
                w.WriteHeader(http.StatusNotImplemented)
                _, _ = w.Write([]byte("Session endpoints not implemented"))
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/spectate", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // TODO: Implement spectator endpoints
                w.WriteHeader(http.StatusNotImplemented)
                _, _ = w.Write([]byte("Spectator endpoints not implemented"))
        }</span>)

        // WebSocket endpoint for browser spectating (stubbed)
        <span class="cov0" title="0">mux.HandleFunc("/ws/spectate", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // TODO: Implement WebSocket upgrade and spectating
                // This will be implemented when WebSocket support is added
                sessionID := r.URL.Query().Get("session")
                if sessionID == "" </span><span class="cov0" title="0">{
                        http.Error(w, "session ID required", http.StatusBadRequest)
                        return
                }</span>

                // For now, return a placeholder response
                <span class="cov0" title="0">w.WriteHeader(http.StatusNotImplemented)
                _, _ = w.Write([]byte("WebSocket spectating not yet implemented"))
                log.Printf("WebSocket spectate request for session %s (not implemented)", sessionID)</span>
        })

        <span class="cov0" title="0">mux.HandleFunc("/playback", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // TODO: Implement playback endpoints
                w.WriteHeader(http.StatusNotImplemented)
                _, _ = w.Write([]byte("Playback endpoints not implemented"))
        }</span>)

        // Prometheus metrics endpoint
        <span class="cov0" title="0">mux.Handle("/metrics", promhttp.Handler())

        return mux</span>
}

// RegisterSessionServiceServer registers the gRPC service
func RegisterSessionServiceServer(server interface{}, service *Service) {<span class="cov0" title="0">
        // TODO: Implement gRPC service registration
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package session

import (
        "context"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "io"
        "log"
        rand2 "math/rand"
        "net"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/dungeongate/internal/user"
        "github.com/dungeongate/pkg/config"
        "github.com/dungeongate/pkg/metrics"
        "golang.org/x/crypto/ssh"
)

// WindowSize represents terminal window dimensions
type WindowSize struct {
        Width  uint16
        Height uint16
        X      uint16
        Y      uint16
}

// SSHServer represents the SSH server
type SSHServer struct {
        config         *config.SessionServiceConfig
        sshConfig      *ssh.ServerConfig
        sessionService *Service
        ptyManager     *PTYManager

        // Service clients
        authClient AuthServiceClient
        userClient UserServiceClient
        gameClient GameServiceClient

        // Connection tracking
        connections    map[string]*SSHConnection
        connectionsMux sync.RWMutex

        // Metrics
        metrics     *SSHMetrics
        promMetrics *metrics.SSHMetrics
}

// SSHConnection represents an active SSH connection
type SSHConnection struct {
        ID           string
        Username     string
        RemoteAddr   string
        StartTime    time.Time
        LastActivity time.Time
        Sessions     map[string]*SSHSessionContext
        sessionsMux  sync.RWMutex
}

// SSHSessionContext represents an SSH session context
type SSHSessionContext struct {
        SessionID    string
        ConnectionID string
        Username     string
        Channel      ssh.Channel
        Requests     &lt;-chan *ssh.Request

        // Terminal state
        TerminalType string
        WindowSize   *WindowSize
        HasPTY       bool

        // Authentication state
        IsAuthenticated   bool
        AuthenticatedUser *User

        // Session state
        Command     string
        Environment map[string]string
        ExitStatus  int

        // Control channels
        done       chan struct{}
        ptySession *PTYSession

        // Metrics
        BytesRead    int64
        BytesWritten int64
        StartTime    time.Time
        LastActivity time.Time
}

// SSHMetrics tracks SSH server metrics
type SSHMetrics struct {
        mutex             sync.RWMutex
        TotalConnections  int64
        ActiveConnections int64
        FailedConnections int64
        TotalSessions     int64
        ActiveSessions    int64
        BytesTransferred  int64
}

// NewSSHServer creates a new SSH server instance
func NewSSHServer(sessionService *Service, cfg *config.SessionServiceConfig) (*SSHServer, error) <span class="cov8" title="1">{
        server := &amp;SSHServer{
                config:         cfg,
                sessionService: sessionService,
                connections:    make(map[string]*SSHConnection),
                metrics:        &amp;SSHMetrics{},
        }

        // Only initialize Prometheus metrics if not in test mode
        // In test mode, the metrics will be nil to avoid registration conflicts
        if cfg != nil &amp;&amp; cfg.Logging != nil &amp;&amp; cfg.Logging.Level != "test" </span><span class="cov0" title="0">{
                server.promMetrics = metrics.NewSSHMetrics("dungeongate", "ssh")
        }</span>

        // Initialize PTY manager
        <span class="cov8" title="1">ptyManager, err := NewPTYManager()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize PTY manager: %w", err)
        }</span>
        <span class="cov8" title="1">server.ptyManager = ptyManager

        // Configure SSH server
        if err := server.configureSSH(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to configure SSH server: %w", err)
        }</span>

        // Initialize service clients
        <span class="cov8" title="1">server.initializeClients()

        return server, nil</span>
}

// updatePromMetrics safely updates Prometheus metrics if they're initialized
func (s *SSHServer) updatePromMetrics(fn func(*metrics.SSHMetrics)) <span class="cov0" title="0">{
        if s.promMetrics != nil </span><span class="cov0" title="0">{
                fn(s.promMetrics)
        }</span>
}

// configureSSH sets up SSH server configuration
func (s *SSHServer) configureSSH() error <span class="cov8" title="1">{
        sshConfig := &amp;ssh.ServerConfig{
                BannerCallback: s.handleBanner,
                ServerVersion:  "SSH-2.0-dungeongate",
                MaxAuthTries:   3,
        }

        // Configure authentication methods based on settings
        sshAuthConfig := s.config.GetSSH().Auth

        if sshAuthConfig.AllowAnonymous </span><span class="cov8" title="1">{
                // For anonymous access, use NoClientAuth to skip all authentication
                sshConfig.NoClientAuth = true
        }</span> else<span class="cov0" title="0"> {
                // Only set authentication callbacks when not allowing anonymous access
                if sshAuthConfig.PasswordAuth </span><span class="cov0" title="0">{
                        sshConfig.PasswordCallback = s.handlePasswordAuth
                }</span>
                <span class="cov0" title="0">if sshAuthConfig.PublicKeyAuth </span><span class="cov0" title="0">{
                        sshConfig.PublicKeyCallback = s.handlePublicKeyAuth
                }</span>
        }

        // Load or generate host key
        <span class="cov8" title="1">hostKey, err := s.loadOrGenerateHostKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load host key: %w", err)
        }</span>

        <span class="cov8" title="1">sshConfig.AddHostKey(hostKey)
        s.sshConfig = sshConfig

        return nil</span>
}

// initializeClients initializes service clients
func (s *SSHServer) initializeClients() <span class="cov8" title="1">{
        // Set default services addresses if not configured
        authServiceAddr := "localhost:9090"
        userServiceAddr := "localhost:9091"
        gameServiceAddr := "localhost:9092"

        // Get configured addresses if available
        if s.config != nil &amp;&amp; s.config.Services != nil </span><span class="cov8" title="1">{
                if s.config.Services.AuthService != "" </span><span class="cov8" title="1">{
                        authServiceAddr = s.config.Services.AuthService
                }</span>
                <span class="cov8" title="1">if s.config.Services.UserService != "" </span><span class="cov8" title="1">{
                        userServiceAddr = s.config.Services.UserService
                }</span>
                <span class="cov8" title="1">if s.config.Services.GameService != "" </span><span class="cov8" title="1">{
                        gameServiceAddr = s.config.Services.GameService
                }</span>
        }

        <span class="cov8" title="1">s.authClient = NewAuthServiceClient(authServiceAddr)
        s.userClient = NewUserServiceClient(userServiceAddr)

        // Use games from config if available
        if len(s.config.Games) &gt; 0 </span><span class="cov0" title="0">{
                s.gameClient = NewGameServiceClientWithConfig(gameServiceAddr, s.config.Games)
        }</span> else<span class="cov8" title="1"> {
                s.gameClient = NewGameServiceClient(gameServiceAddr)
        }</span>
}

// Start starts the SSH server
func (s *SSHServer) Start(ctx context.Context, port int) error <span class="cov8" title="1">{
        listener, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on port %d: %w", port, err)
        }</span>

        <span class="cov8" title="1">log.Printf("SSH server listening on port %d", port)

        // Start background services
        go s.startMetricsCollection(ctx)
        go s.startConnectionCleanup(ctx)

        // Handle shutdown
        go func() </span><span class="cov8" title="1">{
                &lt;-ctx.Done()
                log.Println("SSH server shutting down...")
                listener.Close()
        }</span>()

        // Accept connections
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                conn, err := listener.Accept()
                if err != nil </span><span class="cov8" title="1">{
                        if ctx.Err() != nil </span><span class="cov8" title="1">{
                                return nil // Context cancelled
                        }</span>
                        <span class="cov0" title="0">log.Printf("Failed to accept connection: %v", err)
                        s.metrics.mutex.Lock()
                        s.metrics.FailedConnections++
                        s.metrics.mutex.Unlock()
                        continue</span>
                }

                <span class="cov0" title="0">go s.handleConnection(ctx, conn)</span>
        }
}

// handleConnection handles a new SSH connection
func (s *SSHServer) handleConnection(ctx context.Context, netConn net.Conn) <span class="cov0" title="0">{
        defer netConn.Close()

        // Update metrics
        s.metrics.mutex.Lock()
        s.metrics.TotalConnections++
        s.metrics.ActiveConnections++
        s.metrics.mutex.Unlock()

        // Update Prometheus metrics
        s.updatePromMetrics(func(m *metrics.SSHMetrics) </span><span class="cov0" title="0">{
                m.ConnectionsTotal.Inc()
                m.ConnectionsActive.Inc()
        }</span>)
        <span class="cov0" title="0">connectionStart := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.metrics.mutex.Lock()
                s.metrics.ActiveConnections--
                s.metrics.mutex.Unlock()

                // Update Prometheus metrics
                s.updatePromMetrics(func(m *metrics.SSHMetrics) </span><span class="cov0" title="0">{
                        m.ConnectionsActive.Dec()
                        m.ConnectionDuration.Observe(time.Since(connectionStart).Seconds())
                }</span>)
        }()

        // Perform SSH handshake
        <span class="cov0" title="0">sshConn, chans, reqs, err := ssh.NewServerConn(netConn, s.sshConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to handshake: %v", err)
                s.metrics.mutex.Lock()
                s.metrics.FailedConnections++
                s.metrics.mutex.Unlock()

                // Update Prometheus metrics
                s.updatePromMetrics(func(m *metrics.SSHMetrics) </span><span class="cov0" title="0">{
                        m.ConnectionsFailed.Inc()
                }</span>)
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">defer sshConn.Close()

        // Create connection context
        connectionID := generateConnectionID()
        connection := &amp;SSHConnection{
                ID:           connectionID,
                Username:     sshConn.User(),
                RemoteAddr:   sshConn.RemoteAddr().String(),
                StartTime:    time.Now(),
                LastActivity: time.Now(),
                Sessions:     make(map[string]*SSHSessionContext),
        }

        // Track connection
        s.connectionsMux.Lock()
        s.connections[connectionID] = connection
        s.connectionsMux.Unlock()

        defer func() </span><span class="cov0" title="0">{
                s.connectionsMux.Lock()
                delete(s.connections, connectionID)
                s.connectionsMux.Unlock()
        }</span>()

        <span class="cov0" title="0">log.Printf("User %s connected from %s (connection: %s)",
                connection.Username, connection.RemoteAddr, connectionID)

        // Handle global requests
        go ssh.DiscardRequests(reqs)

        // Handle channels
        for newChannel := range chans </span><span class="cov0" title="0">{
                if newChannel.ChannelType() != "session" </span><span class="cov0" title="0">{
                        _ = newChannel.Reject(ssh.UnknownChannelType, "unknown channel type")
                        continue</span>
                }

                <span class="cov0" title="0">go s.handleChannel(ctx, newChannel, connection)</span>
        }
}

// handleChannel handles a new SSH channel (session)
func (s *SSHServer) handleChannel(ctx context.Context, newChannel ssh.NewChannel, connection *SSHConnection) <span class="cov0" title="0">{
        channel, requests, err := newChannel.Accept()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Could not accept channel: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer channel.Close()

        // Create session context
        sessionID := generateSSHSessionID()
        sessionCtx := &amp;SSHSessionContext{
                SessionID:    sessionID,
                ConnectionID: connection.ID,
                Username:     connection.Username,
                Channel:      channel,
                Requests:     requests,
                WindowSize:   &amp;WindowSize{Width: 80, Height: 24},
                Environment:  make(map[string]string),
                done:         make(chan struct{}),
                StartTime:    time.Now(),
                LastActivity: time.Now(),
        }

        // Track session
        connection.sessionsMux.Lock()
        connection.Sessions[sessionID] = sessionCtx
        connection.sessionsMux.Unlock()

        defer func() </span><span class="cov0" title="0">{
                connection.sessionsMux.Lock()
                delete(connection.Sessions, sessionID)
                connection.sessionsMux.Unlock()

                // Clean up PTY if allocated
                if sessionCtx.ptySession != nil </span><span class="cov0" title="0">{
                        _ = s.ptyManager.ReleasePTY(sessionID)
                }</span>
        }()

        // Update metrics
        <span class="cov0" title="0">s.metrics.mutex.Lock()
        s.metrics.TotalSessions++
        s.metrics.ActiveSessions++
        s.metrics.mutex.Unlock()

        // Update Prometheus metrics
        s.updatePromMetrics(func(m *metrics.SSHMetrics) </span><span class="cov0" title="0">{
                m.SessionsTotal.Inc()
                m.SessionsActive.Inc()
        }</span>)
        <span class="cov0" title="0">sessionStart := time.Now()

        defer func() </span><span class="cov0" title="0">{
                s.metrics.mutex.Lock()
                s.metrics.ActiveSessions--
                s.metrics.mutex.Unlock()

                // Update Prometheus metrics
                s.updatePromMetrics(func(m *metrics.SSHMetrics) </span><span class="cov0" title="0">{
                        m.SessionsActive.Dec()
                        m.SessionDuration.Observe(time.Since(sessionStart).Seconds())
                }</span>)
        }()

        <span class="cov0" title="0">log.Printf("New session %s for user %s", sessionID, connection.Username)

        // Handle session requests
        go s.handleSessionRequests(ctx, sessionCtx)

        // Start the main menu
        s.startMainMenu(ctx, sessionCtx)</span>
}

// handleSessionRequests handles SSH session requests
func (s *SSHServer) handleSessionRequests(ctx context.Context, sessionCtx *SSHSessionContext) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case req, ok := &lt;-sessionCtx.Requests:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">switch req.Type </span>{
                        case "pty-req":<span class="cov0" title="0">
                                s.handlePTYRequest(sessionCtx, req)</span>
                        case "shell":<span class="cov0" title="0">
                                s.handleShellRequest(sessionCtx, req)</span>
                        case "exec":<span class="cov0" title="0">
                                s.handleExecRequest(sessionCtx, req)</span>
                        case "window-change":<span class="cov0" title="0">
                                s.handleWindowChangeRequest(sessionCtx, req)</span>
                        case "env":<span class="cov0" title="0">
                                s.handleEnvRequest(sessionCtx, req)</span>
                        default:<span class="cov0" title="0">
                                _ = req.Reply(false, nil)</span>
                        }

                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-sessionCtx.done:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// handlePTYRequest handles PTY allocation request
func (s *SSHServer) handlePTYRequest(sessionCtx *SSHSessionContext, req *ssh.Request) <span class="cov0" title="0">{
        if len(req.Payload) &lt; 4 </span><span class="cov0" title="0">{
                _ = req.Reply(false, nil)
                return
        }</span>

        // Parse PTY request
        <span class="cov0" title="0">termLen := req.Payload[3]
        if len(req.Payload) &lt; 4+int(termLen)+16 </span><span class="cov0" title="0">{
                _ = req.Reply(false, nil)
                return
        }</span>

        <span class="cov0" title="0">sessionCtx.TerminalType = string(req.Payload[4 : 4+termLen])

        // Track terminal type
        s.updatePromMetrics(func(m *metrics.SSHMetrics) </span><span class="cov0" title="0">{
                m.TerminalTypes.WithLabelValues(sessionCtx.TerminalType).Inc()
        }</span>)

        // Extract window dimensions
        <span class="cov0" title="0">offset := 4 + int(termLen)
        sessionCtx.WindowSize.Width = uint16(req.Payload[offset])&lt;&lt;8 | uint16(req.Payload[offset+1])
        sessionCtx.WindowSize.Height = uint16(req.Payload[offset+2])&lt;&lt;8 | uint16(req.Payload[offset+3])
        sessionCtx.WindowSize.X = sessionCtx.WindowSize.Width
        sessionCtx.WindowSize.Y = sessionCtx.WindowSize.Height

        sessionCtx.HasPTY = true

        log.Printf("PTY allocated for session %s: %s %dx%d",
                sessionCtx.SessionID, sessionCtx.TerminalType,
                sessionCtx.WindowSize.Width, sessionCtx.WindowSize.Height)

        _ = req.Reply(true, nil)</span>
}

// handleShellRequest handles shell request
func (s *SSHServer) handleShellRequest(sessionCtx *SSHSessionContext, req *ssh.Request) <span class="cov0" title="0">{
        _ = req.Reply(true, nil)
}</span>

// handleExecRequest handles command execution request
func (s *SSHServer) handleExecRequest(sessionCtx *SSHSessionContext, req *ssh.Request) <span class="cov0" title="0">{
        if len(req.Payload) &lt; 4 </span><span class="cov0" title="0">{
                _ = req.Reply(false, nil)
                return
        }</span>

        <span class="cov0" title="0">cmdLen := uint32(req.Payload[0])&lt;&lt;24 | uint32(req.Payload[1])&lt;&lt;16 |
                uint32(req.Payload[2])&lt;&lt;8 | uint32(req.Payload[3])

        if len(req.Payload) &lt; 4+int(cmdLen) </span><span class="cov0" title="0">{
                _ = req.Reply(false, nil)
                return
        }</span>

        <span class="cov0" title="0">sessionCtx.Command = string(req.Payload[4 : 4+cmdLen])

        log.Printf("Command execution request for session %s: %s",
                sessionCtx.SessionID, sessionCtx.Command)

        _ = req.Reply(true, nil)</span>
}

// handleWindowChangeRequest handles window size change
func (s *SSHServer) handleWindowChangeRequest(sessionCtx *SSHSessionContext, req *ssh.Request) <span class="cov0" title="0">{
        if len(req.Payload) &gt;= 16 </span><span class="cov0" title="0">{
                sessionCtx.WindowSize.Width = uint16(req.Payload[0])&lt;&lt;8 | uint16(req.Payload[1])
                sessionCtx.WindowSize.Height = uint16(req.Payload[2])&lt;&lt;8 | uint16(req.Payload[3])
                sessionCtx.WindowSize.X = sessionCtx.WindowSize.Width
                sessionCtx.WindowSize.Y = sessionCtx.WindowSize.Height

                // Track terminal size change
                s.updatePromMetrics(func(m *metrics.SSHMetrics) </span><span class="cov0" title="0">{
                        m.TerminalSizeChanges.Inc()
                }</span>)

                // Update PTY window size if active
                <span class="cov0" title="0">if sessionCtx.ptySession != nil </span><span class="cov0" title="0">{
                        _ = sessionCtx.ptySession.ResizeWindow(sessionCtx.WindowSize.Height, sessionCtx.WindowSize.Width)
                }</span>

                <span class="cov0" title="0">log.Printf("Window size changed for session %s: %dx%d",
                        sessionCtx.SessionID, sessionCtx.WindowSize.Width, sessionCtx.WindowSize.Height)</span>
        }
        <span class="cov0" title="0">_ = req.Reply(true, nil)</span>
}

// handleEnvRequest handles environment variable request
func (s *SSHServer) handleEnvRequest(sessionCtx *SSHSessionContext, req *ssh.Request) <span class="cov0" title="0">{
        if len(req.Payload) &lt; 8 </span><span class="cov0" title="0">{
                _ = req.Reply(false, nil)
                return
        }</span>

        <span class="cov0" title="0">nameLen := uint32(req.Payload[0])&lt;&lt;24 | uint32(req.Payload[1])&lt;&lt;16 |
                uint32(req.Payload[2])&lt;&lt;8 | uint32(req.Payload[3])
        valueLen := uint32(req.Payload[4])&lt;&lt;24 | uint32(req.Payload[5])&lt;&lt;16 |
                uint32(req.Payload[6])&lt;&lt;8 | uint32(req.Payload[7])

        if len(req.Payload) &lt; 8+int(nameLen)+int(valueLen) </span><span class="cov0" title="0">{
                _ = req.Reply(false, nil)
                return
        }</span>

        <span class="cov0" title="0">name := string(req.Payload[8 : 8+nameLen])
        value := string(req.Payload[8+nameLen : 8+nameLen+valueLen])

        sessionCtx.Environment[name] = value

        log.Printf("Environment variable set for session %s: %s=%s",
                sessionCtx.SessionID, name, value)

        _ = req.Reply(true, nil)</span>
}

// startMainMenu starts the main menu
func (s *SSHServer) startMainMenu(ctx context.Context, sessionCtx *SSHSessionContext) <span class="cov0" title="0">{
        defer close(sessionCtx.done)

        // Send welcome banner
        s.sendBanner(sessionCtx)

        // Main menu loop
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-sessionCtx.done:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        // Show menu
                        s.showMenu(sessionCtx)

                        // Read user input
                        choice, err := s.readUserInput(sessionCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error reading user input: %v", err)
                                return
                        }</span>

                        // Handle menu choice
                        <span class="cov0" title="0">if !s.handleMenuChoice(ctx, sessionCtx, choice) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// sendBanner sends the appropriate banner based on user authentication status
func (s *SSHServer) sendBanner(sessionCtx *SSHSessionContext) <span class="cov0" title="0">{
        var bannerPath string
        var username string

        // Determine which banner to show based on authentication status
        if sessionCtx.IsAuthenticated </span><span class="cov0" title="0">{
                bannerPath = s.getBannerPath("main_user")
                username = sessionCtx.Username
        }</span> else<span class="cov0" title="0"> {
                bannerPath = s.getBannerPath("main_anon")
                username = "Anonymous"
        }</span>

        // Get terminal width, with fallback to default
        <span class="cov0" title="0">terminalWidth := 80
        if sessionCtx.WindowSize != nil </span><span class="cov0" title="0">{
                terminalWidth = int(sessionCtx.WindowSize.Width)
        }</span>

        // Load and display the dynamic banner
        <span class="cov0" title="0">banner := s.loadDynamicBanner(bannerPath, terminalWidth, username)
        if banner != "" </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, banner)
        }</span> else<span class="cov0" title="0"> {
                // Fallback to simple banner if file loading fails
                fallbackBanner := fmt.Sprintf("Welcome to DungeonGate, %s!\r\n\r\n", username)
                s.writeToSession(sessionCtx, fallbackBanner)
        }</span>
}

// getBannerPath returns the configured path for a specific banner type
func (s *SSHServer) getBannerPath(bannerType string) string <span class="cov0" title="0">{
        if s.config == nil || s.config.Menu == nil || s.config.Menu.Banners == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">switch bannerType </span>{
        case "main_anon":<span class="cov0" title="0">
                return s.config.Menu.Banners.MainAnon</span>
        case "main_user":<span class="cov0" title="0">
                return s.config.Menu.Banners.MainUser</span>
        case "watch_menu":<span class="cov0" title="0">
                return s.config.Menu.Banners.WatchMenu</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// loadDynamicBanner loads a banner file and dynamically resizes it for the terminal
func (s *SSHServer) loadDynamicBanner(bannerPath string, terminalWidth int, username string) string <span class="cov0" title="0">{
        if bannerPath == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Read banner file
        <span class="cov0" title="0">content, err := os.ReadFile(bannerPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to read banner file %s: %v", bannerPath, err)
                return ""
        }</span>

        // Process the banner content
        <span class="cov0" title="0">bannerText := string(content)

        // Replace placeholders
        bannerText = s.replaceBannerPlaceholders(bannerText, username)

        // Add hardcoded footer
        bannerText = s.addBannerFooter(bannerText)

        // Resize banner to fit terminal width
        resizedBanner := s.resizeBanner(bannerText, terminalWidth)

        return resizedBanner + "\r\n"</span>
}

// replaceBannerPlaceholders replaces template variables in banner text
func (s *SSHServer) replaceBannerPlaceholders(bannerText, username string) string <span class="cov0" title="0">{
        // Replace common placeholders - order matters! Replace longer placeholders first
        bannerText = strings.ReplaceAll(bannerText, "$SERVERID", "DungeonGate")
        bannerText = strings.ReplaceAll(bannerText, "$USERNAME", username) // Replace this before $USER
        bannerText = strings.ReplaceAll(bannerText, "{user}", username)
        bannerText = strings.ReplaceAll(bannerText, "$USER", username)

        // Add timestamp if placeholder exists
        bannerText = strings.ReplaceAll(bannerText, "$DATE", time.Now().Format("2006-01-02"))
        bannerText = strings.ReplaceAll(bannerText, "$TIME", time.Now().Format("15:04:05"))

        return bannerText
}</span>

// addBannerFooter adds a hardcoded footer to the banner content
func (s *SSHServer) addBannerFooter(bannerText string) string <span class="cov0" title="0">{
        version := "0.0.2" // default fallback
        if s.config != nil &amp;&amp; s.config.Version != "" </span><span class="cov0" title="0">{
                version = s.config.Version
        }</span>

        <span class="cov0" title="0">footer := fmt.Sprintf(`

        
  ## Powered by             DungeonGate         %s
  ## See https://github.com/psubacz/dungeongate`, version)

        return bannerText + footer</span>
}

// resizeBanner dynamically adjusts banner content to fit terminal width
func (s *SSHServer) resizeBanner(bannerText string, terminalWidth int) string <span class="cov0" title="0">{
        if terminalWidth &lt;= 0 </span><span class="cov0" title="0">{
                terminalWidth = 80 // Default fallback
        }</span>

        <span class="cov0" title="0">lines := strings.Split(bannerText, "\n")
        var resizedLines []string

        for _, line := range lines </span><span class="cov0" title="0">{
                // Remove any existing \r characters
                line = strings.TrimRight(line, "\r")

                // Calculate padding needed to center the line
                lineLength := len(line)

                if lineLength == 0 </span><span class="cov0" title="0">{
                        // Empty line
                        resizedLines = append(resizedLines, "")
                        continue</span>
                }

                <span class="cov0" title="0">if lineLength &gt; terminalWidth &amp;&amp; terminalWidth &gt; 10 </span><span class="cov0" title="0">{
                        // Line is too long, truncate it with ellipsis if there's enough space
                        truncated := line[:terminalWidth-3] + "..."
                        resizedLines = append(resizedLines, truncated)
                }</span> else<span class="cov0" title="0"> if lineLength &gt; terminalWidth </span><span class="cov0" title="0">{
                        // Just truncate without ellipsis for very narrow terminals
                        truncated := line[:terminalWidth]
                        resizedLines = append(resizedLines, truncated)
                }</span> else<span class="cov0" title="0"> {
                        // Left-align the line (no padding needed)
                        resizedLines = append(resizedLines, line)
                }</span>
        }

        // Join lines with \r\n for proper terminal display
        <span class="cov0" title="0">return strings.Join(resizedLines, "\r\n")</span>
}

// showDynamicMenu generates a menu with the specified width
func (s *SSHServer) showDynamicMenu(sessionCtx *SSHSessionContext, width int) <span class="cov0" title="0">{
        var bannerPath string
        var username string

        // Determine which banner to show based on authentication status
        if sessionCtx.IsAuthenticated &amp;&amp; sessionCtx.AuthenticatedUser != nil </span><span class="cov0" title="0">{
                bannerPath = s.getBannerPath("main_user")
                username = sessionCtx.AuthenticatedUser.Username
        }</span> else<span class="cov0" title="0"> {
                bannerPath = s.getBannerPath("main_anon")
                username = "Anonymous"
        }</span>

        // Try to load and display the dynamic banner
        <span class="cov0" title="0">banner := s.loadDynamicBanner(bannerPath, width, username)
        if banner != "" </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, banner)
                s.writeToSession(sessionCtx, "\r\nChoice: ")
                return
        }</span>

        // Fallback to boxed menu if banner loading fails

        // Generate top border
        <span class="cov0" title="0">topBorder := "" + strings.Repeat("", width-2) + "\r\n"

        // Generate title line
        title := "DungeonGate - SSH Edition"
        titleLine := s.generateMenuLine(title, width, true)

        // Generate separator
        separator := "" + strings.Repeat("", width-2) + "\r\n"

        // Generate content lines
        var menu strings.Builder
        menu.WriteString(topBorder)
        menu.WriteString(titleLine)
        menu.WriteString(separator)
        menu.WriteString(s.generateMenuLine("", width, false)) // Empty line

        // Welcome message
        if sessionCtx.IsAuthenticated &amp;&amp; sessionCtx.AuthenticatedUser != nil </span><span class="cov0" title="0">{
                welcomeMsg := fmt.Sprintf("Welcome, %s!", sessionCtx.AuthenticatedUser.Username)
                menu.WriteString(s.generateMenuLine(welcomeMsg, width, false))
        }</span> else<span class="cov0" title="0"> {
                menu.WriteString(s.generateMenuLine("Welcome, anonymous user!", width, false))
        }</span>

        <span class="cov0" title="0">menu.WriteString(s.generateMenuLine("", width, false)) // Empty line

        // Menu options
        if sessionCtx.IsAuthenticated &amp;&amp; sessionCtx.AuthenticatedUser != nil </span><span class="cov0" title="0">{
                menu.WriteString(s.generateMenuLine("[p] Play a game", width, false))
                menu.WriteString(s.generateMenuLine("[w] Watch games", width, false))
                menu.WriteString(s.generateMenuLine("[e] Edit profile", width, false))
                menu.WriteString(s.generateMenuLine("[l] List games", width, false))
                menu.WriteString(s.generateMenuLine("[r] View recordings", width, false))
                menu.WriteString(s.generateMenuLine("[s] Statistics", width, false))
                menu.WriteString(s.generateMenuLine("[q] Quit", width, false))
        }</span> else<span class="cov0" title="0"> {
                menu.WriteString(s.generateMenuLine("[l] Login", width, false))
                menu.WriteString(s.generateMenuLine("[r] Register", width, false))
                menu.WriteString(s.generateMenuLine("[w] Watch games", width, false))
                menu.WriteString(s.generateMenuLine("[g] List games", width, false))
                menu.WriteString(s.generateMenuLine("[q] Quit", width, false))
        }</span>

        <span class="cov0" title="0">menu.WriteString(s.generateMenuLine("", width, false)) // Empty line

        // Generate bottom border
        bottomBorder := "" + strings.Repeat("", width-2) + "\r\n"
        menu.WriteString(bottomBorder)

        menu.WriteString("\r\nChoice: ")

        s.writeToSession(sessionCtx, menu.String())</span>
}

// generateMenuLine creates a properly formatted menu line
func (s *SSHServer) generateMenuLine(content string, width int, centered bool) string <span class="cov0" title="0">{
        if centered </span><span class="cov0" title="0">{
                // Center the content
                padding := (width - 2 - len(content)) / 2
                leftPad := strings.Repeat(" ", padding)
                rightPad := strings.Repeat(" ", width-2-len(content)-padding)
                return "" + leftPad + content + rightPad + "\r\n"
        }</span> else<span class="cov0" title="0"> {
                // Left-align with padding
                if content == "" </span><span class="cov0" title="0">{
                        // Empty line
                        return "" + strings.Repeat(" ", width-2) + "\r\n"
                }</span> else<span class="cov0" title="0"> {
                        // Content line with left padding
                        leftPad := "  " // 2 spaces for indentation
                        contentWithPad := leftPad + content
                        rightPad := strings.Repeat(" ", width-2-len(contentWithPad))
                        return "" + contentWithPad + rightPad + "\r\n"
                }</span>
        }
}

// showCompactMenu shows a simple menu for narrow terminals
func (s *SSHServer) showCompactMenu(sessionCtx *SSHSessionContext) <span class="cov0" title="0">{
        var bannerPath string
        var username string

        // Determine which banner to show based on authentication status
        if sessionCtx.IsAuthenticated &amp;&amp; sessionCtx.AuthenticatedUser != nil </span><span class="cov0" title="0">{
                bannerPath = s.getBannerPath("main_user")
                username = sessionCtx.AuthenticatedUser.Username
        }</span> else<span class="cov0" title="0"> {
                bannerPath = s.getBannerPath("main_anon")
                username = "Anonymous"
        }</span>

        // Get terminal width for narrow terminals
        <span class="cov0" title="0">terminalWidth := 50
        if sessionCtx.WindowSize != nil &amp;&amp; sessionCtx.WindowSize.Width &gt; 0 </span><span class="cov0" title="0">{
                terminalWidth = int(sessionCtx.WindowSize.Width)
        }</span>

        // Try to load and display the dynamic banner
        <span class="cov0" title="0">banner := s.loadDynamicBanner(bannerPath, terminalWidth, username)
        if banner != "" </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, banner)
                s.writeToSession(sessionCtx, "\r\nChoice: ")
        }</span> else<span class="cov0" title="0"> {
                // Fallback to simple menu if banner loading fails
                var menu strings.Builder
                menu.WriteString("=== DungeonGate ===\r\n\r\n")

                if sessionCtx.IsAuthenticated &amp;&amp; sessionCtx.AuthenticatedUser != nil </span><span class="cov0" title="0">{
                        menu.WriteString(fmt.Sprintf("Welcome, %s!\r\n\r\n", sessionCtx.AuthenticatedUser.Username))
                        menu.WriteString("[p] Play a game\r\n")
                        menu.WriteString("[w] Watch games\r\n")
                        menu.WriteString("[e] Edit profile\r\n")
                        menu.WriteString("[l] List games\r\n")
                        menu.WriteString("[r] View recordings\r\n")
                        menu.WriteString("[s] Statistics\r\n")
                        menu.WriteString("[q] Quit\r\n")
                }</span> else<span class="cov0" title="0"> {
                        menu.WriteString("Welcome, anonymous user!\r\n\r\n")
                        menu.WriteString("[l] Login\r\n")
                        menu.WriteString("[r] Register\r\n")
                        menu.WriteString("[w] Watch games\r\n")
                        menu.WriteString("[g] List games\r\n")
                        menu.WriteString("[q] Quit\r\n")
                }</span>

                <span class="cov0" title="0">menu.WriteString("\r\nChoice: ")
                s.writeToSession(sessionCtx, menu.String())</span>
        }
}

func (s *SSHServer) showMenu(sessionCtx *SSHSessionContext) <span class="cov0" title="0">{
        s.clearScreen(sessionCtx)

        termWidth := int(sessionCtx.WindowSize.Width)

        // Minimum width check
        if termWidth &lt; 50 </span><span class="cov0" title="0">{
                s.showCompactMenu(sessionCtx)
                return
        }</span>

        // Calculate optimal menu width
        <span class="cov0" title="0">menuWidth := termWidth - 4 // Leave 2 chars margin on each side
        if menuWidth &gt; 78 </span><span class="cov0" title="0">{
                menuWidth = 78 // Cap at reasonable maximum
        }</span>

        <span class="cov0" title="0">s.showDynamicMenu(sessionCtx, menuWidth)</span>
}

// // showMenu displays the main menu
// func (s *SSHServer) showMenu(sessionCtx *SSHSessionContext) {
//         s.clearScreen(sessionCtx)

//         menu := `
// 
//                             DungeonGate - SSH Edition                         
// 
//                                                                               
// `

//         if sessionCtx.IsAuthenticated &amp;&amp; sessionCtx.AuthenticatedUser != nil {
//                 menu += fmt.Sprintf("  Welcome, %s!%-60s\r\n",
//                         sessionCtx.AuthenticatedUser.Username,
//                         strings.Repeat(" ", 60-len(sessionCtx.AuthenticatedUser.Username)-10))
//                 menu += `                                                                              
//   [p] Play a game                                                             
//   [w] Watch games                                                             
//   [e] Edit profile                                                            
//   [l] List games                                                              
//   [r] View recordings                                                         
//   [s] Statistics                                                              
//   [q] Quit                                                                    
// `
//         } else {
//                 menu += `  Welcome, anonymous user!                                                    
//                                                                               
//   [l] Login                                                                   
//   [r] Register                                                                
//   [w] Watch games                                                             
//   [g] List games                                                              
//   [q] Quit                                                                    
// `
//         }

//         menu += `                                                                              
// 

// Choice: `

//         s.writeToSession(sessionCtx, menu)
// }

// readUserInput reads user input from the SSH session
func (s *SSHServer) readUserInput(sessionCtx *SSHSessionContext) (string, error) <span class="cov0" title="0">{
        buffer := make([]byte, 1)

        for </span><span class="cov0" title="0">{
                n, err := sessionCtx.Channel.Read(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Update metrics
                <span class="cov0" title="0">sessionCtx.BytesRead += int64(n)
                sessionCtx.LastActivity = time.Now()

                char := buffer[0]

                // Handle special characters
                switch char </span>{
                case 3:<span class="cov0" title="0"> // Ctrl+C
                        return "", fmt.Errorf("interrupted")</span>
                case '\r', '\n':<span class="cov0" title="0">
                        // Ignore line endings for single char input
                        continue</span>
                case ' ', '\t':<span class="cov0" title="0">
                        // Ignore whitespace for single char input
                        continue</span>
                default:<span class="cov0" title="0">
                        // Return the character as a string
                        if char &gt;= 32 &amp;&amp; char &lt;= 126 </span><span class="cov0" title="0">{ // Printable ASCII
                                return string(char), nil
                        }</span>
                        // Ignore other control characters
                        <span class="cov0" title="0">continue</span>
                }
        }
}

// readPasswordInput reads password input (without echo)
func (s *SSHServer) readPasswordInput(sessionCtx *SSHSessionContext) (string, error) <span class="cov0" title="0">{
        var password strings.Builder
        buffer := make([]byte, 1)

        for </span><span class="cov0" title="0">{
                n, err := sessionCtx.Channel.Read(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sessionCtx.BytesRead += int64(n)
                sessionCtx.LastActivity = time.Now()

                char := buffer[0]

                switch char </span>{
                case '\r', '\n':<span class="cov0" title="0">
                        // End of input
                        s.writeToSession(sessionCtx, "\r\n")
                        return password.String(), nil</span>
                case '\b', 127:<span class="cov0" title="0"> // Backspace
                        if password.Len() &gt; 0 </span><span class="cov0" title="0">{
                                passwordStr := password.String()
                                password.Reset()
                                password.WriteString(passwordStr[:len(passwordStr)-1])
                                s.writeToSession(sessionCtx, "\b \b")
                        }</span>
                case 3:<span class="cov0" title="0"> // Ctrl+C
                        return "", fmt.Errorf("interrupted")</span>
                default:<span class="cov0" title="0">
                        password.WriteByte(char)
                        s.writeToSession(sessionCtx, "*")</span>
                }
        }
}

// handleMenuChoice handles menu selection
func (s *SSHServer) handleMenuChoice(ctx context.Context, sessionCtx *SSHSessionContext, choice string) bool <span class="cov8" title="1">{
        switch strings.ToLower(choice) </span>{
        case "l":<span class="cov0" title="0">
                if sessionCtx.IsAuthenticated </span><span class="cov0" title="0">{
                        return s.handleListGames(ctx, sessionCtx)
                }</span>
                <span class="cov0" title="0">return s.handleLogin(ctx, sessionCtx)</span>
        case "r":<span class="cov0" title="0">
                if sessionCtx.IsAuthenticated </span><span class="cov0" title="0">{
                        return s.handleViewRecordings(ctx, sessionCtx)
                }</span>
                <span class="cov0" title="0">return s.handleRegisterEnhanced(ctx, sessionCtx)</span>
        case "p":<span class="cov0" title="0">
                if !sessionCtx.IsAuthenticated </span><span class="cov0" title="0">{
                        s.writeToSession(sessionCtx, "Please login first.\r\n")
                        s.waitForKeypress(sessionCtx)
                        return true
                }</span>
                <span class="cov0" title="0">return s.handlePlayGame(ctx, sessionCtx)</span>
        case "w":<span class="cov0" title="0">
                return s.handleWatchGames(ctx, sessionCtx)</span>
        case "e":<span class="cov0" title="0">
                if !sessionCtx.IsAuthenticated </span><span class="cov0" title="0">{
                        s.writeToSession(sessionCtx, "Please login first.\r\n")
                        s.waitForKeypress(sessionCtx)
                        return true
                }</span>
                <span class="cov0" title="0">return s.handleEditProfile(ctx, sessionCtx)</span>
        case "g":<span class="cov0" title="0">
                return s.handleListGames(ctx, sessionCtx)</span>
        case "s":<span class="cov0" title="0">
                return s.handleStatistics(ctx, sessionCtx)</span>
        case "x":<span class="cov0" title="0">
                if !sessionCtx.IsAuthenticated </span><span class="cov0" title="0">{
                        s.writeToSession(sessionCtx, "Please login first.\r\n")
                        s.waitForKeypress(sessionCtx)
                        return true
                }</span>
                <span class="cov0" title="0">return s.handleResetSave(ctx, sessionCtx)</span>
        case "q":<span class="cov8" title="1">
                s.writeToSession(sessionCtx, "Goodbye!\r\n")
                return false</span>
        default:<span class="cov8" title="1">
                s.writeToSession(sessionCtx, "Invalid choice. Please try again.\r\n")
                s.waitForKeypress(sessionCtx)
                return true</span>
        }
}

// handleLogin handles user login with retry logic
func (s *SSHServer) handleLogin(ctx context.Context, sessionCtx *SSHSessionContext) bool <span class="cov0" title="0">{
        maxLoginAttempts := s.getMaxLoginAttemptsWithDefault()
        attempts := 0

        for attempts &lt; maxLoginAttempts </span><span class="cov0" title="0">{
                s.clearScreen(sessionCtx)
                s.writeToSession(sessionCtx, "=== Login ===\r\n\r\n")

                if attempts &gt; 0 </span><span class="cov0" title="0">{
                        s.writeToSession(sessionCtx, fmt.Sprintf("Login attempt %d of %d\r\n\r\n", attempts+1, maxLoginAttempts))
                }</span>

                <span class="cov0" title="0">s.writeToSession(sessionCtx, "Username: ")
                username, err := s.readLineInput(sessionCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">s.writeToSession(sessionCtx, "Password: ")
                password, err := s.readPasswordInput(sessionCtx)
                if err != nil </span><span class="cov0" title="0">{
                        s.writeToSession(sessionCtx, "Login cancelled.\r\n")
                        s.waitForKeypress(sessionCtx)
                        return true
                }</span>

                // Track authentication attempt
                <span class="cov0" title="0">authStart := time.Now()
                s.promMetrics.AuthAttemptsTotal.WithLabelValues("password", username).Inc()

                // Wait for auth service to be available - spin until it comes back
                for s.sessionService.authMiddleware == nil </span><span class="cov0" title="0">{
                        s.writeToSession(sessionCtx, "Authentication service is starting up, please wait...\r\n")
                        time.Sleep(2 * time.Second)
                        
                        // Check if connection is still alive
                        if sessionCtx.Channel == nil </span><span class="cov0" title="0">{
                                return true // Connection was closed
                        }</span>
                }

                // Auth service is now available
                // Get client IP from connection
                <span class="cov0" title="0">clientIP := "unknown"
                if sessionCtx.ConnectionID != "" </span><span class="cov0" title="0">{
                        s.connectionsMux.RLock()
                        if conn, exists := s.connections[sessionCtx.ConnectionID]; exists </span><span class="cov0" title="0">{
                                clientIP = conn.RemoteAddr
                        }</span>
                        <span class="cov0" title="0">s.connectionsMux.RUnlock()</span>
                }
                <span class="cov0" title="0">authenticatedUser, err := s.sessionService.authMiddleware.AuthenticateUser(ctx, username, password, clientIP)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types for better user feedback
                        var errorMessage string
                        var metricLabel string
                        var shouldRetry = true

                        switch </span>{
                        case strings.Contains(err.Error(), "user_not_found") || strings.Contains(err.Error(), "username_not_found"):<span class="cov0" title="0">
                                errorMessage = "Username not found. Please check your username and try again.\r\n"
                                metricLabel = "username_not_found"</span>
                        case strings.Contains(err.Error(), "invalid_credentials") || strings.Contains(err.Error(), "invalid_password"):<span class="cov0" title="0">
                                errorMessage = "Incorrect password. Please try again.\r\n"
                                metricLabel = "invalid_password"</span>
                        case strings.Contains(err.Error(), "account_locked"):<span class="cov0" title="0">
                                errorMessage = "Account is temporarily locked due to too many failed login attempts. Please try again later.\r\n"
                                metricLabel = "account_locked"
                                shouldRetry = false</span> // Don't allow retry for locked accounts
                        default:<span class="cov0" title="0">
                                errorMessage = "Login failed. Please try again.\r\n"
                                metricLabel = "other_error"</span>
                        }

                        <span class="cov0" title="0">s.promMetrics.AuthFailuresTotal.WithLabelValues("password", metricLabel).Inc()
                        s.promMetrics.AuthDuration.Observe(time.Since(authStart).Seconds())
                        s.writeToSession(sessionCtx, errorMessage)

                        if !shouldRetry </span><span class="cov0" title="0">{
                                s.waitForKeypress(sessionCtx)
                                return true
                        }</span>

                        <span class="cov0" title="0">attempts++
                        if attempts &lt; maxLoginAttempts </span><span class="cov0" title="0">{
                                s.writeToSession(sessionCtx, "\r\nPress any key to try again...")
                                s.waitForKeypress(sessionCtx)
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                s.writeToSession(sessionCtx, "\r\nMaximum login attempts exceeded.\r\n")
                                s.waitForKeypress(sessionCtx)
                                return true
                        }</span>
                }

                // Login successful - User is already in the correct format from auth middleware
                <span class="cov0" title="0">sessionCtx.IsAuthenticated = true
                sessionCtx.AuthenticatedUser = authenticatedUser
                sessionCtx.Username = authenticatedUser.Username

                // Track successful authentication
                s.promMetrics.AuthDuration.Observe(time.Since(authStart).Seconds())

                s.writeToSession(sessionCtx, "Login successful - Press any key to continue!\r\n")
                s.waitForKeypress(sessionCtx)
                return true</span>
        }

        // This should never be reached
        <span class="cov0" title="0">return true</span>
}

// handleRegisterEnhanced handles enhanced user registration with validation
func (s *SSHServer) handleRegisterEnhanced(ctx context.Context, sessionCtx *SSHSessionContext) bool <span class="cov0" title="0">{
        s.clearScreen(sessionCtx)
        s.writeToSession(sessionCtx, "\r\n")
        s.writeToSession(sessionCtx, "                    User Registration                      \r\n")
        s.writeToSession(sessionCtx, "\r\n\r\n")

        // Get connection info for logging
        remoteAddr := "unknown"
        if sessionCtx.ConnectionID != "" </span><span class="cov0" title="0">{
                s.connectionsMux.RLock()
                if conn, exists := s.connections[sessionCtx.ConnectionID]; exists </span><span class="cov0" title="0">{
                        remoteAddr = conn.RemoteAddr
                }</span>
                <span class="cov0" title="0">s.connectionsMux.RUnlock()</span>
        }

        // Step 1: Username
        <span class="cov0" title="0">s.writeToSession(sessionCtx, "Step 1/4: Choose your username\r\n")
        s.writeToSession(sessionCtx, "(3-30 characters, letters, numbers, and underscores only)\r\n\r\n")
        s.writeToSession(sessionCtx, "Username: ")
        username, err := s.readLineInput(sessionCtx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: Username input error: %v", err)
                return false
        }</span>

        <span class="cov0" title="0">log.Printf("DEBUG: Registration attempt - Username: %s, IP: %s", username, remoteAddr)

        // Step 2: Email (optional)
        s.writeToSession(sessionCtx, "\r\nStep 2/4: Email address (optional, press Enter to skip)\r\n")
        s.writeToSession(sessionCtx, "Email: ")
        email, err := s.readLineInput(sessionCtx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: Email input error: %v", err)
                return false
        }</span>

        // Step 3: Password
        <span class="cov0" title="0">s.writeToSession(sessionCtx, "\r\nStep 3/4: Choose a password\r\n")
        s.writeToSession(sessionCtx, "(minimum 6 characters)\r\n\r\n")
        s.writeToSession(sessionCtx, "Password: ")
        password, err := s.readPasswordInput(sessionCtx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: Password input error: %v", err)
                s.writeToSession(sessionCtx, "Registration cancelled.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        // Step 4: Confirm password
        <span class="cov0" title="0">s.writeToSession(sessionCtx, "\r\nStep 4/4: Confirm your password\r\n")
        s.writeToSession(sessionCtx, "Confirm password: ")
        confirmPassword, err := s.readPasswordInput(sessionCtx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: Password confirmation error: %v", err)
                s.writeToSession(sessionCtx, "Registration cancelled.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        // Basic validation
        <span class="cov0" title="0">if password != confirmPassword </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, "\r\n Passwords don't match. Please try again.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">s.writeToSession(sessionCtx, "\r\n Creating your account...\r\n")

        // Create registration request - convert from user to session types
        req := &amp;RegistrationRequest{
                Username:        username,
                Password:        password,
                PasswordConfirm: confirmPassword,
                Email:           email,
                RealName:        "",   // Not collected in enhanced version yet
                AcceptTerms:     true, // Implied by registration
                Source:          "ssh",
                IPAddress:       remoteAddr,
                UserAgent:       "dungeongate-ssh",
        }

        log.Printf("DEBUG: Calling user service registration for: %s", username)

        // Use the real user service for registration
        if s.sessionService.userService != nil </span><span class="cov0" title="0">{
                // Convert to user service registration request
                userReq := &amp;user.RegistrationRequest{
                        Username:        username,
                        Password:        password,
                        PasswordConfirm: confirmPassword,
                        Email:           email,
                        RealName:        "",   // Not collected in enhanced version yet
                        AcceptTerms:     true, // Implied by registration
                        Source:          "ssh",
                        IPAddress:       remoteAddr,
                        UserAgent:       "dungeongate-ssh",
                }

                // Direct call to user service
                response, err := s.sessionService.userService.RegisterUser(ctx, userReq)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("DEBUG: Registration failed for %s: %v", username, err)
                        s.writeToSession(sessionCtx, fmt.Sprintf(" Registration failed: %v\r\n", err))
                        s.waitForKeypress(sessionCtx)
                        return true
                }</span>

                <span class="cov0" title="0">if !response.Success </span><span class="cov0" title="0">{
                        log.Printf("DEBUG: Registration validation failed for %s", username)
                        s.writeToSession(sessionCtx, " Registration failed:\r\n")
                        for _, validationErr := range response.Errors </span><span class="cov0" title="0">{
                                s.writeToSession(sessionCtx, fmt.Sprintf("    %s: %s\r\n", validationErr.Field, validationErr.Message))
                        }</span>
                        <span class="cov0" title="0">s.waitForKeypress(sessionCtx)
                        return true</span>
                }

                // Success!
                <span class="cov0" title="0">log.Printf("DEBUG: User registered successfully - ID: %d, Username: %s", response.User.ID, response.User.Username)

                // Verify in database
                if registeredUser, err := s.sessionService.userService.GetUserByUsername(ctx, username); err == nil </span><span class="cov0" title="0">{
                        log.Printf("DEBUG: User verification - Found in DB: %s (ID: %d)", registeredUser.Username, registeredUser.ID)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("DEBUG: User verification failed: %v", err)
                }</span>

                <span class="cov0" title="0">s.writeToSession(sessionCtx, "\r\n Registration successful!\r\n\r\n")
                s.writeToSession(sessionCtx, fmt.Sprintf("Welcome to DungeonGate, %s!\r\n", response.User.Username))
                s.writeToSession(sessionCtx, "You can now login with your credentials.\r\n\r\n")
                s.writeToSession(sessionCtx, "Press any key to continue...")
                s.waitForKeypress(sessionCtx)

                return true</span>
        } else<span class="cov0" title="0"> {
                // Fallback to mock user client (this should not happen in production)
                log.Printf("DEBUG: No user service available, using fallback mock client")
                response, err := s.userClient.RegisterUser(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("DEBUG: Mock registration failed for %s: %v", username, err)
                        s.writeToSession(sessionCtx, fmt.Sprintf(" Registration failed: %v\r\n", err))
                        s.waitForKeypress(sessionCtx)
                        return true
                }</span>

                <span class="cov0" title="0">log.Printf("DEBUG: Mock user registered: %s", response.User.Username)
                s.writeToSession(sessionCtx, "\r\n Registration successful! (Mock)\r\n\r\n")
                s.writeToSession(sessionCtx, fmt.Sprintf("Welcome to DungeonGate, %s!\r\n", response.User.Username))
                s.writeToSession(sessionCtx, "You can now login with your credentials.\r\n\r\n")
                s.writeToSession(sessionCtx, "Press any key to continue...")
                s.waitForKeypress(sessionCtx)

                return true</span>
        }
}


// handlePlayGame handles game selection and launching
func (s *SSHServer) handlePlayGame(ctx context.Context, sessionCtx *SSHSessionContext) bool <span class="cov0" title="0">{
        games, err := s.gameClient.ListGames(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, "Error retrieving games.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">enabledGames := make([]*Game, 0)
        for _, game := range games </span><span class="cov0" title="0">{
                if game.Enabled </span><span class="cov0" title="0">{
                        enabledGames = append(enabledGames, game)
                }</span>
        }

        <span class="cov0" title="0">if len(enabledGames) == 0 </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, "No games available.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">s.clearScreen(sessionCtx)
        s.writeToSession(sessionCtx, "=== Available Games ===\r\n\r\n")

        for i, game := range enabledGames </span><span class="cov0" title="0">{
                gameDisplay := fmt.Sprintf("[%d] %s - %s", i+1, game.Name, game.Description)

                // Add save information for NetHack
                if game.ID == "nethack" &amp;&amp; sessionCtx.IsAuthenticated </span><span class="cov0" title="0">{
                        saveManager := NewSaveManager("/tmp/nethack-saves")
                        if userSave, err := saveManager.GetUserSave(sessionCtx.Username, "nethack"); err == nil &amp;&amp; userSave.HasSave </span><span class="cov0" title="0">{
                                if userSave.SaveHash != "" </span><span class="cov0" title="0">{
                                        gameDisplay += fmt.Sprintf(" (Save Hash: %s)", userSave.SaveHash)
                                }</span> else<span class="cov0" title="0"> {
                                        gameDisplay += " (Save Available)"
                                }</span>
                        }
                }

                <span class="cov0" title="0">s.writeToSession(sessionCtx, gameDisplay+"\r\n")</span>
        }

        <span class="cov0" title="0">s.writeToSession(sessionCtx, "\r\nChoice (0 to cancel): ")
        choice, err := s.readLineInput(sessionCtx)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">gameID, err := strconv.Atoi(choice)
        if err != nil || gameID == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if gameID &lt; 1 || gameID &gt; len(enabledGames) </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, "Invalid choice.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">selectedGame := enabledGames[gameID-1]

        // Handle NetHack with save slot selection
        if selectedGame.ID == "nethack" </span><span class="cov0" title="0">{
                return s.handleNetHackGame(ctx, sessionCtx, selectedGame)
        }</span>

        // Start the game
        <span class="cov0" title="0">s.writeToSession(sessionCtx, fmt.Sprintf("Starting %s...\r\n", selectedGame.Name))

        // Create game session
        var userID int
        var username string
        if sessionCtx.IsAuthenticated &amp;&amp; sessionCtx.AuthenticatedUser != nil </span><span class="cov0" title="0">{
                userID = sessionCtx.AuthenticatedUser.ID
                username = sessionCtx.AuthenticatedUser.Username
        }</span> else<span class="cov0" title="0"> {
                userID = 0                     // Anonymous user
                username = sessionCtx.Username // Use the session username
        }</span>

        <span class="cov0" title="0">gameSession, err := s.sessionService.CreateSession(ctx, &amp;CreateSessionRequest{
                UserID:       userID,
                Username:     username,
                GameID:       selectedGame.ID,
                TerminalSize: fmt.Sprintf("%dx%d", sessionCtx.WindowSize.Width, sessionCtx.WindowSize.Height),
                Encoding:     "utf-8",
        })
        if err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, fmt.Sprintf("Failed to create game session: %v\r\n", err))
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        // Start game in PTY
        <span class="cov0" title="0">err = s.startGameInPTY(ctx, sessionCtx, selectedGame, gameSession)
        if err != nil </span><span class="cov0" title="0">{
                // Check if this is just a normal game exit
                if err == io.EOF || err.Error() == "PTY session has ended" || strings.Contains(err.Error(), "has ended") </span><span class="cov0" title="0">{
                        // Game ended normally, this is not an error
                        log.Printf("Game ended normally for user %s", sessionCtx.Username)
                }</span> else<span class="cov0" title="0"> {
                        s.writeToSession(sessionCtx, fmt.Sprintf("Failed to start game: %v\r\n", err))
                        s.waitForKeypress(sessionCtx)
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">return true</span>
}

// startGameInPTY starts a game in a PTY session
func (s *SSHServer) startGameInPTY(ctx context.Context, sessionCtx *SSHSessionContext, game *Game, gameSession *Session) error <span class="cov0" title="0">{
        // Track game start
        gameStart := time.Now()
        s.promMetrics.GamesStartedTotal.WithLabelValues(game.ID, game.Name).Inc()
        s.promMetrics.GamesActive.WithLabelValues(game.ID, game.Name).Inc()

        // Allocate PTY
        ptySession, err := s.ptyManager.AllocatePTY(sessionCtx.SessionID, sessionCtx.Username, game.ID, *sessionCtx.WindowSize)
        if err != nil </span><span class="cov0" title="0">{
                s.promMetrics.GameSessionErrors.WithLabelValues(game.ID, "pty_allocation").Inc()
                return fmt.Errorf("failed to allocate PTY: %w", err)
        }</span>

        <span class="cov0" title="0">sessionCtx.ptySession = ptySession

        // Build game command
        command, args := s.buildGameCommand(game, sessionCtx)

        // Start game process
        if err := ptySession.StartCommand(command, args); err != nil </span><span class="cov0" title="0">{
                _ = s.ptyManager.ReleasePTY(sessionCtx.SessionID)
                s.promMetrics.GameSessionErrors.WithLabelValues(game.ID, "start_failed").Inc()
                s.promMetrics.GamesActive.WithLabelValues(game.ID, game.Name).Dec()
                return fmt.Errorf("failed to start game: %w", err)
        }</span>

        // Set up cleanup for when game ends
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                s.promMetrics.GamesActive.WithLabelValues(game.ID, game.Name).Dec()
                s.promMetrics.GameDuration.WithLabelValues(game.ID, game.Name).Observe(time.Since(gameStart).Seconds())
        }</span>()

        <span class="cov0" title="0">s.writeToSession(sessionCtx, "Game started! Press Ctrl+C to exit.\r\n")
        time.Sleep(1 * time.Second)

        // Start I/O bridging with spectator support
        return s.bridgeGameIO(ctx, sessionCtx, ptySession, gameSession)</span>
}

// buildGameCommand builds the command to start a game
func (s *SSHServer) buildGameCommand(game *Game, sessionCtx *SSHSessionContext) (string, []string) <span class="cov0" title="0">{
        // Use configured binary and args if available, but fix NetHack args
        if game.Binary != "" </span><span class="cov0" title="0">{
                args := make([]string, len(game.Args))
                copy(args, game.Args)

                // Special handling for NetHack to add username after -u
                if game.ID == "nethack" </span><span class="cov0" title="0">{
                        for i, arg := range args </span><span class="cov0" title="0">{
                                if arg == "-u" &amp;&amp; i+1 &lt; len(args) </span><span class="cov0" title="0">{
                                        // Username should already be there, but if it's not, add it
                                        if args[i+1] == "" || args[i+1] == "-u" </span><span class="cov0" title="0">{
                                                args[i+1] = sessionCtx.Username
                                        }</span>
                                } else<span class="cov0" title="0"> if arg == "-u" &amp;&amp; i+1 &gt;= len(args) </span><span class="cov0" title="0">{
                                        // Add username after -u
                                        args = append(args, sessionCtx.Username)
                                }</span>
                        }
                        // If no -u flag found, add it with username
                        <span class="cov0" title="0">hasUserFlag := false
                        for _, arg := range args </span><span class="cov0" title="0">{
                                if arg == "-u" </span><span class="cov0" title="0">{
                                        hasUserFlag = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !hasUserFlag </span><span class="cov0" title="0">{
                                args = append(args, "-u", sessionCtx.Username)
                        }</span>
                }

                <span class="cov0" title="0">return game.Binary, args</span>
        }

        // Fallback to predefined game commands
        <span class="cov0" title="0">switch game.ID </span>{
        case "nethack":<span class="cov0" title="0">
                return "/usr/games/nethack", []string{"-u", sessionCtx.Username}</span>
        case "dcss", "crawl":<span class="cov0" title="0">
                return "/usr/games/crawl", []string{}</span>
        case "bash":<span class="cov0" title="0">
                return "/bin/bash", []string{"-l"}</span>
        case "nano":<span class="cov0" title="0">
                return "/usr/bin/nano", []string{}</span>
        default:<span class="cov0" title="0">
                // Default to a simple shell
                return "/bin/bash", []string{"-c", fmt.Sprintf("echo 'Welcome to %s!'; /bin/bash", game.Name)}</span>
        }
}

// bridgeGameIO bridges I/O between SSH session and game PTY, with spectator broadcasting
func (s *SSHServer) bridgeGameIO(ctx context.Context, sessionCtx *SSHSessionContext, ptySession *PTYSession, gameSession *Session) error <span class="cov0" title="0">{
        // Create channels for coordination
        done := make(chan error, 2)

        // Start input forwarding (SSH -&gt; PTY)
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                log.Printf("Panic in input forwarding: %v", r)
                        }</span>
                }()

                <span class="cov0" title="0">buffer := make([]byte, 1024)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                done &lt;- ctx.Err()
                                return</span>
                        case &lt;-sessionCtx.done:<span class="cov0" title="0">
                                done &lt;- nil
                                return</span>
                        default:<span class="cov0" title="0">
                                n, err := sessionCtx.Channel.Read(buffer)
                                if err != nil </span><span class="cov0" title="0">{
                                        if err == io.EOF </span><span class="cov0" title="0">{
                                                done &lt;- nil
                                                return
                                        }</span>
                                        <span class="cov0" title="0">done &lt;- err
                                        return</span>
                                }

                                // Update metrics
                                <span class="cov0" title="0">sessionCtx.BytesRead += int64(n)
                                sessionCtx.LastActivity = time.Now()

                                // Check for exit signals
                                if n == 1 &amp;&amp; buffer[0] == 3 </span><span class="cov0" title="0">{ // Ctrl+C
                                        s.writeToSession(sessionCtx, "\r\nExiting game...\r\n")
                                        _ = ptySession.SendSignal(syscall.SIGTERM)
                                        done &lt;- nil
                                        return
                                }</span>

                                // Forward to PTY
                                <span class="cov0" title="0">if err := ptySession.SendInput(buffer[:n]); err != nil </span><span class="cov0" title="0">{
                                        done &lt;- err
                                        return
                                }</span>
                        }
                }
        }()

        // Start output forwarding (PTY -&gt; SSH)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                log.Printf("Panic in output forwarding: %v", r)
                        }</span>
                }()

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                done &lt;- ctx.Err()
                                return</span>
                        case &lt;-sessionCtx.done:<span class="cov0" title="0">
                                done &lt;- nil
                                return</span>
                        default:<span class="cov0" title="0">
                                data, err := ptySession.ReadOutput()
                                if err != nil </span><span class="cov0" title="0">{
                                        if err == io.EOF </span><span class="cov0" title="0">{
                                                done &lt;- nil
                                                return
                                        }</span>
                                        <span class="cov0" title="0">done &lt;- err
                                        return</span>
                                }

                                <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Forward to SSH (the player)
                                <span class="cov0" title="0">if _, err := sessionCtx.Channel.Write(data); err != nil </span><span class="cov0" title="0">{
                                        done &lt;- err
                                        return
                                }</span>

                                // Broadcast to spectators using immutable data sharing
                                <span class="cov0" title="0">if gameSession != nil </span><span class="cov0" title="0">{
                                        if err := s.sessionService.WriteToSession(ctx, gameSession.ID, data); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Failed to broadcast to spectators for session %s: %v", gameSession.ID, err)
                                                // Don't fail the whole game if spectator broadcasting fails
                                        }</span>
                                }

                                // Update metrics
                                <span class="cov0" title="0">sessionCtx.BytesWritten += int64(len(data))
                                sessionCtx.LastActivity = time.Now()</span>
                        }
                }
        }()

        // Wait for completion
        <span class="cov0" title="0">err := &lt;-done

        // Clean up
        if sessionCtx.ptySession != nil </span><span class="cov0" title="0">{
                sessionCtx.ptySession.Close()
                // Also release the PTY from the manager
                _ = s.ptyManager.ReleasePTY(sessionCtx.SessionID)
                sessionCtx.ptySession = nil
        }</span>

        <span class="cov0" title="0">s.writeToSession(sessionCtx, "\r\nGame session ended. Press any key to continue...\r\n")
        s.waitForKeypress(sessionCtx)

        return err</span>
}

// handleWatchGames handles game spectating
func (s *SSHServer) handleWatchGames(ctx context.Context, sessionCtx *SSHSessionContext) bool <span class="cov0" title="0">{
        activeSessions, err := s.sessionService.GetActiveSessions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, "Error retrieving active games.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">if len(activeSessions) == 0 </span><span class="cov0" title="0">{
                s.clearScreen(sessionCtx)
                s.writeToSession(sessionCtx, "\r\n")
                s.writeToSession(sessionCtx, "                                  Watch Games                                 \r\n")
                s.writeToSession(sessionCtx, "\r\n\r\n")
                s.writeToSession(sessionCtx, "No active games to watch.\r\n\r\n")
                s.writeToSession(sessionCtx, "Press any key to continue...")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">s.clearScreen(sessionCtx)

        // Get terminal width for proper formatting
        terminalWidth := 80
        if sessionCtx.WindowSize != nil </span><span class="cov0" title="0">{
                terminalWidth = int(sessionCtx.WindowSize.Width)
        }</span>

        // Load and display the watch menu banner
        <span class="cov0" title="0">bannerPath := s.getBannerPath("watch_menu")
        banner := s.loadWatchMenuBanner(bannerPath, terminalWidth, activeSessions)
        if banner != "" </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, banner)
        }</span> else<span class="cov0" title="0"> {
                // Fallback banner
                s.writeToSession(sessionCtx, "\r\n")
                s.writeToSession(sessionCtx, "                                  Watch Games                                 \r\n")
                s.writeToSession(sessionCtx, "\r\n\r\n")
                s.writeToSession(sessionCtx, "The following games are in progress:\r\n\r\n")
                s.writeToSession(sessionCtx, "     Username         Game    Size     Start date &amp; time     Idle time  Watch\r\n")
        }</span>

        // Display session list with proper formatting
        <span class="cov0" title="0">s.displayWatchGamesList(sessionCtx, activeSessions)

        s.writeToSession(sessionCtx, fmt.Sprintf("\r\n(%d-%d of %d)\r\n\r\n", 1, len(activeSessions), len(activeSessions)))
        s.writeToSession(sessionCtx, "Watch which game? ('?' for help) =&gt; ")

        choice, err := s.readUserInput(sessionCtx)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Handle special commands
        <span class="cov0" title="0">if choice == "?" </span><span class="cov0" title="0">{
                s.showWatchHelp(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">if choice == "q" || choice == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Convert letter choice to index (a=0, b=1, etc.)
        <span class="cov0" title="0">if len(choice) == 1 &amp;&amp; choice[0] &gt;= 'a' &amp;&amp; choice[0] &lt;= 'z' </span><span class="cov0" title="0">{
                sessionIndex := int(choice[0] - 'a')
                if sessionIndex &gt;= 0 &amp;&amp; sessionIndex &lt; len(activeSessions) </span><span class="cov0" title="0">{
                        selectedSession := activeSessions[sessionIndex]
                        return s.startSpectating(ctx, sessionCtx, selectedSession)
                }</span>
        }

        <span class="cov0" title="0">s.writeToSession(sessionCtx, "Invalid choice. Please try again.\r\n")
        s.waitForKeypress(sessionCtx)
        return true</span>
}

// loadWatchMenuBanner loads the watch menu banner and processes it
func (s *SSHServer) loadWatchMenuBanner(bannerPath string, terminalWidth int, sessions []*Session) string <span class="cov0" title="0">{
        if bannerPath == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Read banner file
        <span class="cov0" title="0">content, err := os.ReadFile(bannerPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to read watch menu banner file %s: %v", bannerPath, err)
                return ""
        }</span>

        <span class="cov0" title="0">bannerText := string(content)

        // Resize banner to fit terminal width
        resizedBanner := s.resizeBanner(bannerText, terminalWidth)

        return resizedBanner + "\r\n"</span>
}

// displayWatchGamesList displays the formatted list of active games
func (s *SSHServer) displayWatchGamesList(sessionCtx *SSHSessionContext, sessions []*Session) <span class="cov0" title="0">{
        for i, session := range sessions </span><span class="cov0" title="0">{
                // Format: a) Username Game Size Start date &amp; time Idle time Watchers
                letter := string(rune('a' + i))

                // Truncate username to fit in column
                username := session.Username
                if len(username) &gt; 15 </span><span class="cov0" title="0">{
                        username = username[:12] + "..."
                }</span>

                // Map game IDs to short names
                <span class="cov0" title="0">gameDisplay := session.GameID
                switch session.GameID </span>{
                case "nethack":<span class="cov0" title="0">
                        gameDisplay = "NH370"</span>
                case "dcss", "crawl":<span class="cov0" title="0">
                        gameDisplay = "DCSS"</span>
                case "bash":<span class="cov0" title="0">
                        gameDisplay = "SHELL"</span>
                }

                // Get terminal size
                <span class="cov0" title="0">termSize := session.TerminalSize
                if termSize == "" </span><span class="cov0" title="0">{
                        termSize = "80x24"
                }</span>

                // Calculate time since start and idle time
                <span class="cov0" title="0">startTime := session.StartTime.Format("2006-01-02 15:04:05")
                idleTime := ""
                if time.Since(session.LastActivity) &gt; time.Minute </span><span class="cov0" title="0">{
                        idle := time.Since(session.LastActivity)
                        if idle &gt; time.Hour </span><span class="cov0" title="0">{
                                idleTime = fmt.Sprintf("%dh %dm", int(idle.Hours()), int(idle.Minutes())%60)
                        }</span> else<span class="cov0" title="0"> if idle &gt; time.Minute </span><span class="cov0" title="0">{
                                idleTime = fmt.Sprintf("%dm %ds", int(idle.Minutes()), int(idle.Seconds())%60)
                        }</span> else<span class="cov0" title="0"> {
                                idleTime = fmt.Sprintf("%ds", int(idle.Seconds()))
                        }</span>
                }

                // Count spectators
                <span class="cov0" title="0">spectatorCount := len(session.Spectators)

                // Format the line with proper spacing
                line := fmt.Sprintf("%s) %-15s %-6s %-8s %s %-10s %d",
                        letter, username, gameDisplay, termSize, startTime, idleTime, spectatorCount)

                s.writeToSession(sessionCtx, line+"\r\n")</span>
        }
}

// showWatchHelp displays help for the watch command
func (s *SSHServer) showWatchHelp(sessionCtx *SSHSessionContext) <span class="cov0" title="0">{
        s.clearScreen(sessionCtx)
        s.writeToSession(sessionCtx, "\r\n")
        s.writeToSession(sessionCtx, "                                Watch Games Help                              \r\n")
        s.writeToSession(sessionCtx, "\r\n\r\n")
        s.writeToSession(sessionCtx, "Commands:\r\n")
        s.writeToSession(sessionCtx, "  a-z    : Watch the corresponding game (e.g., 'a' for first game)\r\n")
        s.writeToSession(sessionCtx, "  q      : Return to main menu\r\n")
        s.writeToSession(sessionCtx, "  ?      : Show this help\r\n")
        s.writeToSession(sessionCtx, "  Enter  : Return to main menu\r\n\r\n")
        s.writeToSession(sessionCtx, "While spectating:\r\n")
        s.writeToSession(sessionCtx, "  Ctrl+C : Stop spectating and return to watch menu\r\n\r\n")
        s.writeToSession(sessionCtx, "Press any key to continue...")
        s.waitForKeypress(sessionCtx)
}</span>

// startSpectating initiates spectating for a selected session
func (s *SSHServer) startSpectating(ctx context.Context, sessionCtx *SSHSessionContext, selectedSession *Session) bool <span class="cov0" title="0">{
        // Get user info for spectator
        userID := 0
        username := "anonymous"
        if sessionCtx.IsAuthenticated &amp;&amp; sessionCtx.AuthenticatedUser != nil </span><span class="cov0" title="0">{
                userID = sessionCtx.AuthenticatedUser.ID
                username = sessionCtx.AuthenticatedUser.Username
        }</span>

        // Create SSH spectator connection
        <span class="cov0" title="0">spectatorConnection := NewSSHSpectatorConnection(sessionCtx)

        // Add spectator with connection
        err := s.sessionService.AddSpectatorWithConnection(ctx, selectedSession.ID, userID, username, spectatorConnection)
        if err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, fmt.Sprintf("Failed to start spectating: %v\r\n", err))
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        // Run spectating loop
        <span class="cov0" title="0">return s.runSpectatorSession(ctx, sessionCtx, selectedSession.ID, userID)</span>
}

// runSpectatorSession handles the spectating session loop
func (s *SSHServer) runSpectatorSession(ctx context.Context, sessionCtx *SSHSessionContext, gameSessionID string, userID int) bool <span class="cov0" title="0">{
        // Create a channel to handle user input for exiting
        exitChan := make(chan struct{})

        // Initialize terminal for spectating
        // Clear screen and set up terminal properly
        s.writeToSession(sessionCtx, "\033[2J\033[H") // Clear screen and home cursor
        s.writeToSession(sessionCtx, "\033[?1049h")   // Switch to alternate screen buffer (like vim/less)

        // Start goroutine to handle user input (Ctrl+C to exit)
        go func() </span><span class="cov0" title="0">{
                buffer := make([]byte, 1)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                n, err := sessionCtx.Channel.Read(buffer)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Spectator input read error for user %d: %v", userID, err)
                                        select </span>{
                                        case exitChan &lt;- struct{}{}:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                }

                                <span class="cov0" title="0">if n &gt; 0 &amp;&amp; n &lt;= len(buffer) </span><span class="cov0" title="0">{
                                        char := buffer[0]
                                        if char == 3 </span><span class="cov0" title="0">{ // Ctrl+C
                                                select </span>{
                                                case exitChan &lt;- struct{}{}:<span class="cov0" title="0"></span>
                                                default:<span class="cov0" title="0"></span>
                                                }
                                                <span class="cov0" title="0">return</span>
                                        }
                                        // Ignore other input while spectating
                                }
                        }
                }
        }()

        // Note: The actual game data is being written directly to sessionCtx.Channel
        // by the SSHSpectatorConnection.Write() method, so we just need to wait
        // for the user to exit

        // Wait for exit signal or context cancellation
        <span class="cov0" title="0">var exitReason string
        select </span>{
        case &lt;-exitChan:<span class="cov0" title="0">
                exitReason = "user_exit"
                // Restore terminal state
                s.writeToSession(sessionCtx, "\033[?1049l")   // Switch back from alternate screen buffer
                s.writeToSession(sessionCtx, "\033[2J\033[H") // Clear screen
                s.writeToSession(sessionCtx, "Exiting spectator mode...\r\n")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                exitReason = "context_cancelled"
                // Restore terminal state
                s.writeToSession(sessionCtx, "\033[?1049l")   // Switch back from alternate screen buffer
                s.writeToSession(sessionCtx, "\033[2J\033[H") // Clear screen
                s.writeToSession(sessionCtx, "Connection terminated.\r\n")</span>
        }

        // Always attempt to remove spectator with retry logic
        <span class="cov0" title="0">const maxCleanupRetries = 3
        var cleanupErr error
        for i := 0; i &lt; maxCleanupRetries; i++ </span><span class="cov0" title="0">{
                cleanupErr = s.sessionService.RemoveSpectator(ctx, gameSessionID, userID)
                if cleanupErr == nil </span><span class="cov0" title="0">{
                        log.Printf("Successfully removed spectator %d from session %s (exit reason: %s)", userID, gameSessionID, exitReason)
                        break</span>
                }
                <span class="cov0" title="0">log.Printf("Failed to remove spectator %d from session %s (attempt %d/%d): %v", userID, gameSessionID, i+1, maxCleanupRetries, cleanupErr)
                if i &lt; maxCleanupRetries-1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(100*(i+1)) * time.Millisecond)
                }</span>
        }

        <span class="cov0" title="0">if cleanupErr != nil </span><span class="cov0" title="0">{
                log.Printf("CRITICAL: Failed to remove spectator %d from session %s after %d attempts: %v", userID, gameSessionID, maxCleanupRetries, cleanupErr)
        }</span>

        <span class="cov0" title="0">s.writeToSession(sessionCtx, "Press any key to continue...")
        s.waitForKeypress(sessionCtx)

        return true</span>
}

// handleListGames handles game listing
func (s *SSHServer) handleListGames(ctx context.Context, sessionCtx *SSHSessionContext) bool <span class="cov0" title="0">{
        games, err := s.gameClient.ListGames(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, "Error retrieving games.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">s.clearScreen(sessionCtx)
        s.writeToSession(sessionCtx, "=== Available Games ===\r\n\r\n")

        if len(games) == 0 </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, "No games configured.\r\n")
        }</span> else<span class="cov0" title="0"> {
                for _, game := range games </span><span class="cov0" title="0">{
                        status := " Disabled"
                        if game.Enabled </span><span class="cov0" title="0">{
                                status = " Available"
                        }</span>
                        <span class="cov0" title="0">s.writeToSession(sessionCtx, fmt.Sprintf("%-20s %s\r\n", game.Name, status))
                        if game.Description != "" </span><span class="cov0" title="0">{
                                s.writeToSession(sessionCtx, fmt.Sprintf("    %s\r\n", game.Description))
                        }</span>
                        <span class="cov0" title="0">s.writeToSession(sessionCtx, "\r\n")</span>
                }
        }

        <span class="cov0" title="0">s.writeToSession(sessionCtx, "\r\nPress any key to continue...")
        s.waitForKeypress(sessionCtx)

        return true</span>
}

// handleEditProfile handles profile editing
func (s *SSHServer) handleEditProfile(ctx context.Context, sessionCtx *SSHSessionContext) bool <span class="cov0" title="0">{
        s.clearScreen(sessionCtx)
        s.writeToSession(sessionCtx, "=== Edit Profile ===\r\n\r\n")
        s.writeToSession(sessionCtx, "Profile editing not yet implemented.\r\n")
        s.waitForKeypress(sessionCtx)
        return true
}</span>

// handleViewRecordings handles recording viewing
func (s *SSHServer) handleViewRecordings(ctx context.Context, sessionCtx *SSHSessionContext) bool <span class="cov0" title="0">{
        s.clearScreen(sessionCtx)
        s.writeToSession(sessionCtx, "=== View Recordings ===\r\n\r\n")
        s.writeToSession(sessionCtx, "Recording viewing not yet implemented.\r\n")
        s.waitForKeypress(sessionCtx)
        return true
}</span>

// handleStatistics handles statistics viewing
func (s *SSHServer) handleStatistics(ctx context.Context, sessionCtx *SSHSessionContext) bool <span class="cov0" title="0">{
        s.clearScreen(sessionCtx)
        s.writeToSession(sessionCtx, "=== Statistics ===\r\n\r\n")

        // Get system metrics
        metrics := s.sessionService.GetMetrics()
        sshMetrics := s.GetMetrics()

        s.writeToSession(sessionCtx, "System Statistics:\r\n")
        s.writeToSession(sessionCtx, fmt.Sprintf("  Active Sessions: %d\r\n", metrics.ActiveSessions))
        s.writeToSession(sessionCtx, fmt.Sprintf("  Total Sessions: %d\r\n", metrics.TotalSessions))
        s.writeToSession(sessionCtx, fmt.Sprintf("  Active Spectators: %d\r\n", metrics.ActiveSpectators))
        s.writeToSession(sessionCtx, fmt.Sprintf("  Total Spectators: %d\r\n", metrics.TotalSpectators))
        s.writeToSession(sessionCtx, fmt.Sprintf("  Bytes Transferred: %d\r\n", metrics.BytesTransferred))
        s.writeToSession(sessionCtx, fmt.Sprintf("  Uptime: %d seconds\r\n", metrics.UptimeSeconds))

        s.writeToSession(sessionCtx, "\r\nSSH Statistics:\r\n")
        s.writeToSession(sessionCtx, fmt.Sprintf("  Total Connections: %d\r\n", sshMetrics.TotalConnections))
        s.writeToSession(sessionCtx, fmt.Sprintf("  Active Connections: %d\r\n", sshMetrics.ActiveConnections))
        s.writeToSession(sessionCtx, fmt.Sprintf("  Failed Connections: %d\r\n", sshMetrics.FailedConnections))
        s.writeToSession(sessionCtx, fmt.Sprintf("  Total Sessions: %d\r\n", sshMetrics.TotalSessions))
        s.writeToSession(sessionCtx, fmt.Sprintf("  Active Sessions: %d\r\n", sshMetrics.ActiveSessions))

        s.writeToSession(sessionCtx, "\r\nPress any key to continue...")
        s.waitForKeypress(sessionCtx)
        return true
}</span>

// Utility functions

// readLineInput reads a line of input from the SSH session
func (s *SSHServer) readLineInput(sessionCtx *SSHSessionContext) (string, error) <span class="cov0" title="0">{
        var line strings.Builder
        buffer := make([]byte, 1)

        for </span><span class="cov0" title="0">{
                n, err := sessionCtx.Channel.Read(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sessionCtx.BytesRead += int64(n)
                sessionCtx.LastActivity = time.Now()

                char := buffer[0]

                switch char </span>{
                case '\r', '\n':<span class="cov0" title="0">
                        // End of input
                        s.writeToSession(sessionCtx, "\r\n")
                        return line.String(), nil</span>
                case '\b', 127:<span class="cov0" title="0"> // Backspace
                        if line.Len() &gt; 0 </span><span class="cov0" title="0">{
                                lineStr := line.String()
                                line.Reset()
                                line.WriteString(lineStr[:len(lineStr)-1])
                                s.writeToSession(sessionCtx, "\b \b")
                        }</span>
                case 3:<span class="cov0" title="0"> // Ctrl+C
                        return "", fmt.Errorf("interrupted")</span>
                default:<span class="cov0" title="0">
                        line.WriteByte(char)
                        s.writeToSession(sessionCtx, string(char))</span>
                }
        }
}

// writeToSession writes data to the SSH session
func (s *SSHServer) writeToSession(sessionCtx *SSHSessionContext, data string) <span class="cov8" title="1">{
        if sessionCtx.Channel == nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Attempting to write to session %s with nil channel", sessionCtx.SessionID)
                return
        }</span>
        <span class="cov8" title="1">if _, err := sessionCtx.Channel.Write([]byte(data)); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error writing to session %s: %v", sessionCtx.SessionID, err)
        }</span>
        <span class="cov8" title="1">sessionCtx.BytesWritten += int64(len(data))
        sessionCtx.LastActivity = time.Now()</span>
}

// clearScreen clears the terminal screen
func (s *SSHServer) clearScreen(sessionCtx *SSHSessionContext) <span class="cov0" title="0">{
        s.writeToSession(sessionCtx, "\033[2J\033[H")
}</span>

// waitForKeypress waits for a keypress
func (s *SSHServer) waitForKeypress(sessionCtx *SSHSessionContext) <span class="cov8" title="1">{
        buffer := make([]byte, 1)
        _, _ = sessionCtx.Channel.Read(buffer)
        sessionCtx.LastActivity = time.Now()
}</span>

// Authentication handlers

// handlePasswordAuth handles password authentication
func (s *SSHServer) handlePasswordAuth(conn ssh.ConnMetadata, password []byte) (*ssh.Permissions, error) <span class="cov8" title="1">{
        // Allow all connections - we handle authentication in the menu
        return &amp;ssh.Permissions{}, nil
}</span>

// handlePublicKeyAuth handles public key authentication
func (s *SSHServer) handlePublicKeyAuth(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) <span class="cov8" title="1">{
        // TODO: Implement public key authentication
        return nil, fmt.Errorf("public key authentication not implemented")
}</span>

// handleBanner returns the SSH banner
func (s *SSHServer) handleBanner(conn ssh.ConnMetadata) string <span class="cov8" title="1">{
        if s.config != nil &amp;&amp; s.config.SSH != nil </span><span class="cov8" title="1">{
                return s.config.SSH.Banner
        }</span>
        <span class="cov0" title="0">return "Welcome to DungeonGate!\r\n"</span>
}

// Host key management

// loadOrGenerateHostKey loads or generates SSH host key
func (s *SSHServer) loadOrGenerateHostKey() (ssh.Signer, error) <span class="cov8" title="1">{
        // Use configured path, which already has a default value from config
        keyPath := s.config.SSH.HostKeyPath
        if keyPath == "" </span><span class="cov0" title="0">{
                // This should never happen as config provides defaults, but just in case
                keyPath = "./ssh_host_rsa_key"
        }</span>

        // Try to load existing key
        <span class="cov8" title="1">if _, err := os.Stat(keyPath); err == nil </span><span class="cov8" title="1">{
                keyData, err := os.ReadFile(keyPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read host key: %w", err)
                }</span>

                <span class="cov8" title="1">key, err := ssh.ParsePrivateKey(keyData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse host key: %w", err)
                }</span>

                <span class="cov8" title="1">log.Printf("Loaded SSH host key from %s", keyPath)
                return key, nil</span>
        }

        // Generate new key
        <span class="cov8" title="1">log.Printf("Generating new SSH host key at %s", keyPath)
        return s.generateHostKey(keyPath)</span>
}

// generateHostKey generates a new SSH host key
func (s *SSHServer) generateHostKey(keyPath string) (ssh.Signer, error) <span class="cov8" title="1">{
        // Generate RSA key
        key, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate RSA key: %w", err)
        }</span>

        // Convert to PEM format
        <span class="cov8" title="1">keyPEM := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(key),
        }

        // Create directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(keyPath), 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Write private key to file
        <span class="cov8" title="1">keyFile, err := os.OpenFile(keyPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create key file: %w", err)
        }</span>
        <span class="cov8" title="1">defer keyFile.Close()

        if err := pem.Encode(keyFile, keyPEM); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write key file: %w", err)
        }</span>

        // Convert to SSH signer
        <span class="cov8" title="1">signer, err := ssh.NewSignerFromKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create signer: %w", err)
        }</span>

        <span class="cov8" title="1">return signer, nil</span>
}

// Background services

// startMetricsCollection starts metrics collection
func (s *SSHServer) startMetricsCollection(ctx context.Context) <span class="cov8" title="1">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        s.metrics.mutex.RLock()
                        log.Printf("SSH Metrics: total_conn=%d active_conn=%d failed_conn=%d total_sess=%d active_sess=%d",
                                s.metrics.TotalConnections, s.metrics.ActiveConnections, s.metrics.FailedConnections,
                                s.metrics.TotalSessions, s.metrics.ActiveSessions)
                        s.metrics.mutex.RUnlock()</span>
                }
        }
}

// startConnectionCleanup starts connection cleanup
func (s *SSHServer) startConnectionCleanup(ctx context.Context) <span class="cov8" title="1">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        s.cleanupIdleConnections()</span>
                }
        }
}

// cleanupIdleConnections cleans up idle connections
func (s *SSHServer) cleanupIdleConnections() <span class="cov8" title="1">{
        s.connectionsMux.Lock()
        defer s.connectionsMux.Unlock()

        now := time.Now()
        idleTimeout := 30 * time.Minute

        for connID, conn := range s.connections </span><span class="cov0" title="0">{
                if now.Sub(conn.LastActivity) &gt; idleTimeout </span><span class="cov0" title="0">{
                        log.Printf("Cleaning up idle connection: %s", connID)

                        // Close all sessions in this connection
                        conn.sessionsMux.Lock()
                        for sessionID, session := range conn.Sessions </span><span class="cov0" title="0">{
                                log.Printf("Closing idle session: %s", sessionID)
                                close(session.done)
                        }</span>
                        <span class="cov0" title="0">conn.sessionsMux.Unlock()

                        delete(s.connections, connID)</span>
                }
        }
}

// Utility functions for ID generation

// generateConnectionID generates a unique connection ID
func generateConnectionID() string <span class="cov0" title="0">{
        return fmt.Sprintf("conn_%d_%d", time.Now().UnixNano(), rand2.Int63n(10000))
}</span>

// generateSSHSessionID generates a unique SSH session ID
func generateSSHSessionID() string <span class="cov0" title="0">{
        return fmt.Sprintf("ssh_sess_%d_%d", time.Now().UnixNano(), rand2.Int63n(10000))
}</span>

// GetMetrics returns SSH server metrics
func (s *SSHServer) GetMetrics() *SSHMetrics <span class="cov8" title="1">{
        s.metrics.mutex.RLock()
        defer s.metrics.mutex.RUnlock()

        return &amp;SSHMetrics{
                TotalConnections:  s.metrics.TotalConnections,
                ActiveConnections: s.metrics.ActiveConnections,
                FailedConnections: s.metrics.FailedConnections,
                TotalSessions:     s.metrics.TotalSessions,
                ActiveSessions:    s.metrics.ActiveSessions,
                BytesTransferred:  s.metrics.BytesTransferred,
        }
}</span>

// GetActiveConnections returns active connection information
func (s *SSHServer) GetActiveConnections() map[string]*SSHConnection <span class="cov8" title="1">{
        s.connectionsMux.RLock()
        defer s.connectionsMux.RUnlock()

        result := make(map[string]*SSHConnection)
        for id, conn := range s.connections </span><span class="cov0" title="0">{
                result[id] = conn
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Shutdown gracefully shuts down the SSH server
func (s *SSHServer) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        log.Println("Shutting down SSH server...")

        // Close all active connections
        s.connectionsMux.Lock()
        for connID, conn := range s.connections </span><span class="cov0" title="0">{
                log.Printf("Closing connection: %s", connID)

                conn.sessionsMux.Lock()
                for sessionID, session := range conn.Sessions </span><span class="cov0" title="0">{
                        log.Printf("Closing session: %s", sessionID)
                        close(session.done)
                }</span>
                <span class="cov0" title="0">conn.sessionsMux.Unlock()</span>
        }
        <span class="cov8" title="1">s.connectionsMux.Unlock()

        // Clean up PTY manager
        if s.ptyManager != nil </span><span class="cov8" title="1">{
                s.ptyManager.Shutdown()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// handleNetHackGame handles NetHack with auto-load/new game logic
func (s *SSHServer) handleNetHackGame(ctx context.Context, sessionCtx *SSHSessionContext, game *Game) bool <span class="cov0" title="0">{
        // Initialize save manager
        saveManager := NewSaveManager("/tmp/nethack-saves")

        // Check if user has an existing save
        userSave, err := saveManager.GetUserSave(sessionCtx.Username, "nethack")
        if err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, fmt.Sprintf("Error checking save data: %v\r\n", err))
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">if userSave.HasSave </span><span class="cov0" title="0">{
                // Auto-load existing save
                size := fmt.Sprintf("%.1f KB", float64(userSave.FileSize)/1024)
                hashInfo := ""
                if userSave.SaveHash != "" </span><span class="cov0" title="0">{
                        hashInfo = fmt.Sprintf(" [%s]", userSave.SaveHash)
                }</span>
                <span class="cov0" title="0">s.writeToSession(sessionCtx, fmt.Sprintf("Loading your NetHack game... (%s%s, last played: %s)\r\n",
                        size, hashInfo, userSave.UpdatedAt.Format("2006-01-02 15:04:05")))</span>
        } else<span class="cov0" title="0"> {
                // Start new game
                s.writeToSession(sessionCtx, "Starting new NetHack game...\r\n")
        }</span>

        // Start NetHack
        <span class="cov0" title="0">return s.startNetHackWithSave(ctx, sessionCtx, game)</span>
}

// startNetHackWithSave starts NetHack with proper save environment setup
func (s *SSHServer) startNetHackWithSave(ctx context.Context, sessionCtx *SSHSessionContext, game *Game) bool <span class="cov0" title="0">{
        saveManager := NewSaveManager("/tmp/nethack-saves")

        // Get save environment for this user
        saveEnv, err := saveManager.PrepareUserSaveEnvironment(sessionCtx.Username, "nethack")
        if err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, fmt.Sprintf("Failed to prepare save environment: %v\r\n", err))
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        // Update game environment with save-specific settings
        <span class="cov0" title="0">gameWithSave := *game
        if gameWithSave.Environment == nil </span><span class="cov0" title="0">{
                gameWithSave.Environment = make(map[string]string)
        }</span>

        // Merge save environment
        <span class="cov0" title="0">for key, value := range saveEnv </span><span class="cov0" title="0">{
                gameWithSave.Environment[key] = value
        }</span>

        // Create game session
        <span class="cov0" title="0">var userID int
        var username string
        if sessionCtx.IsAuthenticated &amp;&amp; sessionCtx.AuthenticatedUser != nil </span><span class="cov0" title="0">{
                userID = sessionCtx.AuthenticatedUser.ID
                username = sessionCtx.AuthenticatedUser.Username
        }</span> else<span class="cov0" title="0"> {
                userID = 0                     // Anonymous user
                username = sessionCtx.Username // Use the session username
        }</span>

        <span class="cov0" title="0">gameSession, err := s.sessionService.CreateSession(ctx, &amp;CreateSessionRequest{
                UserID:       userID,
                Username:     username,
                GameID:       gameWithSave.ID,
                TerminalSize: fmt.Sprintf("%dx%d", sessionCtx.WindowSize.Width, sessionCtx.WindowSize.Height),
                Encoding:     "utf-8",
        })
        if err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, fmt.Sprintf("Failed to create game session: %v\r\n", err))
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        // Start game in PTY
        <span class="cov0" title="0">err = s.startGameInPTY(ctx, sessionCtx, &amp;gameWithSave, gameSession)
        if err != nil </span><span class="cov0" title="0">{
                // Check if this is just a normal game exit
                if err == io.EOF || err.Error() == "PTY session has ended" || strings.Contains(err.Error(), "has ended") </span><span class="cov0" title="0">{
                        // Game ended normally, this is not an error
                        log.Printf("NetHack game ended normally for user %s", sessionCtx.Username)
                }</span> else<span class="cov0" title="0"> {
                        s.writeToSession(sessionCtx, fmt.Sprintf("Failed to start game: %v\r\n", err))
                        s.waitForKeypress(sessionCtx)
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">return true</span>
}

// handleResetSave handles resetting a user's NetHack save
func (s *SSHServer) handleResetSave(ctx context.Context, sessionCtx *SSHSessionContext) bool <span class="cov0" title="0">{
        saveManager := NewSaveManager("/tmp/nethack-saves")

        s.clearScreen(sessionCtx)
        s.writeToSession(sessionCtx, "=== Reset NetHack Save ===\r\n\r\n")

        // Check if user has an existing save
        userSave, err := saveManager.GetUserSave(sessionCtx.Username, "nethack")
        if err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, fmt.Sprintf("Error checking save data: %v\r\n", err))
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">if !userSave.HasSave </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, "You don't have any NetHack save data to reset.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        // Show save info and confirm deletion
        <span class="cov0" title="0">size := fmt.Sprintf("%.1f KB", float64(userSave.FileSize)/1024)
        hashInfo := ""
        if userSave.SaveHash != "" </span><span class="cov0" title="0">{
                hashInfo = fmt.Sprintf(" (Hash: %s)", userSave.SaveHash)
        }</span>

        <span class="cov0" title="0">s.writeToSession(sessionCtx, fmt.Sprintf("Current save: %s%s\r\n", size, hashInfo))
        s.writeToSession(sessionCtx, fmt.Sprintf("Last played: %s\r\n", userSave.UpdatedAt.Format("2006-01-02 15:04:05")))
        s.writeToSession(sessionCtx, fmt.Sprintf("Save file: %s\r\n\r\n", userSave.SavePath))

        s.writeToSession(sessionCtx, "  WARNING: This will permanently delete your NetHack save game! \r\n")
        s.writeToSession(sessionCtx, "This action cannot be undone. A backup will be created first.\r\n\r\n")
        s.writeToSession(sessionCtx, "Type 'DELETE' to confirm or anything else to cancel: ")

        choice, err := s.readLineInput(sessionCtx)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">choice = strings.TrimSpace(choice)
        if choice != "DELETE" </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, "Reset cancelled.\r\n")
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        // Create backup before deletion
        <span class="cov0" title="0">s.writeToSession(sessionCtx, "Creating backup...\r\n")
        if err := saveManager.BackupUserSave(sessionCtx.Username, "nethack"); err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, fmt.Sprintf("Warning: Failed to create backup: %v\r\n", err))
        }</span>

        // Delete the save
        <span class="cov0" title="0">s.writeToSession(sessionCtx, "Deleting save data...\r\n")
        if err := saveManager.DeleteUserSave(sessionCtx.Username, "nethack"); err != nil </span><span class="cov0" title="0">{
                s.writeToSession(sessionCtx, fmt.Sprintf("Error deleting save: %v\r\n", err))
                s.waitForKeypress(sessionCtx)
                return true
        }</span>

        <span class="cov0" title="0">s.writeToSession(sessionCtx, "NetHack save has been reset! You can now start a fresh game.\r\n")
        s.waitForKeypress(sessionCtx)
        return true</span>
}

// getMaxLoginAttempts returns the maximum login attempts from config
// getMaxLoginAttempts returns the maximum login attempts from config
// getMaxLoginAttemptsWithDefault returns the maximum login attempts from config with default handling
func (s *SSHServer) getMaxLoginAttemptsWithDefault() int <span class="cov8" title="1">{
        if s.config != nil &amp;&amp; s.config.User != nil &amp;&amp; s.config.User.LoginAttempts != nil </span><span class="cov8" title="1">{
                if s.config.User.LoginAttempts.MaxAttempts &gt; 0 </span><span class="cov8" title="1">{
                        return s.config.User.LoginAttempts.MaxAttempts
                }</span>
        }
        <span class="cov8" title="1">return 3</span> // Default to 3 attempts
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package session

import (
        "context"
        "fmt"
        "log"
        "sync"
        "sync/atomic"
        "time"

        "github.com/dungeongate/pkg/config"
        "github.com/dungeongate/pkg/ttyrec"
)

// Core data structures

// User represents a user in the system
type User struct {
        ID              int       `json:"id"`
        Username        string    `json:"username"`
        Email           string    `json:"email,omitempty"`
        IsAuthenticated bool      `json:"is_authenticated"`
        IsActive        bool      `json:"is_active"`
        IsAdmin         bool      `json:"is_admin"`
        CreatedAt       time.Time `json:"created_at"`
        UpdatedAt       time.Time `json:"updated_at"`
        LastLogin       time.Time `json:"last_login"`
}

// Game represents a game configuration
type Game struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        ShortName   string            `json:"short_name"`
        Description string            `json:"description"`
        Enabled     bool              `json:"enabled"`
        Binary      string            `json:"binary"`
        Args        []string          `json:"args"`
        WorkingDir  string            `json:"working_dir"`
        Environment map[string]string `json:"environment"`
        MaxPlayers  int               `json:"max_players"`
        Spectatable bool              `json:"spectatable"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
}

// Session represents a game session
type Session struct {
        ID            string                             `json:"id"`
        UserID        int                                `json:"user_id"`
        Username      string                             `json:"username"`
        GameID        string                             `json:"game_id"`
        StartTime     time.Time                          `json:"start_time"`
        EndTime       *time.Time                         `json:"end_time,omitempty"`
        IsActive      bool                               `json:"is_active"`
        TTYRecording  *ttyrec.Session                    `json:"-"`
        TerminalSize  string                             `json:"terminal_size"`
        Encoding      string                             `json:"encoding"`
        LastActivity  time.Time                          `json:"last_activity"`
        StreamEnabled bool                               `json:"stream_enabled"`
        Encrypted     bool                               `json:"encrypted"`
        Spectators    []*Spectator                       `json:"spectators,omitempty"` // For JSON serialization (legacy)
        Registry      *atomic.Pointer[SpectatorRegistry] `json:"-"`                    // Immutable spectator registry
        StreamManager *StreamManager                     `json:"-"`                    // Handles immutable data streaming
        ProcessPID    int                                `json:"process_pid,omitempty"`
        ExitCode      int                                `json:"exit_code,omitempty"`
}

// StreamManager handles immutable data streaming to spectators
type StreamManager struct {
        frameID      atomic.Uint64
        frameChannel chan *StreamFrame
        stopChan     chan struct{}
        wg           sync.WaitGroup

        // Circular buffer for recent frames
        recentFrames     []*StreamFrame
        recentFramesLock sync.RWMutex
        bufferSize       int
        bufferIndex      int
}

// NewStreamManager creates a new stream manager for a session
func NewStreamManager() *StreamManager <span class="cov0" title="0">{
        const defaultBufferSize = 20 // Keep last 20 frames
        return &amp;StreamManager{
                frameChannel: make(chan *StreamFrame, 1000), // Buffered channel for frames
                stopChan:     make(chan struct{}),
                bufferSize:   defaultBufferSize,
                recentFrames: make([]*StreamFrame, defaultBufferSize),
                bufferIndex:  0,
        }
}</span>

// Start begins the streaming process
func (sm *StreamManager) Start(registry *atomic.Pointer[SpectatorRegistry]) <span class="cov0" title="0">{
        sm.wg.Add(1)
        go sm.streamLoop(registry)
}</span>

// Stop gracefully stops the streaming process
func (sm *StreamManager) Stop() <span class="cov0" title="0">{
        close(sm.stopChan)
        sm.wg.Wait()
}</span>

// SendFrame sends an immutable frame to all spectators
func (sm *StreamManager) SendFrame(data []byte) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">frameID := sm.frameID.Add(1)
        frame := NewStreamFrame(data, frameID)

        select </span>{
        case sm.frameChannel &lt;- frame:<span class="cov0" title="0"></span>
                // Frame queued successfully
        default:<span class="cov0" title="0">
                // Channel full, drop frame (prevents blocking)
                log.Printf("Warning: Dropped frame %d due to full buffer", frameID)</span>
        }
}

// streamLoop processes frames and distributes them to spectators
func (sm *StreamManager) streamLoop(registry *atomic.Pointer[SpectatorRegistry]) <span class="cov0" title="0">{
        defer sm.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case frame := &lt;-sm.frameChannel:<span class="cov0" title="0">
                        sm.distributeFrame(frame, registry)</span>
                case &lt;-sm.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// distributeFrame sends a frame to all active spectators
func (sm *StreamManager) distributeFrame(frame *StreamFrame, registry *atomic.Pointer[SpectatorRegistry]) <span class="cov0" title="0">{
        // Store frame in circular buffer
        sm.recentFramesLock.Lock()
        sm.recentFrames[sm.bufferIndex] = frame
        sm.bufferIndex = (sm.bufferIndex + 1) % sm.bufferSize
        sm.recentFramesLock.Unlock()

        // Load current immutable registry
        currentRegistry := registry.Load()
        if currentRegistry == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Get current spectators (safe concurrent read)
        <span class="cov0" title="0">spectators := currentRegistry.GetSpectators()

        // Send frame to each spectator concurrently
        for _, spectator := range spectators </span><span class="cov0" title="0">{
                if spectator.IsActive &amp;&amp; spectator.Connection != nil &amp;&amp; spectator.Connection.IsConnected() </span><span class="cov0" title="0">{
                        go func(spec *Spectator, f *StreamFrame) </span><span class="cov0" title="0">{
                                if err := spec.Connection.Write(f); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Failed to send frame %d to spectator %s: %v", f.FrameID, spec.Username, err)
                                        // TODO: Mark spectator as inactive or remove
                                }</span>
                        }(spectator, frame)
                }
        }
}

// GetRecentFrames returns the recent frames from the circular buffer
func (sm *StreamManager) GetRecentFrames() []*StreamFrame <span class="cov0" title="0">{
        sm.recentFramesLock.RLock()
        defer sm.recentFramesLock.RUnlock()

        // Collect non-nil frames in order
        frames := make([]*StreamFrame, 0, sm.bufferSize)

        // Start from the oldest frame position
        startIdx := sm.bufferIndex
        for i := 0; i &lt; sm.bufferSize; i++ </span><span class="cov0" title="0">{
                idx := (startIdx + i) % sm.bufferSize
                if sm.recentFrames[idx] != nil </span><span class="cov0" title="0">{
                        frames = append(frames, sm.recentFrames[idx])
                }</span>
        }

        <span class="cov0" title="0">return frames</span>
}

// StreamFrame represents an immutable frame of terminal data
type StreamFrame struct {
        Timestamp time.Time `json:"timestamp"`
        Data      []byte    `json:"data"`     // Immutable copy of terminal data
        FrameID   uint64    `json:"frame_id"` // Sequential frame identifier
}

// NewStreamFrame creates a new immutable stream frame
func NewStreamFrame(data []byte, frameID uint64) *StreamFrame <span class="cov0" title="0">{
        // Create deep copy to ensure immutability
        dataCopy := make([]byte, len(data))
        copy(dataCopy, data)

        return &amp;StreamFrame{
                Timestamp: time.Now(),
                Data:      dataCopy,
                FrameID:   frameID,
        }
}</span>

// SpectatorRegistry represents an immutable list of spectators
type SpectatorRegistry struct {
        Spectators map[string]*Spectator `json:"spectators"` // key: spectator ID
        Version    uint64                `json:"version"`    // Registry version for atomic updates
}

// NewSpectatorRegistry creates a new immutable spectator registry
func NewSpectatorRegistry() *SpectatorRegistry <span class="cov0" title="0">{
        return &amp;SpectatorRegistry{
                Spectators: make(map[string]*Spectator),
                Version:    0,
        }
}</span>

// AddSpectator returns a new registry with the spectator added (immutable)
func (r *SpectatorRegistry) AddSpectator(spectator *Spectator) *SpectatorRegistry <span class="cov0" title="0">{
        newSpectators := make(map[string]*Spectator, len(r.Spectators)+1)

        // Copy existing spectators
        for id, spec := range r.Spectators </span><span class="cov0" title="0">{
                newSpectators[id] = spec
        }</span>

        // Add new spectator
        <span class="cov0" title="0">spectatorID := fmt.Sprintf("%d_%s", spectator.UserID, spectator.Username)
        newSpectators[spectatorID] = spectator

        return &amp;SpectatorRegistry{
                Spectators: newSpectators,
                Version:    r.Version + 1,
        }</span>
}

// RemoveSpectator returns a new registry with the spectator removed (immutable)
func (r *SpectatorRegistry) RemoveSpectator(userID int, username string) *SpectatorRegistry <span class="cov0" title="0">{
        spectatorID := fmt.Sprintf("%d_%s", userID, username)

        // If spectator doesn't exist, return same registry
        if _, exists := r.Spectators[spectatorID]; !exists </span><span class="cov0" title="0">{
                return r
        }</span>

        <span class="cov0" title="0">newSpectators := make(map[string]*Spectator, len(r.Spectators)-1)

        // Copy all except the removed spectator
        for id, spec := range r.Spectators </span><span class="cov0" title="0">{
                if id != spectatorID </span><span class="cov0" title="0">{
                        newSpectators[id] = spec
                }</span>
        }

        <span class="cov0" title="0">return &amp;SpectatorRegistry{
                Spectators: newSpectators,
                Version:    r.Version + 1,
        }</span>
}

// GetSpectators returns a slice of all spectators (safe to read concurrently)
func (r *SpectatorRegistry) GetSpectators() []*Spectator <span class="cov0" title="0">{
        spectators := make([]*Spectator, 0, len(r.Spectators))
        for _, spectator := range r.Spectators </span><span class="cov0" title="0">{
                spectators = append(spectators, spectator)
        }</span>
        <span class="cov0" title="0">return spectators</span>
}

// Spectator represents a session spectator
type Spectator struct {
        UserID     int                 `json:"user_id"`
        Username   string              `json:"username"`
        JoinTime   time.Time           `json:"join_time"`
        Connection SpectatorConnection `json:"-"`
        BytesSent  int64               `json:"bytes_sent"`
        IsActive   bool                `json:"is_active"`
}

// SpectatorConnection interface for different connection types
type SpectatorConnection interface {
        Write(frame *StreamFrame) error
        Close() error
        GetType() string
        IsConnected() bool
}

// SSHSpectatorConnection represents an SSH-based spectator connection
type SSHSpectatorConnection struct {
        SessionCtx *SSHSessionContext
        connected  bool
        mutex      sync.RWMutex
}

func NewSSHSpectatorConnection(sessionCtx *SSHSessionContext) *SSHSpectatorConnection <span class="cov0" title="0">{
        return &amp;SSHSpectatorConnection{
                SessionCtx: sessionCtx,
                connected:  true,
        }
}</span>

func (c *SSHSpectatorConnection) Write(frame *StreamFrame) error <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        if !c.connected || c.SessionCtx == nil || c.SessionCtx.Channel == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH connection not available")
        }</span>

        // Write immutable frame data directly
        <span class="cov0" title="0">n, err := c.SessionCtx.Channel.Write(frame.Data)
        if err == nil &amp;&amp; n &gt; 0 </span><span class="cov0" title="0">{
                // Debug: log first few bytes to see what's being sent
                preview := frame.Data
                if len(preview) &gt; 50 </span><span class="cov0" title="0">{
                        preview = preview[:50]
                }</span>
                <span class="cov0" title="0">log.Printf("Spectator %s: wrote %d bytes (preview: %q...)", c.SessionCtx.Username, n, preview)</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (c *SSHSpectatorConnection) Close() error <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        c.connected = false
        if c.SessionCtx != nil &amp;&amp; c.SessionCtx.Channel != nil </span><span class="cov0" title="0">{
                return c.SessionCtx.Channel.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *SSHSpectatorConnection) GetType() string <span class="cov0" title="0">{
        return "ssh"
}</span>

func (c *SSHSpectatorConnection) IsConnected() bool <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()
        return c.connected
}</span>

// WebSocketSpectatorConnection represents a WebSocket-based spectator connection (stubbed)
type WebSocketSpectatorConnection struct {
        ConnID    string
        connected bool
        mutex     sync.RWMutex
}

func NewWebSocketSpectatorConnection(connID string) *WebSocketSpectatorConnection <span class="cov0" title="0">{
        return &amp;WebSocketSpectatorConnection{
                ConnID:    connID,
                connected: true,
        }
}</span>

func (c *WebSocketSpectatorConnection) Write(frame *StreamFrame) error <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        if !c.connected </span><span class="cov0" title="0">{
                return fmt.Errorf("WebSocket connection closed")
        }</span>

        // TODO: Implement WebSocket frame writing when ready
        // Convert frame to JSON and send via WebSocket
        <span class="cov0" title="0">log.Printf("WebSocket spectator %s would receive frame %d with %d bytes at %v",
                c.ConnID, frame.FrameID, len(frame.Data), frame.Timestamp)
        return nil</span>
}

func (c *WebSocketSpectatorConnection) Close() error <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        c.connected = false
        // TODO: Implement WebSocket close when ready
        log.Printf("WebSocket spectator %s connection closed", c.ConnID)
        return nil
}</span>

func (c *WebSocketSpectatorConnection) GetType() string <span class="cov0" title="0">{
        return "websocket"
}</span>

func (c *WebSocketSpectatorConnection) IsConnected() bool <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()
        return c.connected
}</span>

// Request/Response structures

// CreateUserRequest represents a user creation request
type CreateUserRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
        Email    string `json:"email,omitempty"`
}

// RegistrationRequest represents a user registration request
type RegistrationRequest struct {
        Username        string `json:"username"`
        Password        string `json:"password"`
        PasswordConfirm string `json:"password_confirm"`
        Email           string `json:"email,omitempty"`
        RealName        string `json:"real_name,omitempty"`
        AcceptTerms     bool   `json:"accept_terms"`
        CaptchaResponse string `json:"captcha_response,omitempty"`
        Source          string `json:"source"` // "ssh", "web", "api"
        IPAddress       string `json:"ip_address,omitempty"`
        UserAgent       string `json:"user_agent,omitempty"`
}

// RegistrationResponse represents a registration response
type RegistrationResponse struct {
        Success              bool              `json:"success"`
        User                 *User             `json:"user,omitempty"`
        Message              string            `json:"message"`
        Errors               []ValidationError `json:"errors,omitempty"`
        RequiresVerification bool              `json:"requires_verification"`
}

// ValidationError represents a validation error
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
        Code    string `json:"code"`
}

// CreateSessionRequest represents a session creation request
type CreateSessionRequest struct {
        UserID       int    `json:"user_id"`
        Username     string `json:"username"`
        GameID       string `json:"game_id"`
        TerminalSize string `json:"terminal_size"`
        Encoding     string `json:"encoding"`
}

// LoginRequest represents a login request
type LoginRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

// LoginResponse represents a login response
type LoginResponse struct {
        Success      bool   `json:"success"`
        Token        string `json:"token,omitempty"`
        RefreshToken string `json:"refresh_token,omitempty"`
        User         *User  `json:"user,omitempty"`
        Message      string `json:"message,omitempty"`
}

// StartGameRequest represents a game start request
type StartGameRequest struct {
        UserID   int    `json:"user_id"`
        Username string `json:"username"`
        GameID   string `json:"game_id"`
}

// GameSession represents a game session response
type GameSession struct {
        ID       string `json:"id"`
        UserID   int    `json:"user_id"`
        Username string `json:"username"`
        GameID   string `json:"game_id"`
        Status   string `json:"status"`
}

// ServiceMetrics represents service metrics
type ServiceMetrics struct {
        ActiveSessions   int   `json:"active_sessions"`
        TotalSessions    int   `json:"total_sessions"`
        ActiveSpectators int   `json:"active_spectators"`
        TotalSpectators  int   `json:"total_spectators"`
        BytesTransferred int64 `json:"bytes_transferred"`
        UptimeSeconds    int64 `json:"uptime_seconds"`
}

// Service interfaces

// UserServiceClient interface for user service
type UserServiceClient interface {
        GetUser(ctx context.Context, username string) (*User, error)
        GetUserByID(ctx context.Context, userID int) (*User, error)
        GetUserByUsername(ctx context.Context, username string) (*User, error)
        CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error)
        RegisterUser(ctx context.Context, req *RegistrationRequest) (*RegistrationResponse, error)
        UpdateUser(ctx context.Context, userID int, updates map[string]interface{}) (*User, error)
        DeleteUser(ctx context.Context, userID int) error
        ListUsers(ctx context.Context, limit, offset int) ([]*User, error)
        UpdateLastLogin(ctx context.Context, userID int) error
}

// AuthServiceClient interface for authentication service
type AuthServiceClient interface {
        Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error)
        Logout(ctx context.Context, token string) error
        ValidateToken(ctx context.Context, token string) (*User, error)
        RefreshToken(ctx context.Context, refreshToken string) (*LoginResponse, error)
}

// GameServiceClient interface for game service
type GameServiceClient interface {
        ListGames(ctx context.Context) ([]*Game, error)
        GetGame(ctx context.Context, gameID string) (*Game, error)
        StartGame(ctx context.Context, req *StartGameRequest) (*GameSession, error)
        StopGame(ctx context.Context, sessionID string) error
        GetGameStatus(ctx context.Context, sessionID string) (*GameSession, error)
        UpdateGameConfig(ctx context.Context, gameID string, config *Game) error
}

// Server access control modes
type ServerAccessMode string

const (
        AccessModePublic     ServerAccessMode = "public"      // Anonymous signups allowed
        AccessModeSemiPublic ServerAccessMode = "semi-public" // Invitation keys required
        AccessModePrivate    ServerAccessMode = "private"     // Preloaded keys required
)

// ServerAccessConfig represents server access control configuration
type ServerAccessConfig struct {
        Mode                ServerAccessMode `json:"mode"`
        AllowAnonymous      bool             `json:"allow_anonymous"`
        RequireInviteKey    bool             `json:"require_invite_key"`
        RequirePreloadedKey bool             `json:"require_preloaded_key"`
        MaxUsers            int              `json:"max_users"`
        MaxAnonymousUsers   int              `json:"max_anonymous_users"`
        InviteKeyExpiration string           `json:"invite_key_expiration"`
}

// InviteKey represents an invitation key for semi-public servers
type InviteKey struct {
        ID          string     `json:"id"`
        Key         string     `json:"key"`
        CreatedBy   string     `json:"created_by"`
        CreatedAt   time.Time  `json:"created_at"`
        ExpiresAt   *time.Time `json:"expires_at,omitempty"`
        UsedBy      *string    `json:"used_by,omitempty"`
        UsedAt      *time.Time `json:"used_at,omitempty"`
        IsActive    bool       `json:"is_active"`
        MaxUses     int        `json:"max_uses"`
        CurrentUses int        `json:"current_uses"`
        Notes       string     `json:"notes,omitempty"`
}

// PreloadedKey represents a preloaded access key for private servers
type PreloadedKey struct {
        ID        string     `json:"id"`
        Key       string     `json:"key"`
        Username  string     `json:"username"`
        Email     string     `json:"email,omitempty"`
        CreatedBy string     `json:"created_by"`
        CreatedAt time.Time  `json:"created_at"`
        ExpiresAt *time.Time `json:"expires_at,omitempty"`
        UsedAt    *time.Time `json:"used_at,omitempty"`
        IsActive  bool       `json:"is_active"`
        Role      string     `json:"role,omitempty"`
        Notes     string     `json:"notes,omitempty"`
}

// AccessControlRequest represents a request for server access
type AccessControlRequest struct {
        Username  string `json:"username"`
        Email     string `json:"email,omitempty"`
        Password  string `json:"password"`
        InviteKey string `json:"invite_key,omitempty"`
        AccessKey string `json:"access_key,omitempty"`
        IPAddress string `json:"ip_address,omitempty"`
        UserAgent string `json:"user_agent,omitempty"`
}

// AccessControlResponse represents the response to access control check
type AccessControlResponse struct {
        Allowed      bool   `json:"allowed"`
        Reason       string `json:"reason,omitempty"`
        RequiredRole string `json:"required_role,omitempty"`
        MaxUsers     int    `json:"max_users,omitempty"`
        CurrentUsers int    `json:"current_users,omitempty"`
}

// AccessControlManager interface for managing server access
type AccessControlManager interface {
        CheckAccess(ctx context.Context, req *AccessControlRequest) (*AccessControlResponse, error)
        ValidateInviteKey(ctx context.Context, key string) (*InviteKey, error)
        ValidatePreloadedKey(ctx context.Context, key string) (*PreloadedKey, error)
        CreateInviteKey(ctx context.Context, createdBy string, opts *InviteKeyOptions) (*InviteKey, error)
        CreatePreloadedKey(ctx context.Context, createdBy string, opts *PreloadedKeyOptions) (*PreloadedKey, error)
        RevokeInviteKey(ctx context.Context, keyID string) error
        RevokePreloadedKey(ctx context.Context, keyID string) error
        ListInviteKeys(ctx context.Context, activeOnly bool) ([]*InviteKey, error)
        ListPreloadedKeys(ctx context.Context, activeOnly bool) ([]*PreloadedKey, error)
        GetServerStats(ctx context.Context) (*ServerAccessStats, error)
}

// InviteKeyOptions represents options for creating invite keys
type InviteKeyOptions struct {
        ExpiresAt *time.Time `json:"expires_at,omitempty"`
        MaxUses   int        `json:"max_uses"`
        Notes     string     `json:"notes,omitempty"`
}

// PreloadedKeyOptions represents options for creating preloaded keys
type PreloadedKeyOptions struct {
        Username  string     `json:"username"`
        Email     string     `json:"email,omitempty"`
        ExpiresAt *time.Time `json:"expires_at,omitempty"`
        Role      string     `json:"role,omitempty"`
        Notes     string     `json:"notes,omitempty"`
}

// ServerAccessStats represents server access statistics
type ServerAccessStats struct {
        Mode                ServerAccessMode `json:"mode"`
        TotalUsers          int              `json:"total_users"`
        ActiveUsers         int              `json:"active_users"`
        AnonymousUsers      int              `json:"anonymous_users"`
        RegisteredUsers     int              `json:"registered_users"`
        MaxUsers            int              `json:"max_users"`
        ActiveInviteKeys    int              `json:"active_invite_keys"`
        UsedInviteKeys      int              `json:"used_invite_keys"`
        ActivePreloadedKeys int              `json:"active_preloaded_keys"`
        UsedPreloadedKeys   int              `json:"used_preloaded_keys"`
}

// SessionStatus represents session status
type SessionStatus string

const (
        SessionStatusStarting SessionStatus = "starting"
        SessionStatusActive   SessionStatus = "active"
        SessionStatusPaused   SessionStatus = "paused"
        SessionStatusEnding   SessionStatus = "ending"
        SessionStatusEnded    SessionStatus = "ended"
)

// GameType represents game type
type GameType string

const (
        GameTypeRoguelike GameType = "roguelike"
        GameTypeShell     GameType = "shell"
        GameTypeEditor    GameType = "editor"
        GameTypeOther     GameType = "other"
)

// Extended Game structure with additional fields
type ExtendedGame struct {
        *Game
        Type            GameType          `json:"type"`
        Category        string            `json:"category"`
        Version         string            `json:"version"`
        MinTerminalSize string            `json:"min_terminal_size"`
        MaxTerminalSize string            `json:"max_terminal_size"`
        Tags            []string          `json:"tags"`
        LastPlayed      *time.Time        `json:"last_played,omitempty"`
        PlayCount       int               `json:"play_count"`
        AveragePlayTime time.Duration     `json:"average_play_time"`
        Rating          float32           `json:"rating"`
        Difficulty      int               `json:"difficulty"` // 1-10 scale
        Requirements    map[string]string `json:"requirements"`
}

// SessionStatistics represents session statistics
type SessionStatistics struct {
        TotalSessions       int           `json:"total_sessions"`
        ActiveSessions      int           `json:"active_sessions"`
        AverageSessionTime  time.Duration `json:"average_session_time"`
        TotalPlayTime       time.Duration `json:"total_play_time"`
        MostPlayedGame      string        `json:"most_played_game"`
        TotalUsers          int           `json:"total_users"`
        ActiveUsers         int           `json:"active_users"`
        PeakConcurrentUsers int           `json:"peak_concurrent_users"`
        UptimePercentage    float64       `json:"uptime_percentage"`
}

// UserStatistics represents user statistics
type UserStatistics struct {
        TotalSessions      int           `json:"total_sessions"`
        TotalPlayTime      time.Duration `json:"total_play_time"`
        AverageSessionTime time.Duration `json:"average_session_time"`
        FavoriteGame       string        `json:"favorite_game"`
        GamesPlayed        []string      `json:"games_played"`
        FirstLogin         time.Time     `json:"first_login"`
        LastLogin          time.Time     `json:"last_login"`
        LoginCount         int           `json:"login_count"`
        Achievements       []string      `json:"achievements"`
        Rank               int           `json:"rank"`
}

// GameStatistics represents game statistics
type GameStatistics struct {
        TotalSessions      int           `json:"total_sessions"`
        ActiveSessions     int           `json:"active_sessions"`
        TotalPlayTime      time.Duration `json:"total_play_time"`
        AverageSessionTime time.Duration `json:"average_session_time"`
        UniqueUsers        int           `json:"unique_users"`
        PopularityRank     int           `json:"popularity_rank"`
        Rating             float32       `json:"rating"`
        CompletionRate     float32       `json:"completion_rate"`
        AverageScore       float32       `json:"average_score"`
        HighScore          int           `json:"high_score"`
        HighScoreHolder    string        `json:"high_score_holder"`
}

// Event system for notifications

// Event represents a system event
type Event struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        Source    string                 `json:"source"`
        Data      map[string]interface{} `json:"data"`
        Timestamp time.Time              `json:"timestamp"`
}

// EventType constants
const (
        EventTypeSessionStart   = "session.start"
        EventTypeSessionEnd     = "session.end"
        EventTypeUserLogin      = "user.login"
        EventTypeUserLogout     = "user.logout"
        EventTypeUserRegister   = "user.register"
        EventTypeGameStart      = "game.start"
        EventTypeGameEnd        = "game.end"
        EventTypeSpectatorJoin  = "spectator.join"
        EventTypeSpectatorLeave = "spectator.leave"
        EventTypeSystemShutdown = "system.shutdown"
        EventTypeSystemStartup  = "system.startup"
)

// EventBus interface for event handling
type EventBus interface {
        Publish(event *Event) error
        Subscribe(eventType string, handler func(*Event)) error
        Unsubscribe(eventType string, handler func(*Event)) error
}

// SimpleEventBus implements EventBus
type SimpleEventBus struct {
        handlers map[string][]func(*Event)
        mutex    sync.RWMutex
}

func NewSimpleEventBus() *SimpleEventBus <span class="cov0" title="0">{
        return &amp;SimpleEventBus{
                handlers: make(map[string][]func(*Event)),
        }
}</span>

func (eb *SimpleEventBus) Publish(event *Event) error <span class="cov0" title="0">{
        eb.mutex.RLock()
        defer eb.mutex.RUnlock()

        if handlers, exists := eb.handlers[event.Type]; exists </span><span class="cov0" title="0">{
                for _, handler := range handlers </span><span class="cov0" title="0">{
                        go handler(event)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (eb *SimpleEventBus) Subscribe(eventType string, handler func(*Event)) error <span class="cov0" title="0">{
        eb.mutex.Lock()
        defer eb.mutex.Unlock()

        eb.handlers[eventType] = append(eb.handlers[eventType], handler)
        return nil
}</span>

func (eb *SimpleEventBus) Unsubscribe(eventType string, handler func(*Event)) error <span class="cov0" title="0">{
        eb.mutex.Lock()
        defer eb.mutex.Unlock()

        // This is a simplified implementation
        // In a real implementation, you'd need to match function pointers
        delete(eb.handlers, eventType)
        return nil
}</span>

// Logger types

// LogLevel represents log level
type LogLevel int

const (
        LogLevelDebug LogLevel = iota
        LogLevelInfo
        LogLevelWarn
        LogLevelError
)

// Logger interface for structured logging
type Logger interface {
        Debug(msg string, fields ...interface{})
        Info(msg string, fields ...interface{})
        Warn(msg string, fields ...interface{})
        Error(msg string, fields ...interface{})
}

// SimpleLogger implements Logger interface
type SimpleLogger struct {
        level LogLevel
}

func NewSimpleLogger(level LogLevel) *SimpleLogger <span class="cov0" title="0">{
        return &amp;SimpleLogger{level: level}
}</span>

func (l *SimpleLogger) Debug(msg string, fields ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= LogLevelDebug </span><span class="cov0" title="0">{
                log.Printf("[DEBUG] %s %v", msg, fields)
        }</span>
}

func (l *SimpleLogger) Info(msg string, fields ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= LogLevelInfo </span><span class="cov0" title="0">{
                log.Printf("[INFO] %s %v", msg, fields)
        }</span>
}

func (l *SimpleLogger) Warn(msg string, fields ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= LogLevelWarn </span><span class="cov0" title="0">{
                log.Printf("[WARN] %s %v", msg, fields)
        }</span>
}

func (l *SimpleLogger) Error(msg string, fields ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= LogLevelError </span><span class="cov0" title="0">{
                log.Printf("[ERROR] %s %v", msg, fields)
        }</span>
}

// Validation functions

// ValidateCreateUserRequest validates a create user request
func ValidateCreateUserRequest(req *CreateUserRequest) []*ValidationError <span class="cov0" title="0">{
        var errors []*ValidationError

        if req.Username == "" </span><span class="cov0" title="0">{
                errors = append(errors, &amp;ValidationError{
                        Field:   "username",
                        Message: "username is required",
                })
        }</span>

        <span class="cov0" title="0">if req.Password == "" </span><span class="cov0" title="0">{
                errors = append(errors, &amp;ValidationError{
                        Field:   "password",
                        Message: "password is required",
                })
        }</span>

        <span class="cov0" title="0">if len(req.Username) &lt; 3 || len(req.Username) &gt; 32 </span><span class="cov0" title="0">{
                errors = append(errors, &amp;ValidationError{
                        Field:   "username",
                        Message: "username must be between 3 and 32 characters long",
                })
        }</span>

        <span class="cov0" title="0">if len(req.Password) &lt; 6 </span><span class="cov0" title="0">{
                errors = append(errors, &amp;ValidationError{
                        Field:   "password",
                        Message: "password must be at least 6 characters long",
                })
        }</span>

        // Basic username validation (alphanumeric + underscore)
        <span class="cov0" title="0">for _, char := range req.Username </span><span class="cov0" title="0">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                        (char &gt;= '0' &amp;&amp; char &lt;= '9') || char == '_') </span><span class="cov0" title="0">{
                        errors = append(errors, &amp;ValidationError{
                                Field:   "username",
                                Message: "username can only contain letters, numbers, and underscores",
                        })
                        break</span>
                }
        }

        <span class="cov0" title="0">return errors</span>
}

// Configuration helpers

// GetDefaultSSHConfig returns default SSH configuration
func GetDefaultSSHConfig() *config.SSHConfig <span class="cov0" title="0">{
        return &amp;config.SSHConfig{
                Enabled:        true,
                Port:           22,
                Host:           "0.0.0.0",
                HostKeyPath:    "/etc/ssh/ssh_host_rsa_key",
                Banner:         "Welcome to dungeongate!\r\n",
                MaxSessions:    100,
                SessionTimeout: "4h",
                IdleTimeout:    "30m",
                Auth: &amp;config.SSHAuthConfig{
                        PasswordAuth:   true,
                        PublicKeyAuth:  false,
                        AllowAnonymous: true,
                },
                Terminal: &amp;config.SSHTerminalConfig{
                        DefaultSize:        "80x24",
                        MaxSize:            "200x50",
                        SupportedTerminals: []string{"xterm", "xterm-256color", "screen", "tmux", "vt100"},
                },
        }
}</span>

// GetDefaultMenuConfig returns default menu configuration
func GetDefaultMenuConfig() *config.MenuConfig <span class="cov0" title="0">{
        return &amp;config.MenuConfig{
                Banners: &amp;config.BannersConfig{
                        MainAnon:  "/etc/dungeongate/banners/main_anon.txt",
                        MainUser:  "/etc/dungeongate/banners/main_user.txt",
                        WatchMenu: "/etc/dungeongate/banners/watch_menu.txt",
                },
                Options: &amp;config.MenuOptions{
                        Anonymous: []*config.MenuOption{
                                {Key: "l", Label: "Login", Action: "login"},
                                {Key: "r", Label: "Register", Action: "register"},
                                {Key: "w", Label: "Watch games", Action: "watch"},
                                {Key: "g", Label: "List games", Action: "list_games"},
                                {Key: "q", Label: "Quit", Action: "quit"},
                        },
                        Authenticated: []*config.MenuOption{
                                {Key: "p", Label: "Play a game", Action: "play"},
                                {Key: "w", Label: "Watch games", Action: "watch"},
                                {Key: "e", Label: "Edit profile", Action: "edit_profile"},
                                {Key: "l", Label: "List games", Action: "list_games"},
                                {Key: "r", Label: "View recordings", Action: "recordings"},
                                {Key: "s", Label: "Statistics", Action: "stats"},
                                {Key: "q", Label: "Quit", Action: "quit"},
                        },
                },
        }
}</span>

// Security helpers

// HashPassword hashes a password using bcrypt
func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        // This would use bcrypt in a real implementation
        return fmt.Sprintf("hashed_%s", password), nil
}</span>

// VerifyPassword verifies a password against a hash
func VerifyPassword(password, hash string) bool <span class="cov0" title="0">{
        // This would use bcrypt in a real implementation
        return hash == fmt.Sprintf("hashed_%s", password)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package user

import (
        "context"
        "crypto/rand"
        "crypto/subtle"
        "database/sql"
        "encoding/hex"
        "fmt"
        "net/mail"
        "regexp"

        // "strings"

        "time"

        "github.com/dungeongate/pkg/config"
        "github.com/dungeongate/pkg/database"
        "golang.org/x/crypto/argon2"
)

// UserFlags represents user account flags
type UserFlags int

const (
        UserFlagNone         UserFlags = 0
        UserFlagAdmin        UserFlags = 1 &lt;&lt; 0 // 0x01
        UserFlagLoginLock    UserFlags = 1 &lt;&lt; 1 // 0x02
        UserFlagPasswordLock UserFlags = 1 &lt;&lt; 2 // 0x04
        UserFlagEmailLock    UserFlags = 1 &lt;&lt; 3 // 0x08
        UserFlagModerator    UserFlags = 1 &lt;&lt; 4 // 0x10
        UserFlagBeta         UserFlags = 1 &lt;&lt; 5 // 0x20
)

// Enhanced User model
type User struct {
        ID                  int                    `json:"id" db:"id"`
        Username            string                 `json:"username" db:"username"`
        Email               string                 `json:"email,omitempty" db:"email"`
        PasswordHash        string                 `json:"-" db:"password_hash"`
        Salt                string                 `json:"-" db:"salt"`
        Environment         string                 `json:"environment,omitempty" db:"environment"`
        Flags               UserFlags              `json:"flags" db:"flags"`
        CreatedAt           time.Time              `json:"created_at" db:"created_at"`
        UpdatedAt           time.Time              `json:"updated_at" db:"updated_at"`
        LastLogin           *time.Time             `json:"last_login,omitempty" db:"last_login"`
        LoginCount          int                    `json:"login_count" db:"login_count"`
        FailedLoginAttempts int                    `json:"-" db:"failed_login_attempts"`
        AccountLocked       bool                   `json:"account_locked" db:"account_locked"`
        LockedUntil         *time.Time             `json:"-" db:"locked_until"`
        EmailVerified       bool                   `json:"email_verified" db:"email_verified"`
        IsActive            bool                   `json:"is_active" db:"is_active"`
        Profile             *UserProfile           `json:"profile,omitempty"`
        Preferences         map[string]interface{} `json:"preferences,omitempty"`
        Roles               []string               `json:"roles,omitempty"`
}

// UserProfile represents extended user profile information
type UserProfile struct {
        UserID             int    `json:"user_id" db:"user_id"`
        RealName           string `json:"real_name,omitempty" db:"real_name"`
        Location           string `json:"location,omitempty" db:"location"`
        Website            string `json:"website,omitempty" db:"website"`
        Bio                string `json:"bio,omitempty" db:"bio"`
        AvatarURL          string `json:"avatar_url,omitempty" db:"avatar_url"`
        Timezone           string `json:"timezone" db:"timezone"`
        Language           string `json:"language" db:"language"`
        Theme              string `json:"theme" db:"theme"`
        TerminalSize       string `json:"terminal_size" db:"terminal_size"`
        ColorMode          string `json:"color_mode" db:"color_mode"`
        EmailNotifications bool   `json:"email_notifications" db:"email_notifications"`
        PublicProfile      bool   `json:"public_profile" db:"public_profile"`
        AllowSpectators    bool   `json:"allow_spectators" db:"allow_spectators"`
        ShowOnlineStatus   bool   `json:"show_online_status" db:"show_online_status"`
}

// RegistrationRequest represents a user registration request
type RegistrationRequest struct {
        Username        string `json:"username"`
        Password        string `json:"password"`
        PasswordConfirm string `json:"password_confirm"`
        Email           string `json:"email,omitempty"`
        RealName        string `json:"real_name,omitempty"`
        AcceptTerms     bool   `json:"accept_terms"`
        CaptchaResponse string `json:"captcha_response,omitempty"`
        Source          string `json:"source"` // "ssh", "web", "api"
        IPAddress       string `json:"ip_address,omitempty"`
        UserAgent       string `json:"user_agent,omitempty"`
}

// RegistrationResponse represents a registration response
type RegistrationResponse struct {
        Success              bool              `json:"success"`
        User                 *User             `json:"user,omitempty"`
        Message              string            `json:"message"`
        Errors               []ValidationError `json:"errors,omitempty"`
        RequiresVerification bool              `json:"requires_verification"`
}

// ValidationError represents a validation error
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
        Code    string `json:"code"`
}

// Enhanced Service with flexible database configuration
type Service struct {
        db            *database.Connection
        config        *config.UserServiceConfig
        sessionConfig *config.SessionServiceConfig
}

// NewService creates a new user service with enhanced configuration
func NewService(db *database.Connection, cfg *config.UserServiceConfig, sessionCfg *config.SessionServiceConfig) (*Service, error) <span class="cov0" title="0">{
        service := &amp;Service{
                db:            db,
                config:        cfg,
                sessionConfig: sessionCfg,
        }

        // Initialize database schema
        if err := service.initializeSchema(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database schema: %w", err)
        }</span>

        <span class="cov0" title="0">return service, nil</span>
}

// initializeSchema creates the necessary database tables
func (s *Service) initializeSchema() error <span class="cov0" title="0">{
        queries := []string{
                `CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        username VARCHAR(30) UNIQUE NOT NULL,
                        email VARCHAR(80),
                        password_hash VARCHAR(255) NOT NULL,
                        salt VARCHAR(32) NOT NULL,
                        environment TEXT DEFAULT '',
                        flags INTEGER DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_login TIMESTAMP,
                        login_count INTEGER DEFAULT 0,
                        failed_login_attempts INTEGER DEFAULT 0,
                        account_locked BOOLEAN DEFAULT FALSE,
                        locked_until TIMESTAMP,
                        email_verified BOOLEAN DEFAULT FALSE,
                        is_active BOOLEAN DEFAULT TRUE
                )`,
                `CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)`,
                `CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)`,
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := s.db.Exec(query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute schema query: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// RegisterUser registers a new user
func (s *Service) RegisterUser(ctx context.Context, req *RegistrationRequest) (*RegistrationResponse, error) <span class="cov0" title="0">{
        // Validate registration request
        if errors := s.validateRegistrationRequest(req); len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;RegistrationResponse{
                        Success: false,
                        Message: "Validation failed",
                        Errors:  errors,
                }, nil
        }</span>

        // Check if username exists
        <span class="cov0" title="0">if exists, err := s.usernameExists(ctx, req.Username); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check username existence: %w", err)
        }</span> else<span class="cov0" title="0"> if exists </span><span class="cov0" title="0">{
                return &amp;RegistrationResponse{
                        Success: false,
                        Message: "Username already exists",
                        Errors: []ValidationError{
                                {Field: "username", Message: "Username already taken", Code: "USERNAME_EXISTS"},
                        },
                }, nil
        }</span>

        // Hash password
        <span class="cov0" title="0">passwordHash, salt, err := s.hashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Create user
        <span class="cov0" title="0">now := time.Now()
        user := &amp;User{
                Username:      req.Username,
                Email:         req.Email,
                PasswordHash:  passwordHash,
                Salt:          salt,
                Environment:   "",
                Flags:         UserFlagNone,
                CreatedAt:     now,
                UpdatedAt:     now,
                IsActive:      true,
                EmailVerified: true,
        }

        // Insert user into database
        query := `
                INSERT INTO users (username, email, password_hash, salt, environment, flags, 
                                                  created_at, updated_at, is_active, email_verified)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := s.db.ExecContext(ctx, query,
                user.Username, user.Email, user.PasswordHash, user.Salt, user.Environment,
                user.Flags, user.CreatedAt, user.UpdatedAt, user.IsActive, user.EmailVerified)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to insert user: %w", err)
        }</span>

        <span class="cov0" title="0">userID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user ID: %w", err)
        }</span>
        <span class="cov0" title="0">user.ID = int(userID)

        return &amp;RegistrationResponse{
                Success: true,
                User:    user,
                Message: "Registration successful",
        }, nil</span>
}

// validateRegistrationRequest validates the registration request
func (s *Service) validateRegistrationRequest(req *RegistrationRequest) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError

        // Validate username
        if usernameErrors := s.validateUsername(req.Username); len(usernameErrors) &gt; 0 </span><span class="cov0" title="0">{
                errors = append(errors, usernameErrors...)
        }</span>

        // Validate password
        <span class="cov0" title="0">if passwordErrors := s.validatePassword(req.Password); len(passwordErrors) &gt; 0 </span><span class="cov0" title="0">{
                errors = append(errors, passwordErrors...)
        }</span>

        // Validate password confirmation
        <span class="cov0" title="0">if req.Password != req.PasswordConfirm </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "password_confirm",
                        Message: "Passwords do not match",
                        Code:    "PASSWORD_MISMATCH",
                })
        }</span>

        // Validate email if provided
        <span class="cov0" title="0">if req.Email != "" </span><span class="cov0" title="0">{
                if emailErrors := s.validateEmail(req.Email); len(emailErrors) &gt; 0 </span><span class="cov0" title="0">{
                        errors = append(errors, emailErrors...)
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateUsername validates username
func (s *Service) validateUsername(username string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError

        if username == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "username",
                        Message: "Username is required",
                        Code:    "USERNAME_REQUIRED",
                })
                return errors
        }</span>

        <span class="cov0" title="0">if len(username) &lt; 3 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "username",
                        Message: "Username must be at least 3 characters long",
                        Code:    "USERNAME_TOO_SHORT",
                })
        }</span>

        <span class="cov0" title="0">if len(username) &gt; 30 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "username",
                        Message: "Username must be no more than 30 characters long",
                        Code:    "USERNAME_TOO_LONG",
                })
        }</span>

        // Check valid characters (alphanumeric and underscore only)
        <span class="cov0" title="0">validUsername := regexp.MustCompile(`^[a-zA-Z0-9_]+$`)
        if !validUsername.MatchString(username) </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "username",
                        Message: "Username can only contain letters, numbers, and underscores",
                        Code:    "USERNAME_INVALID_CHARS",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePassword validates password
func (s *Service) validatePassword(password string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError

        if password == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "password",
                        Message: "Password is required",
                        Code:    "PASSWORD_REQUIRED",
                })
                return errors
        }</span>

        <span class="cov0" title="0">if len(password) &lt; 6 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "password",
                        Message: "Password must be at least 6 characters long",
                        Code:    "PASSWORD_TOO_SHORT",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateEmail validates email
func (s *Service) validateEmail(email string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError

        if email == "" </span><span class="cov0" title="0">{
                return errors // Email is optional
        }</span>

        <span class="cov0" title="0">if _, err := mail.ParseAddress(email); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "email",
                        Message: "Invalid email format",
                        Code:    "EMAIL_INVALID",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// usernameExists checks if username already exists
func (s *Service) usernameExists(ctx context.Context, username string) (bool, error) <span class="cov0" title="0">{
        var count int
        query := "SELECT COUNT(*) FROM users WHERE username = ?"
        err := s.db.QueryRowContext(ctx, query, username).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}


// hashPassword hashes a password using Argon2
func (s *Service) hashPassword(password string) (string, string, error) <span class="cov0" title="0">{
        // Generate salt
        salt := make([]byte, 16)
        if _, err := rand.Read(salt); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Hash password
        <span class="cov0" title="0">hash := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)

        return hex.EncodeToString(hash), hex.EncodeToString(salt), nil</span>
}

// verifyPassword verifies a password against a hash
func verifyPassword(password, saltHex, hashHex string) bool <span class="cov0" title="0">{
        salt, err := hex.DecodeString(saltHex)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">hash, err := hex.DecodeString(hashHex)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Hash the provided password
        <span class="cov0" title="0">providedHash := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)

        // Compare hashes
        return subtle.ConstantTimeCompare(hash, providedHash) == 1</span>
}

// AuthenticateUser authenticates a user with enhanced error handling and attempt tracking
func (s *Service) AuthenticateUser(ctx context.Context, username, password string) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, environment, flags,
                           created_at, updated_at, last_login, login_count, failed_login_attempts,
                           account_locked, locked_until, email_verified, is_active
                FROM users 
                WHERE username = ? AND is_active = TRUE
        `

        var user User
        var lastLogin, lockedUntil sql.NullTime

        err := s.db.QueryRowContext(ctx, query, username).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.Environment, &amp;user.Flags, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;lastLogin, &amp;user.LoginCount, &amp;user.FailedLoginAttempts,
                &amp;user.AccountLocked, &amp;lockedUntil, &amp;user.EmailVerified, &amp;user.IsActive,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("username_not_found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to query user: %w", err)</span>
        }

        // Convert nullable times
        <span class="cov0" title="0">if lastLogin.Valid </span><span class="cov0" title="0">{
                user.LastLogin = &amp;lastLogin.Time
        }</span>
        <span class="cov0" title="0">if lockedUntil.Valid </span><span class="cov0" title="0">{
                user.LockedUntil = &amp;lockedUntil.Time
        }</span>

        // Check if account is locked
        <span class="cov0" title="0">if user.AccountLocked &amp;&amp; user.LockedUntil != nil &amp;&amp; time.Now().Before(*user.LockedUntil) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("account_locked")
        }</span>

        // Verify password
        <span class="cov0" title="0">if !verifyPassword(password, user.Salt, user.PasswordHash) </span><span class="cov0" title="0">{
                // Increment failed login attempts
                if err := s.incrementFailedLoginAttempts(ctx, user.ID); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't expose it to user
                        fmt.Printf("Error incrementing failed login attempts: %v\n", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("invalid_password")</span>
        }

        // Password is correct - reset failed attempts and unlock account if needed
        <span class="cov0" title="0">if err := s.resetFailedLoginAttempts(ctx, user.ID); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail authentication
                fmt.Printf("Error resetting failed login attempts: %v\n", err)
        }</span>

        // Update last login
        <span class="cov0" title="0">if err := s.updateLastLogin(ctx, user.ID); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail authentication
                fmt.Printf("Error updating last login: %v\n", err)
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// updateLastLogin updates user's last login time
func (s *Service) updateLastLogin(ctx context.Context, userID int) error <span class="cov0" title="0">{
        query := `
                UPDATE users 
                SET last_login = CURRENT_TIMESTAMP, 
                        login_count = login_count + 1
                WHERE id = ?
        `
        _, err := s.db.ExecContext(ctx, query, userID)
        return err
}</span>

// GetUserByID retrieves a user by ID
func (s *Service) GetUserByID(ctx context.Context, userID int) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, environment, flags,
                           created_at, updated_at, last_login, login_count, failed_login_attempts,
                           account_locked, locked_until, email_verified, is_active
                FROM users 
                WHERE id = ?
        `

        var user User
        var lastLogin, lockedUntil sql.NullTime

        err := s.db.QueryRowContext(ctx, query, userID).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.Environment, &amp;user.Flags, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;lastLogin, &amp;user.LoginCount, &amp;user.FailedLoginAttempts,
                &amp;user.AccountLocked, &amp;lockedUntil, &amp;user.EmailVerified, &amp;user.IsActive,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to query user: %w", err)</span>
        }

        // Convert nullable times
        <span class="cov0" title="0">if lastLogin.Valid </span><span class="cov0" title="0">{
                user.LastLogin = &amp;lastLogin.Time
        }</span>
        <span class="cov0" title="0">if lockedUntil.Valid </span><span class="cov0" title="0">{
                user.LockedUntil = &amp;lockedUntil.Time
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetUserByUsername retrieves a user by username
func (s *Service) GetUserByUsername(ctx context.Context, username string) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, environment, flags,
                           created_at, updated_at, last_login, login_count, failed_login_attempts,
                           account_locked, locked_until, email_verified, is_active
                FROM users 
                WHERE username = ?
        `

        var user User
        var lastLogin, lockedUntil sql.NullTime

        err := s.db.QueryRowContext(ctx, query, username).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.Environment, &amp;user.Flags, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;lastLogin, &amp;user.LoginCount, &amp;user.FailedLoginAttempts,
                &amp;user.AccountLocked, &amp;lockedUntil, &amp;user.EmailVerified, &amp;user.IsActive,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to query user: %w", err)</span>
        }

        // Convert nullable times
        <span class="cov0" title="0">if lastLogin.Valid </span><span class="cov0" title="0">{
                user.LastLogin = &amp;lastLogin.Time
        }</span>
        <span class="cov0" title="0">if lockedUntil.Valid </span><span class="cov0" title="0">{
                user.LockedUntil = &amp;lockedUntil.Time
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package user

import (
        "context"
        "fmt"
        "time"
)

// incrementFailedLoginAttempts increments failed login attempts and locks account if needed
func (s *Service) incrementFailedLoginAttempts(ctx context.Context, userID int) error <span class="cov0" title="0">{
        // Get current failed attempts
        var currentAttempts int
        query := `SELECT failed_login_attempts FROM users WHERE id = ?`
        err := s.db.QueryRowContext(ctx, query, userID).Scan(&amp;currentAttempts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current attempts: %w", err)
        }</span>

        <span class="cov0" title="0">newAttempts := currentAttempts + 1
        maxAttempts := s.getMaxFailedAttempts()

        // Check if we should lock the account
        if newAttempts &gt;= maxAttempts </span><span class="cov0" title="0">{
                lockDuration := s.getLockDuration()
                lockUntil := time.Now().Add(lockDuration)

                updateQuery := `
                        UPDATE users 
                        SET failed_login_attempts = ?, 
                                account_locked = TRUE,
                                locked_until = ?
                        WHERE id = ?
                `
                _, err = s.db.ExecContext(ctx, updateQuery, newAttempts, lockUntil, userID)
        }</span> else<span class="cov0" title="0"> {
                updateQuery := `
                        UPDATE users 
                        SET failed_login_attempts = ?
                        WHERE id = ?
                `
                _, err = s.db.ExecContext(ctx, updateQuery, newAttempts, userID)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// resetFailedLoginAttempts resets failed login attempts and unlocks account
func (s *Service) resetFailedLoginAttempts(ctx context.Context, userID int) error <span class="cov0" title="0">{
        query := `
                UPDATE users 
                SET failed_login_attempts = 0,
                        account_locked = FALSE,
                        locked_until = NULL
                WHERE id = ?
        `
        _, err := s.db.ExecContext(ctx, query, userID)
        return err
}</span>

// getMaxFailedAttempts returns the maximum failed login attempts from config
func (s *Service) getMaxFailedAttempts() int <span class="cov8" title="1">{
        if s.sessionConfig != nil &amp;&amp; s.sessionConfig.User != nil &amp;&amp; s.sessionConfig.User.LoginAttempts != nil </span><span class="cov8" title="1">{
                return s.sessionConfig.User.LoginAttempts.MaxAttempts
        }</span>
        <span class="cov8" title="1">return 3</span> // Default to 3 attempts
}

// getLockDuration returns the lock duration from config
func (s *Service) getLockDuration() time.Duration <span class="cov8" title="1">{
        if s.sessionConfig != nil &amp;&amp; s.sessionConfig.User != nil &amp;&amp; s.sessionConfig.User.LoginAttempts != nil </span><span class="cov8" title="1">{
                duration, err := time.ParseDuration(s.sessionConfig.User.LoginAttempts.LockDuration)
                if err == nil </span><span class="cov8" title="1">{
                        return duration
                }</span>
        }
        <span class="cov8" title="1">return 15 * time.Minute</span> // Default to 15 minutes
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package config

import (
        "fmt"
        "os"
        "time"

        "gopkg.in/yaml.v3"
)

// ServerConfig represents common server configuration
type ServerConfig struct {
        Port           int    `yaml:"port"`
        GRPCPort       int    `yaml:"grpc_port"`
        Host           string `yaml:"host"`
        Timeout        string `yaml:"timeout"`
        MaxConnections int    `yaml:"max_connections"`
}

// LegacyDatabaseConfig represents basic database configuration (legacy compatibility)
// For full database features, use DatabaseConfig from user_config.go
type LegacyDatabaseConfig struct {
        Type       string                 `yaml:"type"`
        Connection map[string]interface{} `yaml:"connection"`
        Pool       *PoolConfig            `yaml:"pool,omitempty"`
}

// PoolConfig represents database pool configuration
type PoolConfig struct {
        MaxConnections        int    `yaml:"max_connections"`
        MaxIdleConnections    int    `yaml:"max_idle_connections"`
        ConnectionMaxLifetime string `yaml:"connection_max_lifetime"`
}

// EncryptionConfig represents encryption configuration
type EncryptionConfig struct {
        Enabled             bool   `yaml:"enabled"`
        Algorithm           string `yaml:"algorithm"`
        KeyRotationInterval string `yaml:"key_rotation_interval"`
}

// LoggingConfig represents logging configuration
type LoggingConfig struct {
        Level  string `yaml:"level"`
        Format string `yaml:"format"`
        Output string `yaml:"output"`
}

// MonitoringConfig represents monitoring configuration
type MonitoringConfig struct {
        Enabled bool `yaml:"enabled"`
        Port    int  `yaml:"port"`
}

// SessionManagementConfig represents session management configuration
type SessionManagementConfig struct {
        Terminal   *TerminalConfig   `yaml:"terminal"`
        Timeouts   *TimeoutsConfig   `yaml:"timeouts"`
        TTYRec     *TTYRecConfig     `yaml:"ttyrec"`
        Monitoring *MonitoringConfig `yaml:"monitoring"`
        Spectating *SpectatingConfig `yaml:"spectating"`
}

// TerminalConfig represents terminal configuration
type TerminalConfig struct {
        DefaultSize string `yaml:"default_size"`
        MaxSize     string `yaml:"max_size"`
        Encoding    string `yaml:"encoding"`
}

// TimeoutsConfig represents timeout configuration
type TimeoutsConfig struct {
        IdleTimeout        string `yaml:"idle_timeout"`
        MaxSessionDuration string `yaml:"max_session_duration"`
        CleanupInterval    string `yaml:"cleanup_interval"`
}

// TTYRecConfig represents TTYRec configuration
type TTYRecConfig struct {
        Enabled       bool   `yaml:"enabled"`
        Compression   string `yaml:"compression"`
        Directory     string `yaml:"directory"`
        MaxFileSize   string `yaml:"max_file_size"`
        RetentionDays int    `yaml:"retention_days"`
}

// SpectatingConfig represents spectating configuration
type SpectatingConfig struct {
        Enabled                 bool   `yaml:"enabled"`
        MaxSpectatorsPerSession int    `yaml:"max_spectators_per_session"`
        SpectatorTimeout        string `yaml:"spectator_timeout"`
}

// Load configuration from file
func Load(configPath string) (map[string]interface{}, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Expand environment variables
        <span class="cov0" title="0">expanded := os.ExpandEnv(string(data))

        var config map[string]interface{}
        if err := yaml.Unmarshal([]byte(expanded), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// Helper functions

// ParseTerminalSize parses terminal size string like "80x24"
func ParseTerminalSize(sizeStr string) (width, height int, err error) <span class="cov0" title="0">{
        n, err := fmt.Sscanf(sizeStr, "%dx%d", &amp;width, &amp;height)
        if err != nil || n != 2 </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("invalid terminal size format: %s", sizeStr)
        }</span>
        <span class="cov0" title="0">return width, height, nil</span>
}

// FormatTerminalSize formats terminal size as string
func FormatTerminalSize(width, height int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%dx%d", width, height)
}</span>

// GetDefaultTerminalSize returns default terminal size as width and height
func GetDefaultTerminalSize() (width, height int) <span class="cov0" title="0">{
        return 80, 24
}</span>

// ParseDuration parses duration string with fallback
func ParseDuration(durationStr string, fallback time.Duration) time.Duration <span class="cov0" title="0">{
        if duration, err := time.ParseDuration(durationStr); err == nil </span><span class="cov0" title="0">{
                return duration
        }</span>
        <span class="cov0" title="0">return fallback</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package config

import (
        "fmt"
        "os"
        "time"

        "gopkg.in/yaml.v3"
)

// GameServiceConfig represents the game service configuration
type GameServiceConfig struct {
        Version    string              `yaml:"version"`
        Server     *ServerConfig       `yaml:"server"`
        Database   *DatabaseConfig     `yaml:"database"`
        GameEngine *GameEngineConfig   `yaml:"game_engine"`
        Games      []*GameConfig       `yaml:"games"`
        Kubernetes *KubernetesConfig   `yaml:"kubernetes"`
        Storage    *GameStorageConfig  `yaml:"storage"`
        Logging    *LoggingConfig      `yaml:"logging"`
        Metrics    *MetricsConfig      `yaml:"metrics"`
        Health     *HealthConfig       `yaml:"health"`
        Security   *GameSecurityConfig `yaml:"security"`
}

// GameEngineConfig represents game engine configuration
type GameEngineConfig struct {
        Mode             string                  `yaml:"mode"` // "container", "process", "hybrid"
        ProcessPool      *ProcessPoolConfig      `yaml:"process_pool"`
        ContainerRuntime *ContainerRuntimeConfig `yaml:"container_runtime"`
        Isolation        *IsolationConfig        `yaml:"isolation"`
        Monitoring       *GameMonitoringConfig   `yaml:"monitoring"`
        Chroot           *ChrootConfig           `yaml:"chroot"`
        Resources        *ResourcesConfig        `yaml:"resources"`
}

// GameConfig represents a specific game configuration
type GameConfig struct {
        ID          string            `yaml:"id"`
        Name        string            `yaml:"name"`
        ShortName   string            `yaml:"short_name"`
        Version     string            `yaml:"version"`
        Enabled     bool              `yaml:"enabled"`
        Binary      *BinaryConfig     `yaml:"binary"`
        Files       *FilesConfig      `yaml:"files"`
        Settings    *GameSettings     `yaml:"settings"`
        Environment map[string]string `yaml:"environment"`
        Resources   *ResourcesConfig  `yaml:"resources"`
        Container   *ContainerConfig  `yaml:"container"`
        Networking  *NetworkingConfig `yaml:"networking"`
}

// BinaryConfig represents binary configuration
type BinaryConfig struct {
        Path             string   `yaml:"path"`
        Args             []string `yaml:"args"`
        WorkingDirectory string   `yaml:"working_directory"`
        User             string   `yaml:"user"`
        Group            string   `yaml:"group"`
        Permissions      string   `yaml:"permissions"`
}

// FilesConfig represents files configuration
type FilesConfig struct {
        DataDirectory   string             `yaml:"data_directory"`
        SaveDirectory   string             `yaml:"save_directory"`
        ConfigDirectory string             `yaml:"config_directory"`
        LogDirectory    string             `yaml:"log_directory"`
        TempDirectory   string             `yaml:"temp_directory"`
        SharedFiles     []string           `yaml:"shared_files"`
        UserFiles       []string           `yaml:"user_files"`
        Permissions     *PermissionsConfig `yaml:"permissions"`
}

// PermissionsConfig represents file permissions
type PermissionsConfig struct {
        DataDirectory string `yaml:"data_directory"`
        SaveDirectory string `yaml:"save_directory"`
        UserFiles     string `yaml:"user_files"`
        LogFiles      string `yaml:"log_files"`
}

// GameSettings represents game-specific settings
type GameSettings struct {
        MaxPlayers         int               `yaml:"max_players"`
        MaxSessionDuration string            `yaml:"max_session_duration"`
        IdleTimeout        string            `yaml:"idle_timeout"`
        SaveInterval       string            `yaml:"save_interval"`
        AutoSave           bool              `yaml:"auto_save"`
        Spectating         *SpectatingConfig `yaml:"spectating"`
        Recording          *RecordingConfig  `yaml:"recording"`
        Options            map[string]string `yaml:"options"`
}

// RecordingConfig represents recording configuration
type RecordingConfig struct {
        Enabled       bool   `yaml:"enabled"`
        Format        string `yaml:"format"`
        Compression   string `yaml:"compression"`
        MaxFileSize   string `yaml:"max_file_size"`
        RetentionDays int    `yaml:"retention_days"`
        AutoCleanup   bool   `yaml:"auto_cleanup"`
}

// ContainerConfig represents container configuration
type ContainerConfig struct {
        Image           string                 `yaml:"image"`
        Tag             string                 `yaml:"tag"`
        Registry        string                 `yaml:"registry"`
        PullPolicy      string                 `yaml:"pull_policy"`
        Resources       *ResourcesConfig       `yaml:"resources"`
        Volumes         []*VolumeConfig        `yaml:"volumes"`
        Environment     map[string]string      `yaml:"environment"`
        SecurityContext *SecurityContextConfig `yaml:"security_context"`
        NetworkMode     string                 `yaml:"network_mode"`
}

// VolumeConfig represents volume configuration
type VolumeConfig struct {
        Name       string `yaml:"name"`
        HostPath   string `yaml:"host_path"`
        MountPath  string `yaml:"mount_path"`
        ReadOnly   bool   `yaml:"read_only"`
        VolumeType string `yaml:"volume_type"`
}

// SecurityContextConfig represents security context
type SecurityContextConfig struct {
        RunAsUser              int  `yaml:"run_as_user"`
        RunAsGroup             int  `yaml:"run_as_group"`
        FSGroup                int  `yaml:"fs_group"`
        Privileged             bool `yaml:"privileged"`
        ReadOnlyRootFilesystem bool `yaml:"read_only_root_filesystem"`
}

// NetworkingConfig represents networking configuration
type NetworkingConfig struct {
        Mode           string        `yaml:"mode"`
        Ports          []*PortConfig `yaml:"ports"`
        ExposedPorts   []string      `yaml:"exposed_ports"`
        NetworkAliases []string      `yaml:"network_aliases"`
        DNSConfig      *DNSConfig    `yaml:"dns_config"`
}

// PortConfig represents port configuration
type PortConfig struct {
        ContainerPort int    `yaml:"container_port"`
        HostPort      int    `yaml:"host_port"`
        Protocol      string `yaml:"protocol"`
}

// DNSConfig represents DNS configuration
type DNSConfig struct {
        Nameservers []string `yaml:"nameservers"`
        Search      []string `yaml:"search"`
        Options     []string `yaml:"options"`
}

// KubernetesConfig represents Kubernetes configuration
type KubernetesConfig struct {
        Enabled          bool               `yaml:"enabled"`
        Namespace        string             `yaml:"namespace"`
        ServiceAccount   string             `yaml:"service_account"`
        ConfigMapName    string             `yaml:"config_map_name"`
        PodTemplate      *PodTemplateConfig `yaml:"pod_template"`
        Service          *ServiceConfig     `yaml:"service"`
        Ingress          *IngressConfig     `yaml:"ingress"`
        StorageClass     string             `yaml:"storage_class"`
        PersistentVolume *PVConfig          `yaml:"persistent_volume"`
}

// PodTemplateConfig represents pod template configuration
type PodTemplateConfig struct {
        Labels       map[string]string   `yaml:"labels"`
        Annotations  map[string]string   `yaml:"annotations"`
        NodeSelector map[string]string   `yaml:"node_selector"`
        Tolerations  []*TolerationConfig `yaml:"tolerations"`
        Affinity     *AffinityConfig     `yaml:"affinity"`
}

// TolerationConfig represents toleration configuration
type TolerationConfig struct {
        Key      string `yaml:"key"`
        Operator string `yaml:"operator"`
        Value    string `yaml:"value"`
        Effect   string `yaml:"effect"`
}

// AffinityConfig represents affinity configuration
type AffinityConfig struct {
        NodeAffinity *NodeAffinityConfig `yaml:"node_affinity"`
        PodAffinity  *PodAffinityConfig  `yaml:"pod_affinity"`
}

// NodeAffinityConfig represents node affinity configuration
type NodeAffinityConfig struct {
        RequiredDuringSchedulingIgnoredDuringExecution  *NodeSelectorConfig    `yaml:"required_during_scheduling_ignored_during_execution"`
        PreferredDuringSchedulingIgnoredDuringExecution []*PreferredScheduling `yaml:"preferred_during_scheduling_ignored_during_execution"`
}

// NodeSelectorConfig represents node selector configuration
type NodeSelectorConfig struct {
        NodeSelectorTerms []*NodeSelectorTerm `yaml:"node_selector_terms"`
}

// NodeSelectorTerm represents node selector term
type NodeSelectorTerm struct {
        MatchExpressions []*MatchExpression `yaml:"match_expressions"`
        MatchFields      []*MatchExpression `yaml:"match_fields"`
}

// MatchExpression represents match expression
type MatchExpression struct {
        Key      string   `yaml:"key"`
        Operator string   `yaml:"operator"`
        Values   []string `yaml:"values"`
}

// PreferredScheduling represents preferred scheduling
type PreferredScheduling struct {
        Weight     int               `yaml:"weight"`
        Preference *NodeSelectorTerm `yaml:"preference"`
}

// PodAffinityConfig represents pod affinity configuration
type PodAffinityConfig struct {
        RequiredDuringSchedulingIgnoredDuringExecution  []*PodAffinityTerm         `yaml:"required_during_scheduling_ignored_during_execution"`
        PreferredDuringSchedulingIgnoredDuringExecution []*WeightedPodAffinityTerm `yaml:"preferred_during_scheduling_ignored_during_execution"`
}

// PodAffinityTerm represents pod affinity term
type PodAffinityTerm struct {
        LabelSelector *LabelSelector `yaml:"label_selector"`
        TopologyKey   string         `yaml:"topology_key"`
}

// WeightedPodAffinityTerm represents weighted pod affinity term
type WeightedPodAffinityTerm struct {
        Weight          int              `yaml:"weight"`
        PodAffinityTerm *PodAffinityTerm `yaml:"pod_affinity_term"`
}

// LabelSelector represents label selector
type LabelSelector struct {
        MatchLabels      map[string]string  `yaml:"match_labels"`
        MatchExpressions []*MatchExpression `yaml:"match_expressions"`
}

// ServiceConfig represents service configuration
type ServiceConfig struct {
        Type      string            `yaml:"type"`
        Ports     []*ServicePort    `yaml:"ports"`
        Selector  map[string]string `yaml:"selector"`
        ClusterIP string            `yaml:"cluster_ip"`
}

// ServicePort represents service port
type ServicePort struct {
        Name       string `yaml:"name"`
        Port       int    `yaml:"port"`
        TargetPort int    `yaml:"target_port"`
        Protocol   string `yaml:"protocol"`
}

// IngressConfig represents ingress configuration
type IngressConfig struct {
        Enabled     bool              `yaml:"enabled"`
        Annotations map[string]string `yaml:"annotations"`
        Rules       []*IngressRule    `yaml:"rules"`
        TLS         []*IngressTLS     `yaml:"tls"`
}

// IngressRule represents ingress rule
type IngressRule struct {
        Host  string         `yaml:"host"`
        Paths []*IngressPath `yaml:"paths"`
}

// IngressPath represents ingress path
type IngressPath struct {
        Path     string          `yaml:"path"`
        PathType string          `yaml:"path_type"`
        Backend  *IngressBackend `yaml:"backend"`
}

// IngressBackend represents ingress backend
type IngressBackend struct {
        Service *IngressServiceBackend `yaml:"service"`
}

// IngressServiceBackend represents ingress service backend
type IngressServiceBackend struct {
        Name string             `yaml:"name"`
        Port *ServicePortConfig `yaml:"port"`
}

// ServicePortConfig represents service port configuration
type ServicePortConfig struct {
        Number int    `yaml:"number"`
        Name   string `yaml:"name"`
}

// IngressTLS represents ingress TLS
type IngressTLS struct {
        Hosts      []string `yaml:"hosts"`
        SecretName string   `yaml:"secret_name"`
}

// PVConfig represents persistent volume configuration
type PVConfig struct {
        Size         string   `yaml:"size"`
        StorageClass string   `yaml:"storage_class"`
        AccessModes  []string `yaml:"access_modes"`
}

// ProcessPoolConfig represents process pool configuration
type ProcessPoolConfig struct {
        Enabled             bool   `yaml:"enabled"`
        MinProcesses        int    `yaml:"min_processes"`
        MaxProcesses        int    `yaml:"max_processes"`
        IdleTimeout         string `yaml:"idle_timeout"`
        RespawnInterval     string `yaml:"respawn_interval"`
        HealthCheckInterval string `yaml:"health_check_interval"`
}

// ContainerRuntimeConfig represents container runtime configuration
type ContainerRuntimeConfig struct {
        Runtime      string          `yaml:"runtime"`
        RuntimePath  string          `yaml:"runtime_path"`
        RuntimeArgs  []string        `yaml:"runtime_args"`
        NetworkMode  string          `yaml:"network_mode"`
        CgroupParent string          `yaml:"cgroup_parent"`
        ShmSize      string          `yaml:"shm_size"`
        Ulimits      []*UlimitConfig `yaml:"ulimits"`
}

// UlimitConfig represents ulimit configuration
type UlimitConfig struct {
        Name string `yaml:"name"`
        Soft int64  `yaml:"soft"`
        Hard int64  `yaml:"hard"`
}

// IsolationConfig represents isolation configuration
type IsolationConfig struct {
        Namespaces   *NamespaceConfig  `yaml:"namespaces"`
        Cgroups      *CgroupConfig     `yaml:"cgroups"`
        Capabilities *CapabilityConfig `yaml:"capabilities"`
        Seccomp      *SeccompConfig    `yaml:"seccomp"`
        AppArmor     *AppArmorConfig   `yaml:"apparmor"`
}

// NamespaceConfig represents namespace configuration
type NamespaceConfig struct {
        PID     bool `yaml:"pid"`
        Network bool `yaml:"network"`
        Mount   bool `yaml:"mount"`
        UTS     bool `yaml:"uts"`
        IPC     bool `yaml:"ipc"`
        User    bool `yaml:"user"`
}

// CgroupConfig represents cgroup configuration
type CgroupConfig struct {
        Enabled     bool   `yaml:"enabled"`
        CgroupPath  string `yaml:"cgroup_path"`
        CPULimit    string `yaml:"cpu_limit"`
        MemoryLimit string `yaml:"memory_limit"`
        PidsLimit   int    `yaml:"pids_limit"`
}

// CapabilityConfig represents capability configuration
type CapabilityConfig struct {
        Drop []string `yaml:"drop"`
        Add  []string `yaml:"add"`
}

// SeccompConfig represents seccomp configuration
type SeccompConfig struct {
        Enabled bool   `yaml:"enabled"`
        Profile string `yaml:"profile"`
}

// AppArmorConfig represents AppArmor configuration
type AppArmorConfig struct {
        Enabled bool   `yaml:"enabled"`
        Profile string `yaml:"profile"`
}

// ChrootConfig represents chroot configuration
type ChrootConfig struct {
        Enabled  bool   `yaml:"enabled"`
        RootPath string `yaml:"root_path"`
        UserID   int    `yaml:"user_id"`
        GroupID  int    `yaml:"group_id"`
}

// ResourcesConfig represents resource configuration
type ResourcesConfig struct {
        CPULimit      string `yaml:"cpu_limit"`
        MemoryLimit   string `yaml:"memory_limit"`
        CPURequest    string `yaml:"cpu_request"`
        MemoryRequest string `yaml:"memory_request"`
        DiskLimit     string `yaml:"disk_limit"`
        NetworkLimit  string `yaml:"network_limit"`
        PidsLimit     int    `yaml:"pids_limit"`
}

// GameMonitoringConfig represents game monitoring configuration
type GameMonitoringConfig struct {
        Enabled             bool                   `yaml:"enabled"`
        HealthCheckInterval string                 `yaml:"health_check_interval"`
        MetricsInterval     string                 `yaml:"metrics_interval"`
        LogLevel            string                 `yaml:"log_level"`
        AlertThresholds     *AlertThresholdsConfig `yaml:"alert_thresholds"`
}

// AlertThresholdsConfig represents alert thresholds
type AlertThresholdsConfig struct {
        CPUUsage    float64 `yaml:"cpu_usage"`
        MemoryUsage float64 `yaml:"memory_usage"`
        DiskUsage   float64 `yaml:"disk_usage"`
        LoadAverage float64 `yaml:"load_average"`
}

// GameStorageConfig represents game storage configuration
type GameStorageConfig struct {
        GameDataPath string          `yaml:"game_data_path"`
        UserDataPath string          `yaml:"user_data_path"`
        LogPath      string          `yaml:"log_path"`
        TempPath     string          `yaml:"temp_path"`
        BackupPath   string          `yaml:"backup_path"`
        Volumes      []*VolumeConfig `yaml:"volumes"`
        Backup       *BackupConfig   `yaml:"backup"`
        Cleanup      *CleanupConfig  `yaml:"cleanup"`
}

// BackupConfig represents backup configuration
type BackupConfig struct {
        Enabled         bool   `yaml:"enabled"`
        Interval        string `yaml:"interval"`
        RetentionDays   int    `yaml:"retention_days"`
        CompressBackups bool   `yaml:"compress_backups"`
        BackupLocation  string `yaml:"backup_location"`
}

// CleanupConfig represents cleanup configuration
type CleanupConfig struct {
        Enabled            bool   `yaml:"enabled"`
        Interval           string `yaml:"interval"`
        MaxAge             string `yaml:"max_age"`
        DeleteEmptyDirs    bool   `yaml:"delete_empty_dirs"`
        PreserveRecordings bool   `yaml:"preserve_recordings"`
}

// GameSecurityConfig represents game security configuration
type GameSecurityConfig struct {
        Sandboxing    *SandboxingConfig         `yaml:"sandboxing"`
        AccessControl *AccessControlConfig      `yaml:"access_control"`
        RateLimiting  *RateLimitingConfig       `yaml:"rate_limiting"`
        Monitoring    *SecurityMonitoringConfig `yaml:"monitoring"`
}

// SandboxingConfig represents sandboxing configuration
type SandboxingConfig struct {
        Enabled         bool     `yaml:"enabled"`
        AllowedSyscalls []string `yaml:"allowed_syscalls"`
        BlockedSyscalls []string `yaml:"blocked_syscalls"`
        AllowedPaths    []string `yaml:"allowed_paths"`
        BlockedPaths    []string `yaml:"blocked_paths"`
}

// AccessControlConfig represents access control configuration
type AccessControlConfig struct {
        Enabled               bool     `yaml:"enabled"`
        AllowedUsers          []string `yaml:"allowed_users"`
        AllowedGroups         []string `yaml:"allowed_groups"`
        RequireAuthentication bool     `yaml:"require_authentication"`
        MaxConcurrentSessions int      `yaml:"max_concurrent_sessions"`
}

// SecurityMonitoringConfig represents security monitoring configuration
type SecurityMonitoringConfig struct {
        Enabled                   bool `yaml:"enabled"`
        LogSecurityEvents         bool `yaml:"log_security_events"`
        AlertOnSuspiciousActivity bool `yaml:"alert_on_suspicious_activity"`
        MonitorFileAccess         bool `yaml:"monitor_file_access"`
        MonitorNetworkAccess      bool `yaml:"monitor_network_access"`
}

// LoadGameServiceConfig loads game service configuration
func LoadGameServiceConfig(configPath string) (*GameServiceConfig, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">expanded := os.ExpandEnv(string(data))

        var config GameServiceConfig
        if err := yaml.Unmarshal([]byte(expanded), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov0" title="0">applyGameDefaults(&amp;config)

        return &amp;config, nil</span>
}

// applyGameDefaults applies default values to game configuration
func applyGameDefaults(cfg *GameServiceConfig) <span class="cov0" title="0">{
        if cfg.Version == "" </span><span class="cov0" title="0">{
                cfg.Version = "0.0.2"
        }</span>

        <span class="cov0" title="0">if cfg.Server == nil </span><span class="cov0" title="0">{
                cfg.Server = &amp;ServerConfig{
                        Port:           8084,
                        GRPCPort:       9094,
                        Host:           "0.0.0.0",
                        Timeout:        "60s",
                        MaxConnections: 1000,
                }
        }</span>

        <span class="cov0" title="0">if cfg.GameEngine == nil </span><span class="cov0" title="0">{
                cfg.GameEngine = &amp;GameEngineConfig{
                        Mode: "container",
                        ContainerRuntime: &amp;ContainerRuntimeConfig{
                                Runtime:     "docker",
                                NetworkMode: "bridge",
                                ShmSize:     "64m",
                        },
                        Isolation: &amp;IsolationConfig{
                                Namespaces: &amp;NamespaceConfig{
                                        PID:     true,
                                        Network: true,
                                        Mount:   true,
                                        UTS:     true,
                                        IPC:     true,
                                        User:    false,
                                },
                                Capabilities: &amp;CapabilityConfig{
                                        Drop: []string{"ALL"},
                                        Add:  []string{"CHOWN", "SETUID", "SETGID"},
                                },
                        },
                        Resources: &amp;ResourcesConfig{
                                CPULimit:      "1000m",
                                MemoryLimit:   "512Mi",
                                CPURequest:    "100m",
                                MemoryRequest: "128Mi",
                                PidsLimit:     100,
                        },
                        Monitoring: &amp;GameMonitoringConfig{
                                Enabled:             true,
                                HealthCheckInterval: "30s",
                                MetricsInterval:     "15s",
                                LogLevel:            "info",
                                AlertThresholds: &amp;AlertThresholdsConfig{
                                        CPUUsage:    80.0,
                                        MemoryUsage: 85.0,
                                        DiskUsage:   90.0,
                                        LoadAverage: 2.0,
                                },
                        },
                }
        }</span>

        <span class="cov0" title="0">if cfg.Kubernetes == nil </span><span class="cov0" title="0">{
                cfg.Kubernetes = &amp;KubernetesConfig{
                        Enabled:        false,
                        Namespace:      "dungeongate",
                        ServiceAccount: "dungeongate-game-service",
                        ConfigMapName:  "dungeongate-game-config",
                }
        }</span>

        <span class="cov0" title="0">if cfg.Storage == nil </span><span class="cov0" title="0">{
                cfg.Storage = &amp;GameStorageConfig{
                        GameDataPath: "/var/lib/dungeongate/games",
                        UserDataPath: "/var/lib/dungeongate/users",
                        LogPath:      "/var/log/dungeongate/games",
                        TempPath:     "/tmp/dungeongate/games",
                        BackupPath:   "/var/backups/dungeongate",
                        Backup: &amp;BackupConfig{
                                Enabled:         true,
                                Interval:        "24h",
                                RetentionDays:   30,
                                CompressBackups: true,
                        },
                        Cleanup: &amp;CleanupConfig{
                                Enabled:            true,
                                Interval:           "1h",
                                MaxAge:             "7d",
                                DeleteEmptyDirs:    true,
                                PreserveRecordings: true,
                        },
                }
        }</span>

        <span class="cov0" title="0">if cfg.Security == nil </span><span class="cov0" title="0">{
                cfg.Security = &amp;GameSecurityConfig{
                        Sandboxing: &amp;SandboxingConfig{
                                Enabled: true,
                                AllowedSyscalls: []string{
                                        "read", "write", "open", "close", "stat", "fstat",
                                        "lstat", "poll", "lseek", "mmap", "mprotect", "munmap",
                                        "brk", "rt_sigaction", "rt_sigprocmask", "rt_sigreturn",
                                        "ioctl", "access", "pipe", "select", "sched_yield",
                                        "mremap", "msync", "mincore", "madvise", "shmget",
                                        "shmat", "shmctl", "dup", "dup2", "pause", "nanosleep",
                                        "getitimer", "alarm", "setitimer", "getpid", "sendfile",
                                        "socket", "connect", "accept", "sendto", "recvfrom",
                                        "sendmsg", "recvmsg", "shutdown", "bind", "listen",
                                        "getsockname", "getpeername", "socketpair", "setsockopt",
                                        "getsockopt", "clone", "fork", "vfork", "execve", "exit",
                                        "wait4", "kill", "uname", "semget", "semop", "semctl",
                                        "shmdt", "msgget", "msgsnd", "msgrcv", "msgctl", "fcntl",
                                        "flock", "fsync", "fdatasync", "truncate", "ftruncate",
                                        "getdents", "getcwd", "chdir", "fchdir", "rename", "mkdir",
                                        "rmdir", "creat", "link", "unlink", "symlink", "readlink",
                                        "chmod", "fchmod", "chown", "fchown", "lchown", "umask",
                                        "gettimeofday", "getrlimit", "getrusage", "sysinfo",
                                        "times", "ptrace", "getuid", "syslog", "getgid", "setuid",
                                        "setgid", "geteuid", "getegid", "setpgid", "getppid",
                                        "getpgrp", "setsid", "setreuid", "setregid", "getgroups",
                                        "setgroups", "setresuid", "getresuid", "setresgid",
                                        "getresgid", "getpgid", "setfsuid", "setfsgid", "getsid",
                                        "capget", "capset", "rt_sigpending", "rt_sigtimedwait",
                                        "rt_sigqueueinfo", "rt_sigsuspend", "sigaltstack",
                                        "utime", "mknod", "uselib", "personality", "ustat",
                                        "statfs", "fstatfs", "sysfs", "getpriority", "setpriority",
                                        "sched_setparam", "sched_getparam", "sched_setscheduler",
                                        "sched_getscheduler", "sched_get_priority_max",
                                        "sched_get_priority_min", "sched_rr_get_interval",
                                        "mlock", "munlock", "mlockall", "munlockall", "vhangup",
                                        "modify_ldt", "pivot_root", "prctl", "arch_prctl",
                                        "adjtimex", "setrlimit", "chroot", "sync", "acct",
                                        "settimeofday", "mount", "umount2", "swapon", "swapoff",
                                        "reboot", "sethostname", "setdomainname", "iopl", "ioperm",
                                        "create_module", "init_module", "delete_module",
                                        "get_kernel_syms", "query_module", "quotactl", "nfsservctl",
                                        "getpmsg", "putpmsg", "afs_syscall", "tuxcall", "security",
                                        "gettid", "readahead", "setxattr", "lsetxattr", "fsetxattr",
                                        "getxattr", "lgetxattr", "fgetxattr", "listxattr",
                                        "llistxattr", "flistxattr", "removexattr", "lremovexattr",
                                        "fremovexattr", "tkill", "time", "futex", "sched_setaffinity",
                                        "sched_getaffinity", "set_thread_area", "io_setup",
                                        "io_destroy", "io_getevents", "io_submit", "io_cancel",
                                        "get_thread_area", "lookup_dcookie", "epoll_create",
                                        "epoll_ctl_old", "epoll_wait_old", "remap_file_pages",
                                        "getdents64", "set_tid_address", "restart_syscall",
                                        "semtimedop", "fadvise64", "timer_create", "timer_settime",
                                        "timer_gettime", "timer_getoverrun", "timer_delete",
                                        "clock_settime", "clock_gettime", "clock_getres",
                                        "clock_nanosleep", "exit_group", "epoll_wait", "epoll_ctl",
                                        "tgkill", "utimes", "vserver", "mbind", "set_mempolicy",
                                        "get_mempolicy", "mq_open", "mq_unlink", "mq_timedsend",
                                        "mq_timedreceive", "mq_notify", "mq_getsetattr", "kexec_load",
                                        "waitid", "add_key", "request_key", "keyctl", "ioprio_set",
                                        "ioprio_get", "inotify_init", "inotify_add_watch",
                                        "inotify_rm_watch", "migrate_pages", "openat", "mkdirat",
                                        "mknodat", "fchownat", "futimesat", "newfstatat", "unlinkat",
                                        "renameat", "linkat", "symlinkat", "readlinkat", "fchmodat",
                                        "faccessat", "pselect6", "ppoll", "unshare", "set_robust_list",
                                        "get_robust_list", "splice", "tee", "sync_file_range",
                                        "vmsplice", "move_pages", "utimensat", "epoll_pwait",
                                        "signalfd", "timerfd_create", "eventfd", "fallocate",
                                        "timerfd_settime", "timerfd_gettime", "accept4", "signalfd4",
                                        "eventfd2", "epoll_create1", "dup3", "pipe2", "inotify_init1",
                                        "preadv", "pwritev", "rt_tgsigqueueinfo", "perf_event_open",
                                        "recvmmsg", "fanotify_init", "fanotify_mark", "prlimit64",
                                        "name_to_handle_at", "open_by_handle_at", "clock_adjtime",
                                        "syncfs", "sendmmsg", "setns", "getcpu", "process_vm_readv",
                                        "process_vm_writev", "kcmp", "finit_module", "sched_setattr",
                                        "sched_getattr", "renameat2", "seccomp", "getrandom",
                                        "memfd_create", "kexec_file_load", "bpf", "execveat",
                                        "userfaultfd", "membarrier", "mlock2", "copy_file_range",
                                        "preadv2", "pwritev2", "pkey_mprotect", "pkey_alloc",
                                        "pkey_free", "statx", "io_pgetevents", "rseq",
                                },
                                AllowedPaths: []string{
                                        "/usr/games",
                                        "/var/games",
                                        "/tmp",
                                        "/dev/null",
                                        "/dev/zero",
                                        "/dev/random",
                                        "/dev/urandom",
                                        "/proc/self",
                                        "/proc/thread-self",
                                        "/proc/version",
                                        "/proc/cpuinfo",
                                        "/proc/meminfo",
                                        "/proc/stat",
                                        "/proc/uptime",
                                        "/proc/loadavg",
                                        "/etc/passwd",
                                        "/etc/group",
                                        "/etc/hosts",
                                        "/etc/resolv.conf",
                                        "/etc/nsswitch.conf",
                                        "/etc/ld.so.cache",
                                        "/etc/ld.so.conf",
                                        "/etc/ld.so.conf.d",
                                        "/lib",
                                        "/lib64",
                                        "/usr/lib",
                                        "/usr/lib64",
                                        "/usr/share/terminfo",
                                        "/usr/share/locale",
                                },
                                BlockedPaths: []string{
                                        "/etc/shadow",
                                        "/etc/sudoers",
                                        "/etc/ssh",
                                        "/root",
                                        "/home",
                                        "/var/log",
                                        "/var/run",
                                        "/var/lib/dpkg",
                                        "/var/lib/apt",
                                        "/boot",
                                        "/sys",
                                        "/proc/sys",
                                        "/proc/*/mem",
                                        "/proc/*/maps",
                                        "/proc/*/environ",
                                        "/proc/*/cmdline",
                                        "/proc/kcore",
                                        "/proc/kmem",
                                        "/proc/kallsyms",
                                        "/proc/modules",
                                        "/dev/mem",
                                        "/dev/kmem",
                                        "/dev/port",
                                },
                        },
                        AccessControl: &amp;AccessControlConfig{
                                Enabled:               true,
                                RequireAuthentication: true,
                                MaxConcurrentSessions: 10,
                        },
                        RateLimiting: &amp;RateLimitingConfig{
                                Enabled:             true,
                                MaxConnectionsPerIP: 5,
                                ConnectionWindow:    "1m",
                        },
                        Monitoring: &amp;SecurityMonitoringConfig{
                                Enabled:                   true,
                                LogSecurityEvents:         true,
                                AlertOnSuspiciousActivity: true,
                                MonitorFileAccess:         true,
                                MonitorNetworkAccess:      true,
                        },
                }
        }</span>
}

// Validate validates the game service configuration
func (cfg *GameServiceConfig) Validate() error <span class="cov0" title="0">{
        if cfg.Server == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server configuration is required")
        }</span>
        <span class="cov0" title="0">if cfg.GameEngine == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("game engine configuration is required")
        }</span>
        <span class="cov0" title="0">if cfg.Storage == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("storage configuration is required")
        }</span>

        // Validate game engine mode
        <span class="cov0" title="0">switch cfg.GameEngine.Mode </span>{
        case "container", "process", "hybrid":<span class="cov0" title="0"></span>
                // Valid modes
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid game engine mode: %s", cfg.GameEngine.Mode)</span>
        }

        // Validate individual game configurations
        <span class="cov0" title="0">for _, game := range cfg.Games </span><span class="cov0" title="0">{
                if err := game.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("game %s validation failed: %w", game.ID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Validate validates a game configuration
func (game *GameConfig) Validate() error <span class="cov0" title="0">{
        if game.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("game ID is required")
        }</span>
        <span class="cov0" title="0">if game.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("game name is required")
        }</span>
        <span class="cov0" title="0">if game.Binary == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("binary configuration is required")
        }</span>
        <span class="cov0" title="0">if game.Binary.Path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("binary path is required")
        }</span>

        // Validate resource limits
        <span class="cov0" title="0">if game.Resources != nil </span><span class="cov0" title="0">{
                if game.Resources.CPULimit != "" </span><span class="cov0" title="0">{
                        if _, err := ParseResourceQuantity(game.Resources.CPULimit); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid CPU limit: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">if game.Resources.MemoryLimit != "" </span><span class="cov0" title="0">{
                        if _, err := ParseResourceQuantity(game.Resources.MemoryLimit); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid memory limit: %w", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// ParseResourceQuantity parses a resource quantity string
func ParseResourceQuantity(s string) (int64, error) <span class="cov0" title="0">{
        // Simple implementation - in production, use k8s.io/apimachinery/pkg/api/resource
        // For now, just validate it's not empty
        if s == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("resource quantity cannot be empty")
        }</span>
        <span class="cov0" title="0">return 1, nil</span>
}

// GetGameTimeoutDuration returns game timeout as duration
func (game *GameConfig) GetGameTimeoutDuration() time.Duration <span class="cov0" title="0">{
        if game.Settings != nil &amp;&amp; game.Settings.MaxSessionDuration != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(game.Settings.MaxSessionDuration); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return 4 * time.Hour</span> // Default fallback
}

// GetIdleTimeoutDuration returns idle timeout as duration
func (game *GameConfig) GetIdleTimeoutDuration() time.Duration <span class="cov0" title="0">{
        if game.Settings != nil &amp;&amp; game.Settings.IdleTimeout != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(game.Settings.IdleTimeout); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return 30 * time.Minute</span> // Default fallback
}

// GetDefaultNetHackConfig returns a default NetHack game configuration
func GetDefaultNetHackConfig() *GameConfig <span class="cov0" title="0">{
        return &amp;GameConfig{
                ID:        "nethack",
                Name:      "NetHack",
                ShortName: "nh",
                Version:   "3.7.0",
                Enabled:   true,
                Binary: &amp;BinaryConfig{
                        Path:             "/usr/games/nethack",
                        Args:             []string{"-u", "${USERNAME}"},
                        WorkingDirectory: "/var/games/nethack",
                        User:             "games",
                        Group:            "games",
                        Permissions:      "0755",
                },
                Files: &amp;FilesConfig{
                        DataDirectory:   "/var/games/nethack",
                        SaveDirectory:   "/var/games/nethack/save",
                        ConfigDirectory: "/var/games/nethack/config",
                        LogDirectory:    "/var/log/nethack",
                        TempDirectory:   "/tmp/nethack",
                        SharedFiles:     []string{"nhdat", "license", "recover"},
                        UserFiles:       []string{"${USERNAME}.nh", "${USERNAME}.0", "${USERNAME}.bak"},
                        Permissions: &amp;PermissionsConfig{
                                DataDirectory: "0755",
                                SaveDirectory: "0755",
                                UserFiles:     "0644",
                                LogFiles:      "0644",
                        },
                },
                Settings: &amp;GameSettings{
                        MaxPlayers:         50,
                        MaxSessionDuration: "4h",
                        IdleTimeout:        "30m",
                        SaveInterval:       "5m",
                        AutoSave:           true,
                        Spectating: &amp;SpectatingConfig{
                                Enabled:                 true,
                                MaxSpectatorsPerSession: 5,
                                SpectatorTimeout:        "2h",
                        },
                        Recording: &amp;RecordingConfig{
                                Enabled:       true,
                                Format:        "ttyrec",
                                Compression:   "gzip",
                                MaxFileSize:   "100MB",
                                RetentionDays: 30,
                                AutoCleanup:   true,
                        },
                        Options: map[string]string{
                                "MAXNROFPLAYERS": "50",
                                "SEDLEVEL":       "5",
                                "DUMPLOG":        "1",
                                "LIVELOG":        "1",
                                "XLOGFILE":       "/var/games/nethack/xlogfile",
                                "LIVELOGFILE":    "/var/games/nethack/livelog",
                        },
                },
                Environment: map[string]string{
                        "NETHACKOPTIONS": "@/var/games/nethack/config/${USERNAME}.nethackrc",
                        "HACKDIR":        "/var/games/nethack",
                        "TERM":           "xterm-256color",
                        "USER":           "${USERNAME}",
                        "HOME":           "/var/games/nethack/users/${USERNAME}",
                        "SHELL":          "/bin/sh",
                },
                Resources: &amp;ResourcesConfig{
                        CPULimit:      "500m",
                        MemoryLimit:   "256Mi",
                        CPURequest:    "100m",
                        MemoryRequest: "64Mi",
                        DiskLimit:     "1Gi",
                        PidsLimit:     50,
                },
                Container: &amp;ContainerConfig{
                        Image:      "dungeongate/nethack",
                        Tag:        "3.7.0",
                        Registry:   "ghcr.io",
                        PullPolicy: "IfNotPresent",
                        Volumes: []*VolumeConfig{
                                {
                                        Name:      "nethack-data",
                                        HostPath:  "/var/games/nethack",
                                        MountPath: "/var/games/nethack",
                                        ReadOnly:  false,
                                },
                                {
                                        Name:      "nethack-saves",
                                        HostPath:  "/var/games/nethack/save",
                                        MountPath: "/var/games/nethack/save",
                                        ReadOnly:  false,
                                },
                        },
                        Environment: map[string]string{
                                "GAME":     "nethack",
                                "USERNAME": "${USERNAME}",
                                "TERM":     "xterm-256color",
                        },
                        SecurityContext: &amp;SecurityContextConfig{
                                RunAsUser:              1000,
                                RunAsGroup:             1000,
                                ReadOnlyRootFilesystem: true,
                                Privileged:             false,
                        },
                        NetworkMode: "none",
                },
                Networking: &amp;NetworkingConfig{
                        Mode: "isolated",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package config

import (
        "fmt"
        "os"
        "time"

        "gopkg.in/yaml.v3"
)

// SessionServiceConfig represents session service configuration
type SessionServiceConfig struct {
        Version           string                   `yaml:"version"`
        Server            *ServerConfig            `yaml:"server"`
        SSH               *SSHConfig               `yaml:"ssh"`
        SessionManagement *SessionManagementConfig `yaml:"session_management"`
        Encryption        *EncryptionConfig        `yaml:"encryption"`
        Database          *DatabaseConfig          `yaml:"database"`
        Menu              *MenuConfig              `yaml:"menu"`
        Services          *ServicesConfig          `yaml:"services"`
        Storage           *StorageConfig           `yaml:"storage"`
        Logging           *LoggingConfig           `yaml:"logging"`
        Metrics           *MetricsConfig           `yaml:"metrics"`
        Health            *HealthConfig            `yaml:"health"`
        Security          *SecurityConfig          `yaml:"security"`
        Auth              *AuthServiceConfig       `yaml:"auth"`
        User              *UserConfig              `yaml:"user"`
        Games             []*GameConfig            `yaml:"games"`
}

// SSHConfig represents SSH server configuration
type SSHConfig struct {
        Enabled        bool               `yaml:"enabled"`
        Port           int                `yaml:"port"`
        Host           string             `yaml:"host"`
        HostKeyPath    string             `yaml:"host_key_path"`
        Banner         string             `yaml:"banner"`
        MaxSessions    int                `yaml:"max_sessions"`
        SessionTimeout string             `yaml:"session_timeout"`
        IdleTimeout    string             `yaml:"idle_timeout"`
        Auth           *SSHAuthConfig     `yaml:"auth"`
        Terminal       *SSHTerminalConfig `yaml:"terminal"`
}

// SSHAuthConfig represents SSH authentication configuration
type SSHAuthConfig struct {
        PasswordAuth   bool `yaml:"password_auth"`
        PublicKeyAuth  bool `yaml:"public_key_auth"`
        AllowAnonymous bool `yaml:"allow_anonymous"`
}

// SSHTerminalConfig represents SSH terminal configuration
type SSHTerminalConfig struct {
        DefaultSize        string   `yaml:"default_size"`
        MaxSize            string   `yaml:"max_size"`
        SupportedTerminals []string `yaml:"supported_terminals"`
}

// MenuConfig represents menu configuration
type MenuConfig struct {
        Banners *BannersConfig `yaml:"banners"`
        Options *MenuOptions   `yaml:"options"`
}

// BannersConfig represents banner configuration
type BannersConfig struct {
        MainAnon  string `yaml:"main_anon"`
        MainUser  string `yaml:"main_user"`
        WatchMenu string `yaml:"watch_menu"`
}

// MenuOptions represents menu options configuration
type MenuOptions struct {
        Anonymous     []*MenuOption `yaml:"anonymous"`
        Authenticated []*MenuOption `yaml:"authenticated"`
}

// MenuOption represents a menu option
type MenuOption struct {
        Key    string `yaml:"key"`
        Label  string `yaml:"label"`
        Action string `yaml:"action"`
}

// ServicesConfig represents services configuration
type ServicesConfig struct {
        AuthService string `yaml:"auth_service"`
        UserService string `yaml:"user_service"`
        GameService string `yaml:"game_service"`
}

// StorageConfig represents storage configuration
type StorageConfig struct {
        TTYRecPath string `yaml:"ttyrec_path"`
        TempPath   string `yaml:"temp_path"`
}

// MetricsConfig represents metrics configuration
type MetricsConfig struct {
        Enabled bool `yaml:"enabled"`
        Port    int  `yaml:"port"`
}

// HealthConfig represents health check configuration
type HealthConfig struct {
        Enabled bool   `yaml:"enabled"`
        Path    string `yaml:"path"`
}

// SecurityConfig represents security configuration
type SecurityConfig struct {
        RateLimiting         *RateLimitingConfig    `yaml:"rate_limiting"`
        BruteForceProtection *BruteForceConfig      `yaml:"brute_force_protection"`
        SessionSecurity      *SessionSecurityConfig `yaml:"session_security"`
}

// RateLimitingConfig represents rate limiting configuration
type RateLimitingConfig struct {
        Enabled             bool   `yaml:"enabled"`
        MaxConnectionsPerIP int    `yaml:"max_connections_per_ip"`
        ConnectionWindow    string `yaml:"connection_window"`
}

// BruteForceConfig represents brute force protection configuration
type BruteForceConfig struct {
        Enabled           bool   `yaml:"enabled"`
        MaxFailedAttempts int    `yaml:"max_failed_attempts"`
        LockoutDuration   string `yaml:"lockout_duration"`
}

// SessionSecurityConfig represents session security configuration
type SessionSecurityConfig struct {
        RequireEncryption  bool `yaml:"require_encryption"`
        SessionTokenLength int  `yaml:"session_token_length"`
        SecureRandom       bool `yaml:"secure_random"`
}

// AuthServiceConfig represents authentication service configuration
type AuthServiceConfig struct {
        Enabled                bool   `yaml:"enabled"`
        ServiceAddress         string `yaml:"service_address"`
        JWTSecret              string `yaml:"jwt_secret"`
        JWTIssuer              string `yaml:"jwt_issuer"`
        AccessTokenExpiration  string `yaml:"access_token_expiration"`
        RefreshTokenExpiration string `yaml:"refresh_token_expiration"`
        MaxLoginAttempts       int    `yaml:"max_login_attempts"`
        LockoutDuration        string `yaml:"lockout_duration"`
        RequireTokenForAPI     bool   `yaml:"require_token_for_api"`
        RequireTokenForSSH     bool   `yaml:"require_token_for_ssh"`
}

// LoadSessionServiceConfig loads session service configuration
func LoadSessionServiceConfig(configPath string) (*SessionServiceConfig, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Expand environment variables
        <span class="cov0" title="0">expanded := os.ExpandEnv(string(data))

        var config SessionServiceConfig
        if err := yaml.Unmarshal([]byte(expanded), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        // Apply defaults
        <span class="cov0" title="0">applyDefaults(&amp;config)

        return &amp;config, nil</span>
}

// applyDefaults applies default values to configuration
func applyDefaults(cfg *SessionServiceConfig) <span class="cov0" title="0">{
        // Version default
        if cfg.Version == "" </span><span class="cov0" title="0">{
                cfg.Version = "0.0.2"
        }</span>

        // Server defaults
        <span class="cov0" title="0">if cfg.Server == nil </span><span class="cov0" title="0">{
                cfg.Server = &amp;ServerConfig{}
        }</span>
        <span class="cov0" title="0">if cfg.Server.Port == 0 </span><span class="cov0" title="0">{
                cfg.Server.Port = 8083
        }</span>
        <span class="cov0" title="0">if cfg.Server.GRPCPort == 0 </span><span class="cov0" title="0">{
                cfg.Server.GRPCPort = 9093
        }</span>
        <span class="cov0" title="0">if cfg.Server.Host == "" </span><span class="cov0" title="0">{
                cfg.Server.Host = "0.0.0.0"
        }</span>
        <span class="cov0" title="0">if cfg.Server.Timeout == "" </span><span class="cov0" title="0">{
                cfg.Server.Timeout = "60s"
        }</span>
        <span class="cov0" title="0">if cfg.Server.MaxConnections == 0 </span><span class="cov0" title="0">{
                cfg.Server.MaxConnections = 1000
        }</span>

        // SSH defaults
        <span class="cov0" title="0">if cfg.SSH == nil </span><span class="cov0" title="0">{
                cfg.SSH = &amp;SSHConfig{}
        }</span>
        <span class="cov0" title="0">if cfg.SSH.Port == 0 </span><span class="cov0" title="0">{
                cfg.SSH.Port = 22
        }</span>
        <span class="cov0" title="0">if cfg.SSH.Host == "" </span><span class="cov0" title="0">{
                cfg.SSH.Host = "0.0.0.0"
        }</span>
        <span class="cov0" title="0">if cfg.SSH.HostKeyPath == "" </span><span class="cov0" title="0">{
                cfg.SSH.HostKeyPath = "/etc/ssh/ssh_host_rsa_key"
        }</span>
        <span class="cov0" title="0">if cfg.SSH.Banner == "" </span><span class="cov0" title="0">{
                cfg.SSH.Banner = "Welcome to DungeonGate!\r\n"
        }</span>
        <span class="cov0" title="0">if cfg.SSH.MaxSessions == 0 </span><span class="cov0" title="0">{
                cfg.SSH.MaxSessions = 100
        }</span>
        <span class="cov0" title="0">if cfg.SSH.SessionTimeout == "" </span><span class="cov0" title="0">{
                cfg.SSH.SessionTimeout = "4h"
        }</span>
        <span class="cov0" title="0">if cfg.SSH.IdleTimeout == "" </span><span class="cov0" title="0">{
                cfg.SSH.IdleTimeout = "30m"
        }</span>
        <span class="cov0" title="0">if cfg.SSH.Auth == nil </span><span class="cov0" title="0">{
                cfg.SSH.Auth = &amp;SSHAuthConfig{
                        PasswordAuth:   true,
                        PublicKeyAuth:  false,
                        AllowAnonymous: true,
                }
        }</span>
        <span class="cov0" title="0">if cfg.SSH.Terminal == nil </span><span class="cov0" title="0">{
                cfg.SSH.Terminal = &amp;SSHTerminalConfig{
                        DefaultSize:        "80x24",
                        MaxSize:            "200x50",
                        SupportedTerminals: []string{"xterm", "xterm-256color", "screen", "tmux", "vt100"},
                }
        }</span>

        // Session management defaults
        <span class="cov0" title="0">if cfg.SessionManagement == nil </span><span class="cov0" title="0">{
                cfg.SessionManagement = &amp;SessionManagementConfig{}
        }</span>
        <span class="cov0" title="0">if cfg.SessionManagement.Terminal == nil </span><span class="cov0" title="0">{
                cfg.SessionManagement.Terminal = &amp;TerminalConfig{
                        DefaultSize: "80x24",
                        MaxSize:     "200x50",
                        Encoding:    "utf-8",
                }
        }</span>
        <span class="cov0" title="0">if cfg.SessionManagement.Timeouts == nil </span><span class="cov0" title="0">{
                cfg.SessionManagement.Timeouts = &amp;TimeoutsConfig{
                        IdleTimeout:        "30m",
                        MaxSessionDuration: "4h",
                        CleanupInterval:    "5m",
                }
        }</span>
        <span class="cov0" title="0">if cfg.SessionManagement.TTYRec == nil </span><span class="cov0" title="0">{
                cfg.SessionManagement.TTYRec = &amp;TTYRecConfig{
                        Enabled:       true,
                        Compression:   "gzip",
                        Directory:     "/dgldir/ttyrec",
                        MaxFileSize:   "100MB",
                        RetentionDays: 30,
                }
        }</span>
        <span class="cov0" title="0">if cfg.SessionManagement.Monitoring == nil </span><span class="cov0" title="0">{
                cfg.SessionManagement.Monitoring = &amp;MonitoringConfig{
                        Enabled: true,
                        Port:    8085,
                }
        }</span>
        <span class="cov0" title="0">if cfg.SessionManagement.Spectating == nil </span><span class="cov0" title="0">{
                cfg.SessionManagement.Spectating = &amp;SpectatingConfig{
                        Enabled:                 true,
                        MaxSpectatorsPerSession: 10,
                        SpectatorTimeout:        "2h",
                }
        }</span>

        // Encryption defaults
        <span class="cov0" title="0">if cfg.Encryption == nil </span><span class="cov0" title="0">{
                cfg.Encryption = &amp;EncryptionConfig{
                        Enabled:             true,
                        Algorithm:           "AES-256-GCM",
                        KeyRotationInterval: "24h",
                }
        }</span>

        // Menu defaults
        <span class="cov0" title="0">if cfg.Menu == nil </span><span class="cov0" title="0">{
                cfg.Menu = &amp;MenuConfig{
                        Banners: &amp;BannersConfig{
                                MainAnon:  "/etc/dungeongate/banners/main_anon.txt",
                                MainUser:  "/etc/dungeongate/banners/main_user.txt",
                                WatchMenu: "/etc/dungeongate/banners/watch_menu.txt",
                        },
                        Options: &amp;MenuOptions{
                                Anonymous: []*MenuOption{
                                        {Key: "l", Label: "Login", Action: "login"},
                                        {Key: "r", Label: "Register", Action: "register"},
                                        {Key: "w", Label: "Watch games", Action: "watch"},
                                        {Key: "g", Label: "List games", Action: "list_games"},
                                        {Key: "q", Label: "Quit", Action: "quit"},
                                },
                                Authenticated: []*MenuOption{
                                        {Key: "p", Label: "Play a game", Action: "play"},
                                        {Key: "w", Label: "Watch games", Action: "watch"},
                                        {Key: "e", Label: "Edit profile", Action: "edit_profile"},
                                        {Key: "l", Label: "List games", Action: "list_games"},
                                        {Key: "r", Label: "View recordings", Action: "recordings"},
                                        {Key: "s", Label: "Statistics", Action: "stats"},
                                        {Key: "q", Label: "Quit", Action: "quit"},
                                },
                        },
                }
        }</span>

        // Services defaults
        <span class="cov0" title="0">if cfg.Services == nil </span><span class="cov0" title="0">{
                cfg.Services = &amp;ServicesConfig{
                        AuthService: "auth-service:9090",
                        UserService: "user-service:9091",
                        GameService: "game-service:9092",
                }
        }</span>

        // Storage defaults
        <span class="cov0" title="0">if cfg.Storage == nil </span><span class="cov0" title="0">{
                cfg.Storage = &amp;StorageConfig{
                        TTYRecPath: "/dgldir/ttyrec",
                        TempPath:   "/tmp/sessions",
                }
        }</span>

        // Logging defaults
        <span class="cov0" title="0">if cfg.Logging == nil </span><span class="cov0" title="0">{
                cfg.Logging = &amp;LoggingConfig{
                        Level:  "info",
                        Format: "json",
                        Output: "stdout",
                }
        }</span>

        // Metrics defaults
        <span class="cov0" title="0">if cfg.Metrics == nil </span><span class="cov0" title="0">{
                cfg.Metrics = &amp;MetricsConfig{
                        Enabled: true,
                        Port:    8085,
                }
        }</span>

        // Health defaults
        <span class="cov0" title="0">if cfg.Health == nil </span><span class="cov0" title="0">{
                cfg.Health = &amp;HealthConfig{
                        Enabled: true,
                        Path:    "/health",
                }
        }</span>

        // Security defaults
        <span class="cov0" title="0">if cfg.Security == nil </span><span class="cov0" title="0">{
                cfg.Security = &amp;SecurityConfig{
                        RateLimiting: &amp;RateLimitingConfig{
                                Enabled:             true,
                                MaxConnectionsPerIP: 10,
                                ConnectionWindow:    "1m",
                        },
                        BruteForceProtection: &amp;BruteForceConfig{
                                Enabled:           true,
                                MaxFailedAttempts: 5,
                                LockoutDuration:   "15m",
                        },
                        SessionSecurity: &amp;SessionSecurityConfig{
                                RequireEncryption:  true,
                                SessionTokenLength: 32,
                                SecureRandom:       true,
                        },
                }
        }</span>
}

// Accessor methods for configuration

// GetSSH returns SSH configuration with defaults applied
func (c *SessionServiceConfig) GetSSH() *SSHConfig <span class="cov0" title="0">{
        if c.SSH == nil </span><span class="cov0" title="0">{
                return &amp;SSHConfig{
                        Enabled:        true,
                        Port:           22,
                        Host:           "0.0.0.0",
                        HostKeyPath:    "/etc/ssh/ssh_host_rsa_key",
                        Banner:         "Welcome to DungeonGate!\r\n",
                        MaxSessions:    100,
                        SessionTimeout: "4h",
                        IdleTimeout:    "30m",
                        Auth: &amp;SSHAuthConfig{
                                PasswordAuth:   true,
                                PublicKeyAuth:  false,
                                AllowAnonymous: true,
                        },
                        Terminal: &amp;SSHTerminalConfig{
                                DefaultSize:        "80x24",
                                MaxSize:            "200x50",
                                SupportedTerminals: []string{"xterm", "xterm-256color", "screen", "tmux", "vt100"},
                        },
                }
        }</span>
        <span class="cov0" title="0">return c.SSH</span>
}

// GetMenu returns menu configuration with defaults applied
func (c *SessionServiceConfig) GetMenu() *MenuConfig <span class="cov0" title="0">{
        if c.Menu == nil </span><span class="cov0" title="0">{
                return &amp;MenuConfig{
                        Banners: &amp;BannersConfig{
                                MainAnon:  "/etc/dungeongate/banners/main_anon.txt",
                                MainUser:  "/etc/dungeongate/banners/main_user.txt",
                                WatchMenu: "/etc/dungeongate/banners/watch_menu.txt",
                        },
                        Options: &amp;MenuOptions{
                                Anonymous: []*MenuOption{
                                        {Key: "l", Label: "Login", Action: "login"},
                                        {Key: "r", Label: "Register", Action: "register"},
                                        {Key: "w", Label: "Watch games", Action: "watch"},
                                        {Key: "g", Label: "List games", Action: "list_games"},
                                        {Key: "q", Label: "Quit", Action: "quit"},
                                },
                                Authenticated: []*MenuOption{
                                        {Key: "p", Label: "Play a game", Action: "play"},
                                        {Key: "w", Label: "Watch games", Action: "watch"},
                                        {Key: "e", Label: "Edit profile", Action: "edit_profile"},
                                        {Key: "l", Label: "List games", Action: "list_games"},
                                        {Key: "r", Label: "View recordings", Action: "recordings"},
                                        {Key: "s", Label: "Statistics", Action: "stats"},
                                        {Key: "q", Label: "Quit", Action: "quit"},
                                },
                        },
                }
        }</span>
        <span class="cov0" title="0">return c.Menu</span>
}

// GetServices returns services configuration with defaults applied
func (c *SessionServiceConfig) GetServices() *ServicesConfig <span class="cov0" title="0">{
        if c.Services == nil </span><span class="cov0" title="0">{
                return &amp;ServicesConfig{
                        AuthService: "auth-service:9090",
                        UserService: "user-service:9091",
                        GameService: "game-service:9092",
                }
        }</span>
        <span class="cov0" title="0">return c.Services</span>
}

// GetStorage returns storage configuration with defaults applied
func (c *SessionServiceConfig) GetStorage() *StorageConfig <span class="cov0" title="0">{
        if c.Storage == nil </span><span class="cov0" title="0">{
                return &amp;StorageConfig{
                        TTYRecPath: "/dgldir/ttyrec",
                        TempPath:   "/tmp/sessions",
                }
        }</span>
        <span class="cov0" title="0">return c.Storage</span>
}

// Validation methods

// ValidateSSHConfig validates SSH configuration
func (c *SSHConfig) Validate() error <span class="cov0" title="0">{
        if c.Port &lt; 1 || c.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid SSH port: %d", c.Port)
        }</span>
        <span class="cov0" title="0">if c.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH host cannot be empty")
        }</span>
        <span class="cov0" title="0">if c.MaxSessions &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("max sessions must be at least 1")
        }</span>
        <span class="cov0" title="0">if c.SessionTimeout == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("session timeout cannot be empty")
        }</span>
        <span class="cov0" title="0">if c.IdleTimeout == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("idle timeout cannot be empty")
        }</span>

        // Validate timeout durations
        <span class="cov0" title="0">if _, err := time.ParseDuration(c.SessionTimeout); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid session timeout format: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := time.ParseDuration(c.IdleTimeout); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid idle timeout format: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateSessionServiceConfig validates the entire session service configuration
func (c *SessionServiceConfig) Validate() error <span class="cov0" title="0">{
        if c.Server == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server configuration is required")
        }</span>
        <span class="cov0" title="0">if c.SSH == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH configuration is required")
        }</span>
        <span class="cov0" title="0">if c.SessionManagement == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("session management configuration is required")
        }</span>
        <span class="cov0" title="0">if c.Services == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("services configuration is required")
        }</span>

        // Validate SSH configuration
        <span class="cov0" title="0">if err := c.SSH.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH configuration validation failed: %w", err)
        }</span>

        // Validate ports don't conflict
        <span class="cov0" title="0">if c.Server.Port == c.SSH.Port </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP and SSH ports cannot be the same")
        }</span>
        <span class="cov0" title="0">if c.Server.GRPCPort == c.SSH.Port </span><span class="cov0" title="0">{
                return fmt.Errorf("gRPC and SSH ports cannot be the same")
        }</span>
        <span class="cov0" title="0">if c.Server.Port == c.Server.GRPCPort </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP and gRPC ports cannot be the same")
        }</span>

        // Validate directories exist or can be created
        <span class="cov0" title="0">if c.SessionManagement.TTYRec.Enabled </span><span class="cov0" title="0">{
                if c.SessionManagement.TTYRec.Directory == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("TTY recording directory is required when recording is enabled")
                }</span>
                <span class="cov0" title="0">if err := os.MkdirAll(c.SessionManagement.TTYRec.Directory, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create TTY recording directory: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if c.Storage.TTYRecPath != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(c.Storage.TTYRecPath, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create TTY recording path: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if c.Storage.TempPath != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(c.Storage.TempPath, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create temporary path: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper functions

// GetSessionTimeoutDuration returns session timeout as duration
func (c *SSHConfig) GetSessionTimeoutDuration() time.Duration <span class="cov0" title="0">{
        if duration, err := time.ParseDuration(c.SessionTimeout); err == nil </span><span class="cov0" title="0">{
                return duration
        }</span>
        <span class="cov0" title="0">return 4 * time.Hour</span> // Default fallback
}

// GetIdleTimeoutDuration returns idle timeout as duration
func (c *SSHConfig) GetIdleTimeoutDuration() time.Duration <span class="cov0" title="0">{
        if duration, err := time.ParseDuration(c.IdleTimeout); err == nil </span><span class="cov0" title="0">{
                return duration
        }</span>
        <span class="cov0" title="0">return 30 * time.Minute</span> // Default fallback
}

// GetDefaultTerminalSize returns default terminal size as width and height
func (c *SSHTerminalConfig) GetDefaultTerminalSize() (width, height int) <span class="cov0" title="0">{
        width, height, err := ParseTerminalSize(c.DefaultSize)
        if err != nil </span><span class="cov0" title="0">{
                return 80, 24 // Safe fallback
        }</span>
        <span class="cov0" title="0">return width, height</span>
}

// GetMaxTerminalSize returns maximum terminal size as width and height
func (c *SSHTerminalConfig) GetMaxTerminalSize() (width, height int) <span class="cov0" title="0">{
        width, height, err := ParseTerminalSize(c.MaxSize)
        if err != nil </span><span class="cov0" title="0">{
                return 200, 50 // Safe fallback
        }</span>
        <span class="cov0" title="0">return width, height</span>
}

// IsTerminalSupported checks if a terminal type is supported
func (c *SSHTerminalConfig) IsTerminalSupported(termType string) bool <span class="cov0" title="0">{
        for _, supported := range c.SupportedTerminals </span><span class="cov0" title="0">{
                if supported == termType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetDefaultDevelopmentConfig returns a development configuration
func GetDefaultDevelopmentConfig() *SessionServiceConfig <span class="cov0" title="0">{
        return &amp;SessionServiceConfig{
                Server: &amp;ServerConfig{
                        Port:           8083,
                        GRPCPort:       9093,
                        Host:           "localhost",
                        Timeout:        "30s",
                        MaxConnections: 100,
                },
                SSH: &amp;SSHConfig{
                        Enabled:        true,
                        Port:           2222, // Non-privileged port for development
                        Host:           "localhost",
                        HostKeyPath:    "./ssh_host_rsa_key",
                        Banner:         "Welcome to DungeonGate Development Server!\r\n",
                        MaxSessions:    10,
                        SessionTimeout: "1h",
                        IdleTimeout:    "15m",
                        Auth: &amp;SSHAuthConfig{
                                PasswordAuth:   true,
                                PublicKeyAuth:  false,
                                AllowAnonymous: true,
                        },
                        Terminal: &amp;SSHTerminalConfig{
                                DefaultSize:        "80x24",
                                MaxSize:            "120x40",
                                SupportedTerminals: []string{"xterm", "xterm-256color"},
                        },
                },
                SessionManagement: &amp;SessionManagementConfig{
                        Terminal: &amp;TerminalConfig{
                                DefaultSize: "80x24",
                                MaxSize:     "120x40",
                                Encoding:    "utf-8",
                        },
                        Timeouts: &amp;TimeoutsConfig{
                                IdleTimeout:        "15m",
                                MaxSessionDuration: "1h",
                                CleanupInterval:    "1m",
                        },
                        TTYRec: &amp;TTYRecConfig{
                                Enabled:       true,
                                Compression:   "gzip",
                                Directory:     "./ttyrec",
                                MaxFileSize:   "10MB",
                                RetentionDays: 7,
                        },
                        Spectating: &amp;SpectatingConfig{
                                Enabled:                 true,
                                MaxSpectatorsPerSession: 3,
                                SpectatorTimeout:        "30m",
                        },
                },
                Services: &amp;ServicesConfig{
                        AuthService: "localhost:9090",
                        UserService: "localhost:9091",
                        GameService: "localhost:9092",
                },
                Storage: &amp;StorageConfig{
                        TTYRecPath: "./ttyrec",
                        TempPath:   "./tmp",
                },
                Logging: &amp;LoggingConfig{
                        Level:  "debug",
                        Format: "text",
                        Output: "stdout",
                },
                Metrics: &amp;MetricsConfig{
                        Enabled: true,
                        Port:    8085,
                },
                Health: &amp;HealthConfig{
                        Enabled: true,
                        Path:    "/health",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

// DatabaseMode represents the database operational mode
type DatabaseMode string

const (
        DatabaseModeEmbedded DatabaseMode = "embedded" // SQLite for testing/development
        DatabaseModeExternal DatabaseMode = "external" // PostgreSQL/MySQL for production
)

// DatabaseConfig with dual mode support
type DatabaseConfig struct {
        Mode       DatabaseMode           `yaml:"mode"`           // embedded or external
        Type       string                 `yaml:"type"`           // sqlite, postgresql, mysql
        Connection map[string]interface{} `yaml:"connection"`     // Legacy connection config
        Embedded   *EmbeddedDBConfig      `yaml:"embedded"`       // Embedded database config
        External   *ExternalDBConfig      `yaml:"external"`       // External database config
        Settings   *DatabaseSettings      `yaml:"settings"`       // Common settings
        Pool       *PoolConfig            `yaml:"pool,omitempty"` // Pool configuration for compatibility
}

// EmbeddedDBConfig represents embedded database configuration (SQLite)
type EmbeddedDBConfig struct {
        Type            string       `yaml:"type"`             // sqlite, leveldb, etc.
        Path            string       `yaml:"path"`             // Database file path
        MigrationPath   string       `yaml:"migration_path"`   // Migration files path
        BackupEnabled   bool         `yaml:"backup_enabled"`   // Enable automatic backups
        BackupInterval  string       `yaml:"backup_interval"`  // Backup interval
        BackupRetention int          `yaml:"backup_retention"` // Number of backups to keep
        WALMode         bool         `yaml:"wal_mode"`         // SQLite WAL mode
        Cache           *CacheConfig `yaml:"cache"`            // Cache configuration
}

// ExternalDBConfig represents external database configuration with read/write separation
type ExternalDBConfig struct {
        Type string `yaml:"type"` // postgresql, mysql

        // Writer endpoint configuration
        WriterEndpoint string `yaml:"writer_endpoint"` // Writer endpoint (host:port)

        // Reader endpoint configuration
        ReaderUseWriter bool   `yaml:"reader_use_writer"` // Use writer endpoint for reads
        ReaderEndpoint  string `yaml:"reader_endpoint"`   // Reader endpoint (host:port)

        // Legacy single endpoint support (deprecated)
        Host string `yaml:"host,omitempty"` // Database host (legacy)
        Port int    `yaml:"port,omitempty"` // Database port (legacy)

        // Database credentials and settings
        Database string `yaml:"database"` // Database name
        Username string `yaml:"username"` // Database username
        Password string `yaml:"password"` // Database password
        SSLMode  string `yaml:"ssl_mode"` // SSL mode

        // Connection pool settings
        MaxConnections  int    `yaml:"max_connections"`   // Max total connections
        MaxIdleConns    int    `yaml:"max_idle_conns"`    // Max idle connections
        ConnMaxLifetime string `yaml:"conn_max_lifetime"` // Connection max lifetime

        // Reader-specific connection pool settings
        ReaderMaxConnections int `yaml:"reader_max_connections"` // Max reader connections
        ReaderMaxIdleConns   int `yaml:"reader_max_idle_conns"`  // Max reader idle connections

        // Schema and migration settings
        MigrationPath string `yaml:"migration_path"` // Migration files path
        Schema        string `yaml:"schema"`         // Database schema

        // Additional connection options
        Options map[string]string `yaml:"options"` // Additional options

        // Failover settings
        Failover *FailoverConfig `yaml:"failover"` // Failover configuration
}

// FailoverConfig represents database failover configuration
type FailoverConfig struct {
        Enabled                bool   `yaml:"enabled"`                   // Enable automatic failover
        HealthCheckInterval    string `yaml:"health_check_interval"`     // Health check interval
        FailoverTimeout        string `yaml:"failover_timeout"`          // Timeout before failover
        RetryInterval          string `yaml:"retry_interval"`            // Retry interval
        MaxRetries             int    `yaml:"max_retries"`               // Maximum retry attempts
        ReaderToWriterFallback bool   `yaml:"reader_to_writer_fallback"` // Fallback reads to writer on failure
}

// DatabaseEndpoints represents the actual connection endpoints
type DatabaseEndpoints struct {
        Writer string
        Reader string
}

// DatabaseSettings represents common database settings
type DatabaseSettings struct {
        LogQueries     bool   `yaml:"log_queries"`     // Log SQL queries
        Timeout        string `yaml:"timeout"`         // Query timeout
        RetryAttempts  int    `yaml:"retry_attempts"`  // Number of retry attempts
        RetryDelay     string `yaml:"retry_delay"`     // Delay between retries
        HealthCheck    bool   `yaml:"health_check"`    // Enable health checks
        HealthInterval string `yaml:"health_interval"` // Health check interval
        MetricsEnabled bool   `yaml:"metrics_enabled"` // Enable database metrics
}

// CacheConfig represents database cache configuration
type CacheConfig struct {
        Enabled   bool   `yaml:"enabled"`    // Enable caching
        Size      int    `yaml:"size"`       // Cache size in MB
        TTL       string `yaml:"ttl"`        // Time to live
        Type      string `yaml:"type"`       // Cache type (memory, redis)
        RedisAddr string `yaml:"redis_addr"` // Redis address for distributed cache
}

// UserServiceConfig represents user service configuration
type UserServiceConfig struct {
        Database       *DatabaseConfig     `yaml:"database"`
        Registration   *RegistrationConfig `yaml:"registration"`
        Authentication *AuthConfig         `yaml:"authentication"`
        Validation     *ValidationConfig   `yaml:"validation"`
        Security       *SecurityConfig     `yaml:"security"`
}

// RegistrationConfig represents registration configuration
type RegistrationConfig struct {
        Enabled           bool               `yaml:"enabled"`
        RequireEmail      bool               `yaml:"require_email"`
        RequireTerms      bool               `yaml:"require_terms"`
        EmailVerification bool               `yaml:"email_verification"`
        ManualApproval    bool               `yaml:"manual_approval"`
        DefaultRoles      []string           `yaml:"default_roles"`
        RateLimiting      *RateLimitConfig   `yaml:"rate_limiting"`
        Email             *EmailConfig       `yaml:"email"`
        Captcha           *CaptchaConfig     `yaml:"captcha"`
        Hooks             *RegistrationHooks `yaml:"hooks"`
}

// AuthConfig represents authentication configuration
type AuthConfig struct {
        PasswordExpiry        string               `yaml:"password_expiry"`
        SessionTimeout        string               `yaml:"session_timeout"`
        MaxConcurrentSessions int                  `yaml:"max_concurrent_sessions"`
        RequirePasswordChange bool                 `yaml:"require_password_change"`
        TwoFactorAuth         *TwoFactorConfig     `yaml:"two_factor_auth"`
        LoginAttempts         *LoginAttemptsConfig `yaml:"login_attempts"`
}

// ValidationConfig represents validation configuration
type ValidationConfig struct {
        Username *UsernameValidation `yaml:"username"`
        Password *PasswordValidation `yaml:"password"`
        Email    *EmailValidation    `yaml:"email"`
}

// UsernameValidation represents username validation rules
type UsernameValidation struct {
        MinLength int      `yaml:"min_length"`
        MaxLength int      `yaml:"max_length"`
        Pattern   string   `yaml:"pattern"`
        Reserved  []string `yaml:"reserved"`
        Blacklist []string `yaml:"blacklist"`
}

// PasswordValidation represents password validation rules
type PasswordValidation struct {
        MinLength        int      `yaml:"min_length"`
        MaxLength        int      `yaml:"max_length"`
        RequireSpecial   bool     `yaml:"require_special"`
        RequireNumber    bool     `yaml:"require_number"`
        RequireUppercase bool     `yaml:"require_uppercase"`
        RequireLowercase bool     `yaml:"require_lowercase"`
        Forbidden        []string `yaml:"forbidden"`
        MinEntropy       float64  `yaml:"min_entropy"`
}

// EmailValidation represents email validation rules
type EmailValidation struct {
        Required       bool     `yaml:"required"`
        MaxLength      int      `yaml:"max_length"`
        DomainsAllowed []string `yaml:"domains_allowed"`
        DomainsBlocked []string `yaml:"domains_blocked"`
}

// RateLimitConfig represents rate limiting configuration
type RateLimitConfig struct {
        Enabled       bool   `yaml:"enabled"`
        MaxAttempts   int    `yaml:"max_attempts"`
        Window        string `yaml:"window"`
        BlockDuration string `yaml:"block_duration"`
}

// EmailConfig represents email configuration for registration
type EmailConfig struct {
        VerificationRequired bool     `yaml:"verification_required"`
        DomainsAllowed       []string `yaml:"domains_allowed"`
        DomainsBlocked       []string `yaml:"domains_blocked"`
        TemplatesPath        string   `yaml:"templates_path"`
}

// CaptchaConfig represents captcha configuration
type CaptchaConfig struct {
        Enabled   bool    `yaml:"enabled"`
        Provider  string  `yaml:"provider"` // recaptcha, hcaptcha
        SiteKey   string  `yaml:"site_key"`
        SecretKey string  `yaml:"secret_key"`
        Threshold float64 `yaml:"threshold"`
}

// RegistrationHooks represents registration hook configuration
type RegistrationHooks struct {
        PreRegistration  []string `yaml:"pre_registration"`
        PostRegistration []string `yaml:"post_registration"`
        OnFailure        []string `yaml:"on_failure"`
}

// TwoFactorConfig represents two-factor authentication configuration
type TwoFactorConfig struct {
        Enabled  bool     `yaml:"enabled"`
        Required bool     `yaml:"required"`
        Methods  []string `yaml:"methods"` // totp, sms, email
        Issuer   string   `yaml:"issuer"`
}

// LoginAttemptsConfig represents login attempts configuration
type LoginAttemptsConfig struct {
        MaxAttempts  int    `yaml:"max_attempts"`
        LockDuration string `yaml:"lock_duration"`
        ResetWindow  string `yaml:"reset_window"`
        Progressive  bool   `yaml:"progressive"` // Progressive delays
}

// ConvertLegacyToNew converts a legacy LegacyDatabaseConfig to a DatabaseConfig
// This handles the case where the YAML has the new structure but is loaded into a legacy config
func ConvertLegacyToNew(legacy *LegacyDatabaseConfig) (*DatabaseConfig, error) <span class="cov0" title="0">{
        if legacy == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("legacy database config is nil")
        }</span>

        // Try to extract mode from the connection map
        <span class="cov0" title="0">mode, _ := legacy.Connection["mode"].(string)
        if mode == "" </span><span class="cov0" title="0">{
                // Default to embedded mode if not specified
                mode = string(DatabaseModeEmbedded)
        }</span>

        <span class="cov0" title="0">config := &amp;DatabaseConfig{
                Mode: DatabaseMode(mode),
                Type: legacy.Type,
                Pool: legacy.Pool,
                Settings: &amp;DatabaseSettings{
                        LogQueries:    false,
                        Timeout:       "30s",
                        RetryAttempts: 3,
                        RetryDelay:    "1s",
                },
        }

        // Handle embedded configuration
        if embeddedMap, ok := legacy.Connection["embedded"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                config.Embedded = &amp;EmbeddedDBConfig{
                        Type:          getString(embeddedMap, "type", "sqlite"),
                        Path:          getString(embeddedMap, "path", "./data/default.db"),
                        MigrationPath: getString(embeddedMap, "migration_path", "./migrations"),
                        BackupEnabled: getBool(embeddedMap, "backup_enabled", false),
                        WALMode:       getBool(embeddedMap, "wal_mode", true),
                }

                // Handle cache config
                if cacheMap, ok := embeddedMap["cache"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        config.Embedded.Cache = &amp;CacheConfig{
                                Enabled: getBool(cacheMap, "enabled", true),
                                Size:    getInt(cacheMap, "size", 64),
                                TTL:     getString(cacheMap, "ttl", "1h"),
                                Type:    getString(cacheMap, "type", "memory"),
                        }
                }</span>
        }

        // Handle external configuration
        <span class="cov0" title="0">if externalMap, ok := legacy.Connection["external"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                config.External = &amp;ExternalDBConfig{
                        Type:                 getString(externalMap, "type", "postgresql"),
                        WriterEndpoint:       getString(externalMap, "writer_endpoint", "localhost:5432"),
                        ReaderUseWriter:      getBool(externalMap, "reader_use_writer", true),
                        ReaderEndpoint:       getString(externalMap, "reader_endpoint", "localhost:5432"),
                        Database:             getString(externalMap, "database", "postgres"),
                        Username:             getString(externalMap, "username", "postgres"),
                        Password:             getString(externalMap, "password", ""),
                        SSLMode:              getString(externalMap, "ssl_mode", "disable"),
                        MaxConnections:       getInt(externalMap, "max_connections", 25),
                        MaxIdleConns:         getInt(externalMap, "max_idle_conns", 10),
                        ConnMaxLifetime:      getString(externalMap, "conn_max_lifetime", "1h"),
                        ReaderMaxConnections: getInt(externalMap, "reader_max_connections", 15),
                        ReaderMaxIdleConns:   getInt(externalMap, "reader_max_idle_conns", 5),
                        MigrationPath:        getString(externalMap, "migration_path", "./migrations"),
                        Schema:               getString(externalMap, "schema", "public"),
                }

                // Handle failover config
                if failoverMap, ok := externalMap["failover"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        config.External.Failover = &amp;FailoverConfig{
                                Enabled:                getBool(failoverMap, "enabled", true),
                                HealthCheckInterval:    getString(failoverMap, "health_check_interval", "30s"),
                                FailoverTimeout:        getString(failoverMap, "failover_timeout", "10s"),
                                RetryInterval:          getString(failoverMap, "retry_interval", "5s"),
                                MaxRetries:             getInt(failoverMap, "max_retries", 3),
                                ReaderToWriterFallback: getBool(failoverMap, "reader_to_writer_fallback", true),
                        }
                }</span>
        }

        // Handle settings
        <span class="cov0" title="0">if settingsMap, ok := legacy.Connection["settings"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                config.Settings = &amp;DatabaseSettings{
                        LogQueries:    getBool(settingsMap, "log_queries", false),
                        Timeout:       getString(settingsMap, "timeout", "30s"),
                        RetryAttempts: getInt(settingsMap, "retry_attempts", 3),
                        RetryDelay:    getString(settingsMap, "retry_delay", "1s"),
                }
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// Helper functions for type conversion
func getString(m map[string]interface{}, key, defaultValue string) string <span class="cov0" title="0">{
        if v, ok := m[key].(string); ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getBool(m map[string]interface{}, key string, defaultValue bool) bool <span class="cov0" title="0">{
        if v, ok := m[key].(bool); ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getInt(m map[string]interface{}, key string, defaultValue int) int <span class="cov0" title="0">{
        if v, ok := m[key].(int); ok </span><span class="cov0" title="0">{
                return v
        }</span>
        // Handle float64 from YAML parsing
        <span class="cov0" title="0">if v, ok := m[key].(float64); ok </span><span class="cov0" title="0">{
                return int(v)
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// GetConnectionString returns the appropriate connection string based on mode
func (c *DatabaseConfig) GetConnectionString() (string, error) <span class="cov0" title="0">{
        switch c.Mode </span>{
        case DatabaseModeEmbedded:<span class="cov0" title="0">
                if c.Embedded == nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("embedded configuration is required for embedded mode")
                }</span>
                <span class="cov0" title="0">return c.getEmbeddedConnectionString()</span>
        case DatabaseModeExternal:<span class="cov0" title="0">
                if c.External == nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("external configuration is required for external mode")
                }</span>
                <span class="cov0" title="0">return c.getExternalConnectionString("writer")</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported database mode: %s", c.Mode)</span>
        }
}

// GetWriterConnectionString returns the writer connection string
func (c *DatabaseConfig) GetWriterConnectionString() (string, error) <span class="cov0" title="0">{
        if c.Mode != DatabaseModeExternal </span><span class="cov0" title="0">{
                return c.GetConnectionString()
        }</span>
        <span class="cov0" title="0">return c.getExternalConnectionString("writer")</span>
}

// GetReaderConnectionString returns the reader connection string
func (c *DatabaseConfig) GetReaderConnectionString() (string, error) <span class="cov0" title="0">{
        if c.Mode != DatabaseModeExternal </span><span class="cov0" title="0">{
                return c.GetConnectionString()
        }</span>
        <span class="cov0" title="0">return c.getExternalConnectionString("reader")</span>
}

// GetEndpoints returns the database endpoints configuration
func (c *DatabaseConfig) GetEndpoints() (*DatabaseEndpoints, error) <span class="cov0" title="0">{
        if c.Mode != DatabaseModeExternal </span><span class="cov0" title="0">{
                connStr, err := c.GetConnectionString()
                return &amp;DatabaseEndpoints{
                        Writer: connStr,
                        Reader: connStr,
                }, err
        }</span>

        <span class="cov0" title="0">endpoints := &amp;DatabaseEndpoints{}

        // Parse writer endpoint
        if c.External.WriterEndpoint == "" </span><span class="cov0" title="0">{
                // Fallback to legacy host:port format
                if c.External.Host != "" &amp;&amp; c.External.Port &gt; 0 </span><span class="cov0" title="0">{
                        endpoints.Writer = fmt.Sprintf("%s:%d", c.External.Host, c.External.Port)
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("writer endpoint not configured")
                }</span>
        } else<span class="cov0" title="0"> {
                endpoints.Writer = c.External.WriterEndpoint
        }</span>

        // Parse reader endpoint
        <span class="cov0" title="0">if c.External.ReaderUseWriter </span><span class="cov0" title="0">{
                endpoints.Reader = endpoints.Writer
        }</span> else<span class="cov0" title="0"> {
                if c.External.ReaderEndpoint == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reader endpoint not configured when reader_use_writer is false")
                }</span>
                <span class="cov0" title="0">endpoints.Reader = c.External.ReaderEndpoint</span>
        }

        <span class="cov0" title="0">return endpoints, nil</span>
}

// getEmbeddedConnectionString returns connection string for embedded database
func (c *DatabaseConfig) getEmbeddedConnectionString() (string, error) <span class="cov0" title="0">{
        switch c.Embedded.Type </span>{
        case "sqlite":<span class="cov0" title="0">
                params := "?_journal_mode=WAL&amp;_sync=NORMAL&amp;_cache_size=1000"
                if !c.Embedded.WALMode </span><span class="cov0" title="0">{
                        params = "?_journal_mode=DELETE"
                }</span>
                <span class="cov0" title="0">return c.Embedded.Path + params, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported embedded database type: %s", c.Embedded.Type)</span>
        }
}

// getExternalConnectionString returns connection string for external database
func (c *DatabaseConfig) getExternalConnectionString(endpoint string) (string, error) <span class="cov0" title="0">{
        endpoints, err := c.GetEndpoints()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var hostPort string
        switch endpoint </span>{
        case "writer":<span class="cov0" title="0">
                hostPort = endpoints.Writer</span>
        case "reader":<span class="cov0" title="0">
                hostPort = endpoints.Reader</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("invalid endpoint type: %s", endpoint)</span>
        }

        // Parse host and port from endpoint
        <span class="cov0" title="0">parts := strings.Split(hostPort, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid endpoint format: %s", hostPort)
        }</span>

        <span class="cov0" title="0">host := parts[0]
        port := parts[1]

        switch c.External.Type </span>{
        case "postgresql":<span class="cov0" title="0">
                connStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                        host, port, c.External.Username, c.External.Password,
                        c.External.Database, c.External.SSLMode)

                // Add additional options
                for key, value := range c.External.Options </span><span class="cov0" title="0">{
                        connStr += fmt.Sprintf(" %s=%s", key, value)
                }</span>

                <span class="cov0" title="0">return connStr, nil</span>

        case "mysql":<span class="cov0" title="0">
                connStr := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true",
                        c.External.Username, c.External.Password, host, port, c.External.Database)

                // Add SSL mode for MySQL
                if c.External.SSLMode != "" </span><span class="cov0" title="0">{
                        connStr += "&amp;tls=" + c.External.SSLMode
                }</span>

                // Add additional options
                <span class="cov0" title="0">for key, value := range c.External.Options </span><span class="cov0" title="0">{
                        connStr += fmt.Sprintf("&amp;%s=%s", key, value)
                }</span>

                <span class="cov0" title="0">return connStr, nil</span>

        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported external database type: %s", c.External.Type)</span>
        }
}

// GetDatabaseType returns the database type based on mode
func (c *DatabaseConfig) GetDatabaseType() string <span class="cov0" title="0">{
        switch c.Mode </span>{
        case DatabaseModeEmbedded:<span class="cov0" title="0">
                if c.Embedded != nil </span><span class="cov0" title="0">{
                        return c.Embedded.Type
                }</span>
        case DatabaseModeExternal:<span class="cov0" title="0">
                if c.External != nil </span><span class="cov0" title="0">{
                        return c.External.Type
                }</span>
        }
        <span class="cov0" title="0">return c.Type</span> // Fallback to legacy type
}

// IsEmbedded returns true if using embedded database
func (c *DatabaseConfig) IsEmbedded() bool <span class="cov0" title="0">{
        return c.Mode == DatabaseModeEmbedded
}</span>

// IsExternal returns true if using external database
func (c *DatabaseConfig) IsExternal() bool <span class="cov0" title="0">{
        return c.Mode == DatabaseModeExternal
}</span>

// GetMigrationPath returns the migration path
func (c *DatabaseConfig) GetMigrationPath() string <span class="cov0" title="0">{
        switch c.Mode </span>{
        case DatabaseModeEmbedded:<span class="cov0" title="0">
                if c.Embedded != nil &amp;&amp; c.Embedded.MigrationPath != "" </span><span class="cov0" title="0">{
                        return c.Embedded.MigrationPath
                }</span>
        case DatabaseModeExternal:<span class="cov0" title="0">
                if c.External != nil &amp;&amp; c.External.MigrationPath != "" </span><span class="cov0" title="0">{
                        return c.External.MigrationPath
                }</span>
        }
        <span class="cov0" title="0">return "./migrations"</span>
}

// NewDatabaseConfig creates a new enhanced database configuration with defaults
func NewDatabaseConfig() *DatabaseConfig <span class="cov0" title="0">{
        return &amp;DatabaseConfig{
                Mode: DatabaseModeEmbedded,
                Type: "sqlite",
                Embedded: &amp;EmbeddedDBConfig{
                        Type:            "sqlite",
                        Path:            "./data/users.db",
                        MigrationPath:   "./migrations",
                        BackupEnabled:   true,
                        BackupInterval:  "24h",
                        BackupRetention: 7,
                        WALMode:         true,
                        Cache: &amp;CacheConfig{
                                Enabled: true,
                                Size:    64,
                                TTL:     "1h",
                                Type:    "memory",
                        },
                },
                External: &amp;ExternalDBConfig{
                        Type:                 "postgresql",
                        WriterEndpoint:       "localhost:5432",
                        ReaderUseWriter:      true,
                        ReaderEndpoint:       "",
                        Database:             "dungeongate",
                        Username:             "dungeongate",
                        Password:             "",
                        SSLMode:              "require",
                        MaxConnections:       100,
                        MaxIdleConns:         10,
                        ReaderMaxConnections: 50,
                        ReaderMaxIdleConns:   5,
                        ConnMaxLifetime:      "1h",
                        MigrationPath:        "./migrations",
                        Schema:               "public",
                        Options:              make(map[string]string),
                        Failover: &amp;FailoverConfig{
                                Enabled:                true,
                                HealthCheckInterval:    "30s",
                                FailoverTimeout:        "10s",
                                RetryInterval:          "5s",
                                MaxRetries:             3,
                                ReaderToWriterFallback: true,
                        },
                },
                Settings: &amp;DatabaseSettings{
                        LogQueries:     false,
                        Timeout:        "30s",
                        RetryAttempts:  3,
                        RetryDelay:     "1s",
                        HealthCheck:    true,
                        HealthInterval: "30s",
                        MetricsEnabled: true,
                },
        }
}</span>

// NewUserServiceConfig creates a new user service configuration with defaults
func NewUserServiceConfig() *UserServiceConfig <span class="cov0" title="0">{
        return &amp;UserServiceConfig{
                Database: NewDatabaseConfig(),
                Registration: &amp;RegistrationConfig{
                        Enabled:           true,
                        RequireEmail:      false,
                        RequireTerms:      true,
                        EmailVerification: false,
                        ManualApproval:    false,
                        DefaultRoles:      []string{"user"},
                        RateLimiting: &amp;RateLimitConfig{
                                Enabled:       true,
                                MaxAttempts:   5,
                                Window:        "1h",
                                BlockDuration: "15m",
                        },
                        Email: &amp;EmailConfig{
                                VerificationRequired: false,
                                DomainsAllowed:       []string{},
                                DomainsBlocked:       []string{},
                        },
                        Captcha: &amp;CaptchaConfig{
                                Enabled:   false,
                                Provider:  "recaptcha",
                                Threshold: 0.5,
                        },
                },
                Authentication: &amp;AuthConfig{
                        PasswordExpiry:        "0", // Never expire
                        SessionTimeout:        "24h",
                        MaxConcurrentSessions: 5,
                        RequirePasswordChange: false,
                        TwoFactorAuth: &amp;TwoFactorConfig{
                                Enabled:  false,
                                Required: false,
                                Methods:  []string{"totp"},
                                Issuer:   "DungeonGate",
                        },
                        LoginAttempts: &amp;LoginAttemptsConfig{
                                MaxAttempts:  5,
                                LockDuration: "15m",
                                ResetWindow:  "1h",
                                Progressive:  true,
                        },
                },
                Validation: &amp;ValidationConfig{
                        Username: &amp;UsernameValidation{
                                MinLength: 2,
                                MaxLength: 20,
                                Pattern:   "^[a-zA-Z0-9_]+$",
                                Reserved:  []string{"admin", "root", "guest", "anonymous", "system"},
                                Blacklist: []string{},
                        },
                        Password: &amp;PasswordValidation{
                                MinLength:        6,
                                MaxLength:        128,
                                RequireSpecial:   false,
                                RequireNumber:    false,
                                RequireUppercase: false,
                                RequireLowercase: false,
                                Forbidden:        []string{"password", "123456", "admin", "guest"},
                                MinEntropy:       0.0,
                        },
                        Email: &amp;EmailValidation{
                                Required:       false,
                                MaxLength:      80,
                                DomainsAllowed: []string{},
                                DomainsBlocked: []string{},
                        },
                },
                Security: &amp;SecurityConfig{
                        RateLimiting: &amp;RateLimitingConfig{
                                Enabled:             true,
                                MaxConnectionsPerIP: 10,
                                ConnectionWindow:    "1m",
                        },
                        BruteForceProtection: &amp;BruteForceConfig{
                                Enabled:           true,
                                MaxFailedAttempts: 5,
                                LockoutDuration:   "15m",
                        },
                        SessionSecurity: &amp;SessionSecurityConfig{
                                RequireEncryption:  true,
                                SessionTokenLength: 32,
                                SecureRandom:       true,
                        },
                },
        }
}</span>

// LoadUserServiceConfig loads user service configuration from file
func LoadUserServiceConfig(configPath string) (*UserServiceConfig, error) <span class="cov0" title="0">{
        // If no config file provided, return default configuration
        if configPath == "" </span><span class="cov0" title="0">{
                return NewUserServiceConfig(), nil
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Expand environment variables
        <span class="cov0" title="0">expanded := os.ExpandEnv(string(data))

        var config UserServiceConfig
        if err := yaml.Unmarshal([]byte(expanded), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        // Apply defaults for missing fields
        <span class="cov0" title="0">if config.Database == nil </span><span class="cov0" title="0">{
                config.Database = NewDatabaseConfig()
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// Validate validates the user service configuration
func (c *UserServiceConfig) Validate() error <span class="cov0" title="0">{
        if c.Database == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database configuration is required")
        }</span>

        <span class="cov0" title="0">if err := c.Database.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database configuration validation failed: %w", err)
        }</span>

        // Validate other sections...
        <span class="cov0" title="0">return nil</span>
}

// Validate validates the enhanced database configuration
func (c *DatabaseConfig) Validate() error <span class="cov0" title="0">{
        if c.Mode == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database mode is required")
        }</span>

        <span class="cov0" title="0">switch c.Mode </span>{
        case DatabaseModeEmbedded:<span class="cov0" title="0">
                if c.Embedded == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("embedded configuration is required for embedded mode")
                }</span>
                <span class="cov0" title="0">return c.validateEmbedded()</span>
        case DatabaseModeExternal:<span class="cov0" title="0">
                if c.External == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("external configuration is required for external mode")
                }</span>
                <span class="cov0" title="0">return c.validateExternal()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported database mode: %s", c.Mode)</span>
        }
}

// validateEmbedded validates embedded database configuration
func (c *DatabaseConfig) validateEmbedded() error <span class="cov0" title="0">{
        if c.Embedded.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("embedded database type is required")
        }</span>
        <span class="cov0" title="0">if c.Embedded.Path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("embedded database path is required")
        }</span>

        // Ensure directory exists
        <span class="cov0" title="0">if err := os.MkdirAll(getDir(c.Embedded.Path), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create database directory: %w", err)
        }</span>

        // Validate backup interval if backups are enabled
        <span class="cov0" title="0">if c.Embedded.BackupEnabled &amp;&amp; c.Embedded.BackupInterval != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(c.Embedded.BackupInterval); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid backup interval: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateExternal validates external database configuration
func (c *DatabaseConfig) validateExternal() error <span class="cov0" title="0">{
        if c.External.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("external database type is required")
        }</span>

        // Validate writer endpoint
        <span class="cov0" title="0">if c.External.WriterEndpoint == "" </span><span class="cov0" title="0">{
                // Check legacy host/port configuration
                if c.External.Host == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("writer endpoint or legacy host is required")
                }</span>
                <span class="cov0" title="0">if c.External.Port == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("writer endpoint or legacy port is required")
                }</span>
        } else<span class="cov0" title="0"> {
                // Validate endpoint format
                if err := c.validateEndpointFormat(c.External.WriterEndpoint); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid writer endpoint format: %w", err)
                }</span>
        }

        // Validate reader endpoint if not using writer
        <span class="cov0" title="0">if !c.External.ReaderUseWriter </span><span class="cov0" title="0">{
                if c.External.ReaderEndpoint == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("reader endpoint is required when reader_use_writer is false")
                }</span>
                <span class="cov0" title="0">if err := c.validateEndpointFormat(c.External.ReaderEndpoint); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid reader endpoint format: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if c.External.Database == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database name is required")
        }</span>
        <span class="cov0" title="0">if c.External.Username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database username is required")
        }</span>

        // Validate connection lifetime
        <span class="cov0" title="0">if c.External.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(c.External.ConnMaxLifetime); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid connection max lifetime: %w", err)
                }</span>
        }

        // Validate failover configuration
        <span class="cov0" title="0">if c.External.Failover != nil &amp;&amp; c.External.Failover.Enabled </span><span class="cov0" title="0">{
                if err := c.validateFailoverConfig(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failover configuration validation failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateEndpointFormat validates the format of a database endpoint
func (c *DatabaseConfig) validateEndpointFormat(endpoint string) error <span class="cov0" title="0">{
        parts := strings.Split(endpoint, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("endpoint must be in format 'host:port'")
        }</span>

        <span class="cov0" title="0">host := strings.TrimSpace(parts[0])
        port := strings.TrimSpace(parts[1])

        if host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("host cannot be empty")
        }</span>

        <span class="cov0" title="0">if port == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("port cannot be empty")
        }</span>

        // Validate port is numeric
        <span class="cov0" title="0">if _, err := strconv.Atoi(port); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("port must be numeric: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateFailoverConfig validates failover configuration
func (c *DatabaseConfig) validateFailoverConfig() error <span class="cov0" title="0">{
        failover := c.External.Failover

        if failover.HealthCheckInterval != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(failover.HealthCheckInterval); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid health check interval: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if failover.FailoverTimeout != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(failover.FailoverTimeout); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid failover timeout: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if failover.RetryInterval != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(failover.RetryInterval); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid retry interval: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if failover.MaxRetries &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max retries cannot be negative")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper function to get directory from file path
func getDir(filePath string) string <span class="cov0" title="0">{
        for i := len(filePath) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if filePath[i] == '/' || filePath[i] == '\\' </span><span class="cov0" title="0">{
                        return filePath[:i]
                }</span>
        }
        <span class="cov0" title="0">return "."</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/dungeongate/pkg/config"
        _ "github.com/go-sql-driver/mysql" // MySQL driver
        _ "github.com/lib/pq"              // PostgreSQL driver
        _ "github.com/mattn/go-sqlite3"    // SQLite driver
)

// Connection represents a database connection with read/write separation
type Connection struct {
        writer        *sql.DB
        reader        *sql.DB
        config        *config.DatabaseConfig
        metrics       *ConnectionMetrics
        healthMux     sync.RWMutex
        writerHealthy bool
        readerHealthy bool
}

// ConnectionMetrics tracks database connection metrics
type ConnectionMetrics struct {
        mutex             sync.RWMutex
        WriterConnections int64
        ReaderConnections int64
        WriterQueries     int64
        ReaderQueries     int64
        WriterErrors      int64
        ReaderErrors      int64
        FailoverCount     int64
        LastFailover      time.Time
}

// QueryType represents the type of database query
type QueryType int

const (
        QueryTypeRead QueryType = iota
        QueryTypeWrite
        QueryTypeReadWrite // Transactions that need consistent reads
)

// NewConnection creates a new database connection with read/write separation
func NewConnection(cfg *config.DatabaseConfig) (*Connection, error) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database configuration is nil")
        }</span>

        <span class="cov0" title="0">conn := &amp;Connection{
                config:        cfg,
                metrics:       &amp;ConnectionMetrics{},
                writerHealthy: true,
                readerHealthy: true,
        }

        switch cfg.Mode </span>{
        case config.DatabaseModeEmbedded:<span class="cov0" title="0">
                return conn.initEmbeddedConnection()</span>
        case config.DatabaseModeExternal:<span class="cov0" title="0">
                return conn.initExternalConnection()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported database mode: %s", cfg.Mode)</span>
        }
}

// initEmbeddedConnection initializes an embedded database connection
func (c *Connection) initEmbeddedConnection() (*Connection, error) <span class="cov0" title="0">{
        connStr, err := c.config.GetConnectionString()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get connection string: %w", err)
        }</span>

        <span class="cov0" title="0">db, err := sql.Open(GetDriverName(c.config.GetDatabaseType()), connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // For embedded databases, both reader and writer use the same connection
        <span class="cov0" title="0">c.writer = db
        c.reader = db

        // Configure connection pool
        c.configureConnectionPool(db, c.config.Embedded)

        return c, nil</span>
}

// NewConnectionFromLegacy creates a new database connection from legacy LegacyDatabaseConfig
// This is for backward compatibility with the legacy LegacyDatabaseConfig type
func NewConnectionFromLegacy(cfg *config.LegacyDatabaseConfig) (*Connection, error) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database configuration is nil")
        }</span>

        // Convert legacy config to new config for embedded SQLite (most common case)
        <span class="cov0" title="0">newCfg := &amp;config.DatabaseConfig{
                Mode:       config.DatabaseModeEmbedded,
                Type:       cfg.Type,
                Connection: cfg.Connection,
                Pool:       cfg.Pool,
                Embedded: &amp;config.EmbeddedDBConfig{
                        Type:          cfg.Type,
                        Path:          "./data/default.db", // Default path
                        MigrationPath: "./migrations",
                        BackupEnabled: false,
                        WALMode:       true,
                        Cache: &amp;config.CacheConfig{
                                Enabled: true,
                                Size:    64,
                                TTL:     "1h",
                                Type:    "memory",
                        },
                },
                Settings: &amp;config.DatabaseSettings{
                        LogQueries:     false,
                        Timeout:        "30s",
                        RetryAttempts:  3,
                        RetryDelay:     "1s",
                        HealthCheck:    true,
                        HealthInterval: "30s",
                        MetricsEnabled: true,
                },
        }

        // Extract connection string from legacy config if available
        if connStr, ok := cfg.Connection["dsn"]; ok </span><span class="cov0" title="0">{
                if dsn, ok := connStr.(string); ok </span><span class="cov0" title="0">{
                        newCfg.Embedded.Path = dsn
                }</span>
        }

        <span class="cov0" title="0">return NewConnection(newCfg)</span>
}

// initExternalConnection initializes an external database connection with read/write separation
func (c *Connection) initExternalConnection() (*Connection, error) <span class="cov0" title="0">{
        // Initialize writer connection
        writerConnStr, err := c.config.GetWriterConnectionString()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get writer connection string: %w", err)
        }</span>

        <span class="cov0" title="0">c.writer, err = sql.Open(GetDriverName(c.config.GetDatabaseType()), writerConnStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open writer database: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.writer.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping writer database: %w", err)
        }</span>

        // Configure writer connection pool
        <span class="cov0" title="0">c.configureWriterConnectionPool()

        // Initialize reader connection
        if c.config.External.ReaderUseWriter </span><span class="cov0" title="0">{
                // Use writer connection for reads
                c.reader = c.writer
        }</span> else<span class="cov0" title="0"> {
                // Initialize separate reader connection
                readerConnStr, err := c.config.GetReaderConnectionString()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get reader connection string: %w", err)
                }</span>

                <span class="cov0" title="0">c.reader, err = sql.Open(GetDriverName(c.config.GetDatabaseType()), readerConnStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open reader database: %w", err)
                }</span>

                <span class="cov0" title="0">if err := c.reader.Ping(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to ping reader database: %w", err)
                }</span>

                // Configure reader connection pool
                <span class="cov0" title="0">c.configureReaderConnectionPool()</span>
        }

        // Start health monitoring if failover is enabled
        <span class="cov0" title="0">if c.config.External.Failover != nil &amp;&amp; c.config.External.Failover.Enabled </span><span class="cov0" title="0">{
                go c.startHealthMonitoring()
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

// configureConnectionPool configures connection pool for embedded databases
func (c *Connection) configureConnectionPool(db *sql.DB, embeddedConfig *config.EmbeddedDBConfig) <span class="cov0" title="0">{
        if embeddedConfig == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Set reasonable defaults for SQLite
        <span class="cov0" title="0">db.SetMaxOpenConns(10) // SQLite doesn't benefit from many connections
        db.SetMaxIdleConns(5)
        db.SetConnMaxLifetime(1 * time.Hour)</span>
}

// configureWriterConnectionPool configures the writer connection pool
func (c *Connection) configureWriterConnectionPool() <span class="cov0" title="0">{
        if c.config.External.MaxConnections &gt; 0 </span><span class="cov0" title="0">{
                c.writer.SetMaxOpenConns(c.config.External.MaxConnections)
        }</span>
        <span class="cov0" title="0">if c.config.External.MaxIdleConns &gt; 0 </span><span class="cov0" title="0">{
                c.writer.SetMaxIdleConns(c.config.External.MaxIdleConns)
        }</span>
        <span class="cov0" title="0">if c.config.External.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                if lifetime, err := time.ParseDuration(c.config.External.ConnMaxLifetime); err == nil </span><span class="cov0" title="0">{
                        c.writer.SetConnMaxLifetime(lifetime)
                }</span>
        }
}

// configureReaderConnectionPool configures the reader connection pool
func (c *Connection) configureReaderConnectionPool() <span class="cov0" title="0">{
        maxConns := c.config.External.ReaderMaxConnections
        if maxConns == 0 </span><span class="cov0" title="0">{
                maxConns = c.config.External.MaxConnections / 2 // Default to half of writer connections
        }</span>
        <span class="cov0" title="0">if maxConns &gt; 0 </span><span class="cov0" title="0">{
                c.reader.SetMaxOpenConns(maxConns)
        }</span>

        <span class="cov0" title="0">maxIdle := c.config.External.ReaderMaxIdleConns
        if maxIdle == 0 </span><span class="cov0" title="0">{
                maxIdle = c.config.External.MaxIdleConns / 2
        }</span>
        <span class="cov0" title="0">if maxIdle &gt; 0 </span><span class="cov0" title="0">{
                c.reader.SetMaxIdleConns(maxIdle)
        }</span>

        <span class="cov0" title="0">if c.config.External.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                if lifetime, err := time.ParseDuration(c.config.External.ConnMaxLifetime); err == nil </span><span class="cov0" title="0">{
                        c.reader.SetConnMaxLifetime(lifetime)
                }</span>
        }
}

// startHealthMonitoring starts health monitoring for failover support
func (c *Connection) startHealthMonitoring() <span class="cov0" title="0">{
        failover := c.config.External.Failover
        interval := 30 * time.Second

        if failover.HealthCheckInterval != "" </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(failover.HealthCheckInterval); err == nil </span><span class="cov0" title="0">{
                        interval = parsed
                }</span>
        }

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.checkHealth()
        }</span>
}

// checkHealth performs health checks on database connections
func (c *Connection) checkHealth() <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Check writer health
        writerHealthy := true
        if err := c.writer.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                writerHealthy = false
                c.metrics.mutex.Lock()
                c.metrics.WriterErrors++
                c.metrics.mutex.Unlock()
        }</span>

        // Check reader health (if separate)
        <span class="cov0" title="0">readerHealthy := true
        if c.reader != c.writer </span><span class="cov0" title="0">{
                if err := c.reader.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                        readerHealthy = false
                        c.metrics.mutex.Lock()
                        c.metrics.ReaderErrors++
                        c.metrics.mutex.Unlock()
                }</span>
        } else<span class="cov0" title="0"> {
                readerHealthy = writerHealthy
        }</span>

        // Update health status
        <span class="cov0" title="0">c.healthMux.Lock()
        c.writerHealthy = writerHealthy
        c.readerHealthy = readerHealthy
        c.healthMux.Unlock()</span>
}

// DB returns the appropriate database connection based on query type
func (c *Connection) DB(queryType QueryType) *sql.DB <span class="cov0" title="0">{
        c.healthMux.RLock()
        defer c.healthMux.RUnlock()

        switch queryType </span>{
        case QueryTypeWrite, QueryTypeReadWrite:<span class="cov0" title="0">
                c.metrics.mutex.Lock()
                c.metrics.WriterQueries++
                c.metrics.mutex.Unlock()
                return c.writer</span>

        case QueryTypeRead:<span class="cov0" title="0">
                // Use reader if healthy, otherwise fallback to writer if configured
                if c.readerHealthy </span><span class="cov0" title="0">{
                        c.metrics.mutex.Lock()
                        c.metrics.ReaderQueries++
                        c.metrics.mutex.Unlock()
                        return c.reader
                }</span>

                // Fallback to writer if reader is unhealthy and fallback is enabled
                <span class="cov0" title="0">if c.config.External.Failover != nil &amp;&amp; c.config.External.Failover.ReaderToWriterFallback &amp;&amp; c.writerHealthy </span><span class="cov0" title="0">{
                        c.metrics.mutex.Lock()
                        c.metrics.WriterQueries++
                        c.metrics.FailoverCount++
                        c.metrics.LastFailover = time.Now()
                        c.metrics.mutex.Unlock()
                        return c.writer
                }</span>

                // Return reader even if unhealthy (will likely fail, but let caller handle it)
                <span class="cov0" title="0">c.metrics.mutex.Lock()
                c.metrics.ReaderQueries++
                c.metrics.mutex.Unlock()
                return c.reader</span>

        default:<span class="cov0" title="0">
                // Default to writer for unknown query types
                return c.writer</span>
        }
}

// Writer returns the writer database connection
func (c *Connection) Writer() *sql.DB <span class="cov0" title="0">{
        return c.DB(QueryTypeWrite)
}</span>

// Reader returns the reader database connection
func (c *Connection) Reader() *sql.DB <span class="cov0" title="0">{
        return c.DB(QueryTypeRead)
}</span>

// Close closes both database connections
func (c *Connection) Close() error <span class="cov0" title="0">{
        var err error

        if c.writer != nil </span><span class="cov0" title="0">{
                if writerErr := c.writer.Close(); writerErr != nil </span><span class="cov0" title="0">{
                        err = writerErr
                }</span>
        }

        // Only close reader if it's different from writer
        <span class="cov0" title="0">if c.reader != nil &amp;&amp; c.reader != c.writer </span><span class="cov0" title="0">{
                if readerErr := c.reader.Close(); readerErr != nil </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("writer close error: %v, reader close error: %v", err, readerErr)
                        }</span> else<span class="cov0" title="0"> {
                                err = readerErr
                        }</span>
                }
        }

        <span class="cov0" title="0">return err</span>
}

// Transaction starts a new transaction on the writer database
func (c *Connection) Transaction(ctx context.Context) (*sql.Tx, error) <span class="cov0" title="0">{
        return c.writer.BeginTx(ctx, nil)
}</span>

// Query executes a query and returns rows (uses reader for read queries)
func (c *Connection) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        return c.QueryContext(context.Background(), query, args...)
}</span>

// QueryContext executes a query with context and returns rows
func (c *Connection) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        db := c.DB(c.detectQueryType(query))
        return db.QueryContext(ctx, query, args...)
}</span>

// QueryRow executes a query and returns a single row (uses reader for read queries)
func (c *Connection) QueryRow(query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        return c.QueryRowContext(context.Background(), query, args...)
}</span>

// QueryRowContext executes a query with context and returns a single row
func (c *Connection) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        db := c.DB(c.detectQueryType(query))
        return db.QueryRowContext(ctx, query, args...)
}</span>

// Exec executes a query without returning rows (uses writer)
func (c *Connection) Exec(query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        return c.ExecContext(context.Background(), query, args...)
}</span>

// ExecContext executes a query with context without returning rows
func (c *Connection) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        db := c.DB(QueryTypeWrite) // All exec operations go to writer
        return db.ExecContext(ctx, query, args...)
}</span>

// Prepare prepares a statement (uses writer by default)
func (c *Connection) Prepare(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        return c.PrepareContext(context.Background(), query)
}</span>

// PrepareContext prepares a statement with context
func (c *Connection) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        queryType := c.detectQueryType(query)
        db := c.DB(queryType)
        return db.PrepareContext(ctx, query)
}</span>

// detectQueryType attempts to detect the query type based on the SQL statement
func (c *Connection) detectQueryType(query string) QueryType <span class="cov0" title="0">{
        // Simple query type detection based on the first word
        query = strings.TrimSpace(strings.ToUpper(query))

        if strings.HasPrefix(query, "SELECT") ||
                strings.HasPrefix(query, "SHOW") ||
                strings.HasPrefix(query, "DESCRIBE") ||
                strings.HasPrefix(query, "EXPLAIN") </span><span class="cov0" title="0">{
                return QueryTypeRead
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(query, "INSERT") ||
                strings.HasPrefix(query, "UPDATE") ||
                strings.HasPrefix(query, "DELETE") ||
                strings.HasPrefix(query, "CREATE") ||
                strings.HasPrefix(query, "DROP") ||
                strings.HasPrefix(query, "ALTER") </span><span class="cov0" title="0">{
                return QueryTypeWrite
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(query, "BEGIN") ||
                strings.HasPrefix(query, "START TRANSACTION") </span><span class="cov0" title="0">{
                return QueryTypeReadWrite
        }</span>

        // Default to write for unknown queries to be safe
        <span class="cov0" title="0">return QueryTypeWrite</span>
}

// GetMetrics returns current connection metrics
func (c *Connection) GetMetrics() *ConnectionMetrics <span class="cov0" title="0">{
        c.metrics.mutex.RLock()
        defer c.metrics.mutex.RUnlock()

        return &amp;ConnectionMetrics{
                WriterConnections: c.metrics.WriterConnections,
                ReaderConnections: c.metrics.ReaderConnections,
                WriterQueries:     c.metrics.WriterQueries,
                ReaderQueries:     c.metrics.ReaderQueries,
                WriterErrors:      c.metrics.WriterErrors,
                ReaderErrors:      c.metrics.ReaderErrors,
                FailoverCount:     c.metrics.FailoverCount,
                LastFailover:      c.metrics.LastFailover,
        }
}</span>

// IsHealthy returns the health status of both connections
func (c *Connection) IsHealthy() (writerHealthy, readerHealthy bool) <span class="cov0" title="0">{
        c.healthMux.RLock()
        defer c.healthMux.RUnlock()
        return c.writerHealthy, c.readerHealthy
}</span>

// Ping pings both database connections
func (c *Connection) Ping() error <span class="cov0" title="0">{
        if err := c.writer.Ping(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("writer ping failed: %w", err)
        }</span>

        <span class="cov0" title="0">if c.reader != c.writer </span><span class="cov0" title="0">{
                if err := c.reader.Ping(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("reader ping failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// PingContext pings both database connections with context
func (c *Connection) PingContext(ctx context.Context) error <span class="cov0" title="0">{
        if err := c.writer.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("writer ping failed: %w", err)
        }</span>

        <span class="cov0" title="0">if c.reader != c.writer </span><span class="cov0" title="0">{
                if err := c.reader.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("reader ping failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Stats returns database statistics for both connections
func (c *Connection) Stats() (writerStats, readerStats sql.DBStats) <span class="cov0" title="0">{
        writerStats = c.writer.Stats()

        if c.reader != c.writer </span><span class="cov0" title="0">{
                readerStats = c.reader.Stats()
        }</span> else<span class="cov0" title="0"> {
                readerStats = writerStats
        }</span>

        <span class="cov0" title="0">return writerStats, readerStats</span>
}

// RunMigrations runs database migrations
func RunMigrations(conn *Connection, cfg *config.DatabaseConfig) error <span class="cov0" title="0">{
        // Use writer connection for migrations
        db := conn.Writer()

        // Create migrations table if it doesn't exist
        createMigrationsTable := `
                CREATE TABLE IF NOT EXISTS schema_migrations (
                        version VARCHAR(255) PRIMARY KEY,
                        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
        `

        if _, err := db.Exec(createMigrationsTable); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        // TODO: Implement actual migration logic
        // This would read migration files from cfg.GetMigrationPath() and apply them

        <span class="cov0" title="0">return nil</span>
}

// CreateTables creates the necessary database tables
func CreateTables(conn *Connection) error <span class="cov0" title="0">{
        // Use writer connection for schema changes
        db := conn.Writer()

        // Determine database type for appropriate SQL syntax
        dbType := conn.config.GetDatabaseType()

        var queries []string

        if dbType == "sqlite" </span><span class="cov0" title="0">{
                queries = getSQLiteSchema()
        }</span> else<span class="cov0" title="0"> {
                queries = getPostgreSQLSchema()
        }</span>

        <span class="cov0" title="0">for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := db.Exec(query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute schema query: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getSQLiteSchema returns SQLite-specific schema
func getSQLiteSchema() []string <span class="cov0" title="0">{
        return []string{
                `CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        username VARCHAR(30) UNIQUE NOT NULL,
                        email VARCHAR(80),
                        password_hash VARCHAR(255) NOT NULL,
                        salt VARCHAR(32) NOT NULL,
                        environment TEXT DEFAULT '',
                        flags INTEGER DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_login TIMESTAMP,
                        login_count INTEGER DEFAULT 0,
                        failed_login_attempts INTEGER DEFAULT 0,
                        account_locked BOOLEAN DEFAULT FALSE,
                        locked_until TIMESTAMP,
                        email_verified BOOLEAN DEFAULT FALSE,
                        is_active BOOLEAN DEFAULT TRUE
                )`,
                `CREATE TABLE IF NOT EXISTS user_profiles (
                        user_id INTEGER PRIMARY KEY,
                        real_name VARCHAR(100),
                        location VARCHAR(100),
                        website VARCHAR(200),
                        bio TEXT,
                        avatar_url VARCHAR(500),
                        timezone VARCHAR(50) DEFAULT 'UTC',
                        language VARCHAR(10) DEFAULT 'en',
                        theme VARCHAR(20) DEFAULT 'dark',
                        terminal_size VARCHAR(20) DEFAULT '80x24',
                        color_mode VARCHAR(20) DEFAULT 'color',
                        email_notifications BOOLEAN DEFAULT TRUE,
                        public_profile BOOLEAN DEFAULT FALSE,
                        allow_spectators BOOLEAN DEFAULT TRUE,
                        show_online_status BOOLEAN DEFAULT TRUE,
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )`,
                `CREATE TABLE IF NOT EXISTS user_preferences (
                        user_id INTEGER,
                        key VARCHAR(100),
                        value TEXT,
                        PRIMARY KEY (user_id, key),
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )`,
                `CREATE TABLE IF NOT EXISTS user_roles (
                        user_id INTEGER,
                        role VARCHAR(50),
                        granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        granted_by INTEGER,
                        PRIMARY KEY (user_id, role),
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                        FOREIGN KEY (granted_by) REFERENCES users(id)
                )`,
                `CREATE TABLE IF NOT EXISTS registration_log (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        username VARCHAR(30) NOT NULL,
                        email VARCHAR(80),
                        ip_address VARCHAR(45),
                        user_agent TEXT,
                        source VARCHAR(20),
                        success BOOLEAN,
                        error_message TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )`,
                `CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)`,
                `CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)`,
                `CREATE INDEX IF NOT EXISTS idx_users_active ON users(is_active)`,
                `CREATE INDEX IF NOT EXISTS idx_registration_log_created ON registration_log(created_at)`,
        }
}</span>

// getPostgreSQLSchema returns PostgreSQL-specific schema
func getPostgreSQLSchema() []string <span class="cov0" title="0">{
        return []string{
                `CREATE TABLE IF NOT EXISTS users (
                        id SERIAL PRIMARY KEY,
                        username VARCHAR(30) UNIQUE NOT NULL,
                        email VARCHAR(80),
                        password_hash VARCHAR(255) NOT NULL,
                        salt VARCHAR(32) NOT NULL,
                        environment TEXT DEFAULT '',
                        flags INTEGER DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_login TIMESTAMP,
                        login_count INTEGER DEFAULT 0,
                        failed_login_attempts INTEGER DEFAULT 0,
                        account_locked BOOLEAN DEFAULT FALSE,
                        locked_until TIMESTAMP,
                        email_verified BOOLEAN DEFAULT FALSE,
                        is_active BOOLEAN DEFAULT TRUE
                )`,
                `CREATE TABLE IF NOT EXISTS user_profiles (
                        user_id INTEGER PRIMARY KEY,
                        real_name VARCHAR(100),
                        location VARCHAR(100),
                        website VARCHAR(200),
                        bio TEXT,
                        avatar_url VARCHAR(500),
                        timezone VARCHAR(50) DEFAULT 'UTC',
                        language VARCHAR(10) DEFAULT 'en',
                        theme VARCHAR(20) DEFAULT 'dark',
                        terminal_size VARCHAR(20) DEFAULT '80x24',
                        color_mode VARCHAR(20) DEFAULT 'color',
                        email_notifications BOOLEAN DEFAULT TRUE,
                        public_profile BOOLEAN DEFAULT FALSE,
                        allow_spectators BOOLEAN DEFAULT TRUE,
                        show_online_status BOOLEAN DEFAULT TRUE,
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )`,
                `CREATE TABLE IF NOT EXISTS user_preferences (
                        user_id INTEGER,
                        key VARCHAR(100),
                        value TEXT,
                        PRIMARY KEY (user_id, key),
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )`,
                `CREATE TABLE IF NOT EXISTS user_roles (
                        user_id INTEGER,
                        role VARCHAR(50),
                        granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        granted_by INTEGER,
                        PRIMARY KEY (user_id, role),
                        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                        FOREIGN KEY (granted_by) REFERENCES users(id)
                )`,
                `CREATE TABLE IF NOT EXISTS registration_log (
                        id SERIAL PRIMARY KEY,
                        username VARCHAR(30) NOT NULL,
                        email VARCHAR(80),
                        ip_address VARCHAR(45),
                        user_agent TEXT,
                        source VARCHAR(20),
                        success BOOLEAN,
                        error_message TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )`,
                `CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)`,
                `CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)`,
                `CREATE INDEX IF NOT EXISTS idx_users_active ON users(is_active)`,
                `CREATE INDEX IF NOT EXISTS idx_registration_log_created ON registration_log(created_at)`,
        }
}</span>

// Helper function to get database type string for driver registration
func GetDriverName(dbType string) string <span class="cov0" title="0">{
        switch dbType </span>{
        case "postgresql":<span class="cov0" title="0">
                return "postgres"</span>
        case "mysql":<span class="cov0" title="0">
                return "mysql"</span>
        case "sqlite":<span class="cov0" title="0">
                return "sqlite3"</span>
        default:<span class="cov0" title="0">
                return dbType</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package encryption

import (
        "fmt"
        "github.com/dungeongate/pkg/config"
)

// Encryptor handles encryption operations
type Encryptor struct {
        config *config.EncryptionConfig
        // Add actual encryption fields here
}

// New creates a new encryptor
func New(cfg *config.EncryptionConfig) (*Encryptor, error) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("encryption configuration is required")
        }</span>

        <span class="cov0" title="0">return &amp;Encryptor{
                config: cfg,
        }, nil</span>
}

// Encrypt encrypts data
func (e *Encryptor) Encrypt(data []byte) ([]byte, error) <span class="cov0" title="0">{
        // Implementation would encrypt data
        return data, nil
}</span>

// Decrypt decrypts data
func (e *Encryptor) Decrypt(data []byte) ([]byte, error) <span class="cov0" title="0">{
        // Implementation would decrypt data
        return data, nil
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package dungeongate

import (
        "os"
        "strings"

        "github.com/op/go-logging" // Log Levels
)

func SetupLogger() *logging.Logger <span class="cov0" title="0">{
        // Create a new logger
        var log = logging.MustGetLogger("Controller")
        // Set up a custom log format
        format := logging.MustStringFormatter(
                `%{color}%{time:15:04:05.000} %{shortfunc}  %{level:.9s} %{id:07x}%{color:reset} %{message}`,
        )

        // Create a backend for logging to stdout with the custom format
        backend := logging.NewLogBackend(os.Stdout, "", 0)

        backendFormatter := logging.NewBackendFormatter(backend, format)

        // Set up a module level for the backend
        backends := logging.AddModuleLevel(backendFormatter)

        // Get log level from the environment variable
        logLevel := os.Getenv("LOG_LEVEL")
        if logLevel == "" </span><span class="cov0" title="0">{
                logLevel = "INFO" // Default to INFO if not set
                log.Warning("Log level not set, using default value of", logLevel)
        }</span>

        // Set the log level based on the environment variable
        <span class="cov0" title="0">switch strings.ToUpper(logLevel) </span>{
        case "DEBUG":<span class="cov0" title="0">
                backends.SetLevel(logging.DEBUG, "")</span>
        case "INFO":<span class="cov0" title="0">
                backends.SetLevel(logging.INFO, "")</span>
        case "WARNING":<span class="cov0" title="0">
                backends.SetLevel(logging.WARNING, "")</span>
        case "ERROR":<span class="cov0" title="0">
                backends.SetLevel(logging.ERROR, "")</span>
        case "CRITICAL":<span class="cov0" title="0">
                backends.SetLevel(logging.CRITICAL, "")</span>
        default:<span class="cov0" title="0">
                log.Fatalf("Invalid log level: %s", logLevel)</span>
        }

        // Attach the backend to the logger
        <span class="cov0" title="0">log.SetBackend(backends)
        log.Info("Log Level set to: ", logLevel)
        return log</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

// SSHMetrics contains all SSH server related Prometheus metrics
type SSHMetrics struct {
        // Connection metrics
        ConnectionsTotal   prometheus.Counter
        ConnectionsActive  prometheus.Gauge
        ConnectionsFailed  prometheus.Counter
        ConnectionDuration prometheus.Histogram

        // Session metrics
        SessionsTotal     prometheus.Counter
        SessionsActive    prometheus.Gauge
        SessionDuration   prometheus.Histogram
        SessionBytesRead  prometheus.Counter
        SessionBytesWrite prometheus.Counter

        // Authentication metrics
        AuthAttemptsTotal *prometheus.CounterVec
        AuthFailuresTotal *prometheus.CounterVec
        AuthDuration      prometheus.Histogram

        // Game metrics
        GamesStartedTotal *prometheus.CounterVec
        GamesActive       *prometheus.GaugeVec
        GameDuration      *prometheus.HistogramVec
        GameSessionErrors *prometheus.CounterVec

        // Terminal metrics
        TerminalSizeChanges prometheus.Counter
        TerminalTypes       *prometheus.CounterVec
}

// NewSSHMetrics creates and registers all SSH metrics
func NewSSHMetrics(namespace, subsystem string) *SSHMetrics <span class="cov0" title="0">{
        return &amp;SSHMetrics{
                // Connection metrics
                ConnectionsTotal: promauto.NewCounter(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "connections_total",
                        Help:      "Total number of SSH connections",
                }),
                ConnectionsActive: promauto.NewGauge(prometheus.GaugeOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "connections_active",
                        Help:      "Number of active SSH connections",
                }),
                ConnectionsFailed: promauto.NewCounter(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "connections_failed_total",
                        Help:      "Total number of failed SSH connections",
                }),
                ConnectionDuration: promauto.NewHistogram(prometheus.HistogramOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "connection_duration_seconds",
                        Help:      "SSH connection duration in seconds",
                        Buckets:   prometheus.DefBuckets,
                }),

                // Session metrics
                SessionsTotal: promauto.NewCounter(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "sessions_total",
                        Help:      "Total number of SSH sessions",
                }),
                SessionsActive: promauto.NewGauge(prometheus.GaugeOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "sessions_active",
                        Help:      "Number of active SSH sessions",
                }),
                SessionDuration: promauto.NewHistogram(prometheus.HistogramOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "session_duration_seconds",
                        Help:      "SSH session duration in seconds",
                        Buckets:   prometheus.DefBuckets,
                }),
                SessionBytesRead: promauto.NewCounter(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "session_bytes_read_total",
                        Help:      "Total bytes read from SSH sessions",
                }),
                SessionBytesWrite: promauto.NewCounter(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "session_bytes_written_total",
                        Help:      "Total bytes written to SSH sessions",
                }),

                // Authentication metrics
                AuthAttemptsTotal: promauto.NewCounterVec(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "auth_attempts_total",
                        Help:      "Total number of authentication attempts",
                }, []string{"method", "username"}),
                AuthFailuresTotal: promauto.NewCounterVec(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "auth_failures_total",
                        Help:      "Total number of authentication failures",
                }, []string{"method", "reason"}),
                AuthDuration: promauto.NewHistogram(prometheus.HistogramOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "auth_duration_seconds",
                        Help:      "Authentication duration in seconds",
                        Buckets:   prometheus.DefBuckets,
                }),

                // Game metrics
                GamesStartedTotal: promauto.NewCounterVec(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "games_started_total",
                        Help:      "Total number of games started",
                }, []string{"game_id", "game_name"}),
                GamesActive: promauto.NewGaugeVec(prometheus.GaugeOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "games_active",
                        Help:      "Number of active game sessions",
                }, []string{"game_id", "game_name"}),
                GameDuration: promauto.NewHistogramVec(prometheus.HistogramOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "game_duration_seconds",
                        Help:      "Game session duration in seconds",
                        Buckets:   prometheus.DefBuckets,
                }, []string{"game_id", "game_name"}),
                GameSessionErrors: promauto.NewCounterVec(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "game_session_errors_total",
                        Help:      "Total number of game session errors",
                }, []string{"game_id", "error_type"}),

                // Terminal metrics
                TerminalSizeChanges: promauto.NewCounter(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "terminal_size_changes_total",
                        Help:      "Total number of terminal size changes",
                }),
                TerminalTypes: promauto.NewCounterVec(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: subsystem,
                        Name:      "terminal_types_total",
                        Help:      "Terminal types used for connections",
                }, []string{"type"}),
        }
}</span>

// ServiceMetrics contains general service health metrics
type ServiceMetrics struct {
        // General service metrics
        BuildInfo *prometheus.GaugeVec
        StartTime prometheus.Gauge

        // HTTP metrics
        HTTPRequestsTotal   *prometheus.CounterVec
        HTTPRequestDuration *prometheus.HistogramVec
        HTTPResponseSize    *prometheus.HistogramVec

        // Database metrics
        DBConnectionsActive prometheus.Gauge
        DBQueriesTotal      *prometheus.CounterVec
        DBQueryDuration     *prometheus.HistogramVec
        DBErrors            *prometheus.CounterVec
}

// NewServiceMetrics creates and registers all service metrics
func NewServiceMetrics(namespace string) *ServiceMetrics <span class="cov0" title="0">{
        return &amp;ServiceMetrics{
                BuildInfo: promauto.NewGaugeVec(prometheus.GaugeOpts{
                        Namespace: namespace,
                        Name:      "build_info",
                        Help:      "Build information",
                }, []string{"version", "commit", "build_time"}),
                StartTime: promauto.NewGauge(prometheus.GaugeOpts{
                        Namespace: namespace,
                        Name:      "start_time_seconds",
                        Help:      "Unix timestamp of service start time",
                }),

                // HTTP metrics
                HTTPRequestsTotal: promauto.NewCounterVec(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: "http",
                        Name:      "requests_total",
                        Help:      "Total number of HTTP requests",
                }, []string{"method", "path", "status"}),
                HTTPRequestDuration: promauto.NewHistogramVec(prometheus.HistogramOpts{
                        Namespace: namespace,
                        Subsystem: "http",
                        Name:      "request_duration_seconds",
                        Help:      "HTTP request duration in seconds",
                        Buckets:   prometheus.DefBuckets,
                }, []string{"method", "path"}),
                HTTPResponseSize: promauto.NewHistogramVec(prometheus.HistogramOpts{
                        Namespace: namespace,
                        Subsystem: "http",
                        Name:      "response_size_bytes",
                        Help:      "HTTP response size in bytes",
                        Buckets:   prometheus.ExponentialBuckets(100, 2, 10),
                }, []string{"method", "path"}),

                // Database metrics
                DBConnectionsActive: promauto.NewGauge(prometheus.GaugeOpts{
                        Namespace: namespace,
                        Subsystem: "database",
                        Name:      "connections_active",
                        Help:      "Number of active database connections",
                }),
                DBQueriesTotal: promauto.NewCounterVec(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: "database",
                        Name:      "queries_total",
                        Help:      "Total number of database queries",
                }, []string{"query_type", "table"}),
                DBQueryDuration: promauto.NewHistogramVec(prometheus.HistogramOpts{
                        Namespace: namespace,
                        Subsystem: "database",
                        Name:      "query_duration_seconds",
                        Help:      "Database query duration in seconds",
                        Buckets:   prometheus.DefBuckets,
                }, []string{"query_type"}),
                DBErrors: promauto.NewCounterVec(prometheus.CounterOpts{
                        Namespace: namespace,
                        Subsystem: "database",
                        Name:      "errors_total",
                        Help:      "Total number of database errors",
                }, []string{"error_type"}),
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package ttyrec

import (
        "fmt"
        "github.com/dungeongate/pkg/config"
)

// Recorder handles TTY recording
type Recorder struct {
        config *config.TTYRecConfig
        // Add actual recording fields here
}

// Session represents a recording session
type Session struct {
        ID       string
        Username string
        GameID   string
        // Add recording session fields here
}

// NewRecorder creates a new TTY recorder
func NewRecorder(cfg *config.TTYRecConfig) (*Recorder, error) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TTY recording configuration is required")
        }</span>

        <span class="cov0" title="0">return &amp;Recorder{
                config: cfg,
        }, nil</span>
}

// StartRecording starts recording a session
func (r *Recorder) StartRecording(sessionID, username, gameID string) (*Session, error) <span class="cov0" title="0">{
        return &amp;Session{
                ID:       sessionID,
                Username: username,
                GameID:   gameID,
        }, nil
}</span>

// StopRecording stops recording a session
func (r *Recorder) StopRecording(sessionID string) error <span class="cov0" title="0">{
        // Implementation would stop recording
        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
